; Zilog eZ80 ANSI C Compiler Release 3.4
; -nomodsect -optsize -noreduceopt -nopadbranch -debug
; -peephole -globalopt -localcse -const=ROM 
	FILE	"..\src_fatfs\ff.c"
	.assume ADL=1
.DEBUG "C"
	SEGMENT CODE
.BEGREC "NONAME0",558
.DEFINE "fs_type"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pdrv"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "n_fats"
.VALUE 2
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "wflag"
.VALUE 3
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "fsi_flag"
.VALUE 4
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "id"
.VALUE 5
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "n_rootdir"
.VALUE 7
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "csize"
.VALUE 9
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "lfnbuf"
.VALUE 11
.CLASS 8
.TYPE 45
.ENDEF
.DEFINE "cdir"
.VALUE 14
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "n_fatent"
.VALUE 18
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "fsize"
.VALUE 22
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "volbase"
.VALUE 26
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "fatbase"
.VALUE 30
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "dirbase"
.VALUE 34
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "database"
.VALUE 38
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "winsect"
.VALUE 42
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "win"
.VALUE 46
.CLASS 8
.DIM 512
.TYPE 108
.ENDEF
.ENDREC "NONAME0"
.BEGREC "NONAME1",15
.DEFINE "fs"
.VALUE 0
.CLASS 8
.TAG "NONAME0"
.TYPE 40
.ENDEF
.DEFINE "id"
.VALUE 3
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "attr"
.VALUE 5
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "stat"
.VALUE 6
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "sclust"
.VALUE 7
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "objsize"
.VALUE 11
.CLASS 8
.TYPE 15
.ENDEF
.ENDREC "NONAME1"
.BEGREC "NONAME2",541
.DEFINE "obj"
.VALUE 0
.CLASS 8
.TAG "NONAME1"
.TYPE 8
.ENDEF
.DEFINE "flag"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "err"
.VALUE 16
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "fptr"
.VALUE 17
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "clust"
.VALUE 21
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "sect"
.VALUE 25
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "buf"
.VALUE 29
.CLASS 8
.DIM 512
.TYPE 108
.ENDEF
.ENDREC "NONAME2"
.BEGREC "NONAME3",46
.DEFINE "obj"
.VALUE 0
.CLASS 8
.TAG "NONAME1"
.TYPE 8
.ENDEF
.DEFINE "dptr"
.VALUE 15
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "clust"
.VALUE 19
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "sect"
.VALUE 23
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "dir"
.VALUE 27
.CLASS 8
.TYPE 44
.ENDEF
.DEFINE "fn"
.VALUE 30
.CLASS 8
.DIM 12
.TYPE 108
.ENDEF
.DEFINE "blk_ofs"
.VALUE 42
.CLASS 8
.TYPE 15
.ENDEF
.ENDREC "NONAME3"
.BEGREC "NONAME4",278
.DEFINE "fsize"
.VALUE 0
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "fdate"
.VALUE 4
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "ftime"
.VALUE 6
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "fattrib"
.VALUE 8
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "altname"
.VALUE 9
.CLASS 8
.DIM 13
.TYPE 98
.ENDEF
.DEFINE "fname"
.VALUE 22
.CLASS 8
.DIM 256
.TYPE 98
.ENDEF
.ENDREC "NONAME4"
.BEGREC "NONAME5",12
.DEFINE "fmt"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "n_fat"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "align"
.VALUE 2
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "n_root"
.VALUE 5
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "au_size"
.VALUE 8
.CLASS 8
.TYPE 15
.ENDEF
.ENDREC "NONAME5"
	SEGMENT BSS
_FatFs:
	DS	3
.DEFINE "FatFs"
.ALIAS "_FatFs"
.CLASS 83
.VALUE _FatFs
.DIM 1
.TAG "NONAME0"
.TYPE 360
.ENDEF
_Fsid:
	DS	2*1
.DEFINE "Fsid"
.ALIAS "_Fsid"
.CLASS 83
.VALUE _Fsid
.TYPE 13
.ENDEF
_CurrVol:
	DS	1
.DEFINE "CurrVol"
.ALIAS "_CurrVol"
.CLASS 83
.VALUE _CurrVol
.TYPE 12
.ENDEF
	SEGMENT TEXT
_LfnOfs:
	DB	1
	DB	3
	DB	5
	DB	7
	DB	9
	DB	14
	DB	16
	DB	18
	DB	20
	DB	22
	DB	24
	DB	28
	DB	30
.DEFINE "LfnOfs"
.ALIAS "_LfnOfs"
.CLASS 84
.VALUE _LfnOfs
.DIM 13
.TYPE 108
.ENDEF
_ExCvt:
	DB	128
	DB	154
	DB	69
	DB	65
	DB	142
	DB	65
	DB	143
	DB	128
	DB	69
	DB	69
	DB	69
	DB	73
	DB	73
	DB	73
	DB	142
	DB	143
	DB	144
	DB	146
	DB	146
	DB	79
	DB	153
	DB	79
	DB	85
	DB	85
	DB	89
	DB	153
	DB	154
	DB	155
	DB	156
	DB	157
	DB	158
	DB	159
	DB	65
	DB	73
	DB	79
	DB	85
	DB	165
	DB	165
	DB	166
	DB	167
	DB	168
	DB	169
	DB	170
	DB	171
	DB	172
	DB	173
	DB	174
	DB	175
	DB	176
	DB	177
	DB	178
	DB	179
	DB	180
	DB	181
	DB	182
	DB	183
	DB	184
	DB	185
	DB	186
	DB	187
	DB	188
	DB	189
	DB	190
	DB	191
	DB	192
	DB	193
	DB	194
	DB	195
	DB	196
	DB	197
	DB	198
	DB	199
	DB	200
	DB	201
	DB	202
	DB	203
	DB	204
	DB	205
	DB	206
	DB	207
	DB	208
	DB	209
	DB	210
	DB	211
	DB	212
	DB	213
	DB	214
	DB	215
	DB	216
	DB	217
	DB	218
	DB	219
	DB	220
	DB	221
	DB	222
	DB	223
	DB	224
	DB	225
	DB	226
	DB	227
	DB	228
	DB	229
	DB	230
	DB	231
	DB	232
	DB	233
	DB	234
	DB	235
	DB	236
	DB	237
	DB	238
	DB	239
	DB	240
	DB	241
	DB	242
	DB	243
	DB	244
	DB	245
	DB	246
	DB	247
	DB	248
	DB	249
	DB	250
	DB	251
	DB	252
	DB	253
	DB	254
	DB	255
.DEFINE "ExCvt"
.ALIAS "_ExCvt"
.CLASS 84
.VALUE _ExCvt
.DIM 128
.TYPE 108
.ENDEF
;    1	/*----------------------------------------------------------------------------/
;    2	/  FatFs - Generic FAT Filesystem Module  R0.14b                              /
;    3	/-----------------------------------------------------------------------------/
;    4	/
;    5	/ Copyright (C) 2021, ChaN, all right reserved.
;    6	/
;    7	/ FatFs module is an open source software. Redistribution and use of FatFs in
;    8	/ source and binary forms, with or without modification, are permitted provided
;    9	/ that the following condition is met:
;   10	/
;   11	/ 1. Redistributions of source code must retain the above copyright notice,
;   12	/    this condition and the following disclaimer.
;   13	/
;   14	/ This software is provided by the copyright holder and contributors "AS IS"
;   15	/ and any warranties related to this software are DISCLAIMED.
;   16	/ The copyright owner or contributors be NOT LIABLE for any damages caused
;   17	/ by use of this software.
;   18	/
;   19	/----------------------------------------------------------------------------*/
;   20	
;   21	#include <string.h>
;   22	
;   23	#include "ff.h"			/* Declarations of FatFs API */
;   24	#include "diskio.h"		/* Declarations of device I/O functions */
;   25	
;   26	
;   27	/*--------------------------------------------------------------------------
;   28	
;   29	   Module Private Definitions
;   30	
;   31	---------------------------------------------------------------------------*/
;   32	
;   33	#if FF_DEFINED != 86631	/* Revision ID */
;   34	#error Wrong include file (ff.h).
;   35	#endif
;   36	
;   37	
;   38	/* Limits and boundaries */
;   39	#define MAX_DIR		0x200000		/* Max size of FAT directory */
;   40	#define MAX_DIR_EX	0x10000000		/* Max size of exFAT directory */
;   41	#define MAX_FAT12	0xFF5			/* Max FAT12 clusters (differs from specs, but right for real DOS/Windows behavior) */
;   42	#define MAX_FAT16	0xFFF5			/* Max FAT16 clusters (differs from specs, but right for real DOS/Windows behavior) */
;   43	#define MAX_FAT32	0x0FFFFFF5		/* Max FAT32 clusters (not specified, practical limit) */
;   44	#define MAX_EXFAT	0x7FFFFFFD		/* Max exFAT clusters (differs from specs, implementation limit) */
;   45	
;   46	
;   47	/* Character code support macros */
;   48	#define IsUpper(c)		((c) >= 'A' && (c) <= 'Z')
;   49	#define IsLower(c)		((c) >= 'a' && (c) <= 'z')
;   50	#define IsDigit(c)		((c) >= '0' && (c) <= '9')
;   51	#define IsSeparator(c)	((c) == '/' || (c) == '\\')
;   52	#define IsTerminator(c)	((UINT)(c) < (FF_USE_LFN ? ' ' : '!'))
;   53	#define IsSurrogate(c)	((c) >= 0xD800 && (c) <= 0xDFFF)
;   54	#define IsSurrogateH(c)	((c) >= 0xD800 && (c) <= 0xDBFF)
;   55	#define IsSurrogateL(c)	((c) >= 0xDC00 && (c) <= 0xDFFF)
;   56	
;   57	
;   58	/* Additional file access control and file status flags for internal use */
;   59	#define FA_SEEKEND	0x20	/* Seek to end of the file on file open */
;   60	#define FA_MODIFIED	0x40	/* File has been modified */
;   61	#define FA_DIRTY	0x80	/* FIL.buf[] needs to be written-back */
;   62	
;   63	
;   64	/* Additional file attribute bits for internal use */
;   65	#define AM_VOL		0x08	/* Volume label */
;   66	#define AM_LFN		0x0F	/* LFN entry */
;   67	#define AM_MASK		0x3F	/* Mask of defined bits in FAT */
;   68	#define AM_MASKX	0x37	/* Mask of defined bits in exFAT */
;   69	
;   70	
;   71	/* Name status flags in fn[11] */
;   72	#define NSFLAG		11		/* Index of the name status byte */
;   73	#define NS_LOSS		0x01	/* Out of 8.3 format */
;   74	#define NS_LFN		0x02	/* Force to create LFN entry */
;   75	#define NS_LAST		0x04	/* Last segment */
;   76	#define NS_BODY		0x08	/* Lower case flag (body) */
;   77	#define NS_EXT		0x10	/* Lower case flag (ext) */
;   78	#define NS_DOT		0x20	/* Dot entry */
;   79	#define NS_NOLFN	0x40	/* Do not find LFN */
;   80	#define NS_NONAME	0x80	/* Not followed */
;   81	
;   82	
;   83	/* exFAT directory entry types */
;   84	#define	ET_BITMAP	0x81	/* Allocation bitmap */
;   85	#define	ET_UPCASE	0x82	/* Up-case table */
;   86	#define	ET_VLABEL	0x83	/* Volume label */
;   87	#define	ET_FILEDIR	0x85	/* File and directory */
;   88	#define	ET_STREAM	0xC0	/* Stream extension */
;   89	#define	ET_FILENAME	0xC1	/* Name extension */
;   90	
;   91	
;   92	/* FatFs refers the FAT structure as simple byte array instead of structure member
;   93	/ because the C structure is not binary compatible between different platforms */
;   94	
;   95	#define BS_JmpBoot			0		/* x86 jump instruction (3-byte) */
;   96	#define BS_OEMName			3		/* OEM name (8-byte) */
;   97	#define BPB_BytsPerSec		11		/* Sector size [byte] (WORD) */
;   98	#define BPB_SecPerClus		13		/* Cluster size [sector] (BYTE) */
;   99	#define BPB_RsvdSecCnt		14		/* Size of reserved area [sector] (WORD) */
;  100	#define BPB_NumFATs			16		/* Number of FATs (BYTE) */
;  101	#define BPB_RootEntCnt		17		/* Size of root directory area for FAT [entry] (WORD) */
;  102	#define BPB_TotSec16		19		/* Volume size (16-bit) [sector] (WORD) */
;  103	#define BPB_Media			21		/* Media descriptor byte (BYTE) */
;  104	#define BPB_FATSz16			22		/* FAT size (16-bit) [sector] (WORD) */
;  105	#define BPB_SecPerTrk		24		/* Number of sectors per track for int13h [sector] (WORD) */
;  106	#define BPB_NumHeads		26		/* Number of heads for int13h (WORD) */
;  107	#define BPB_HiddSec			28		/* Volume offset from top of the drive (DWORD) */
;  108	#define BPB_TotSec32		32		/* Volume size (32-bit) [sector] (DWORD) */
;  109	#define BS_DrvNum			36		/* Physical drive number for int13h (BYTE) */
;  110	#define BS_NTres			37		/* WindowsNT error flag (BYTE) */
;  111	#define BS_BootSig			38		/* Extended boot signature (BYTE) */
;  112	#define BS_VolID			39		/* Volume serial number (DWORD) */
;  113	#define BS_VolLab			43		/* Volume label string (8-byte) */
;  114	#define BS_FilSysType		54		/* Filesystem type string (8-byte) */
;  115	#define BS_BootCode			62		/* Boot code (448-byte) */
;  116	#define BS_55AA				510		/* Signature word (WORD) */
;  117	
;  118	#define BPB_FATSz32			36		/* FAT32: FAT size [sector] (DWORD) */
;  119	#define BPB_ExtFlags32		40		/* FAT32: Extended flags (WORD) */
;  120	#define BPB_FSVer32			42		/* FAT32: Filesystem version (WORD) */
;  121	#define BPB_RootClus32		44		/* FAT32: Root directory cluster (DWORD) */
;  122	#define BPB_FSInfo32		48		/* FAT32: Offset of FSINFO sector (WORD) */
;  123	#define BPB_BkBootSec32		50		/* FAT32: Offset of backup boot sector (WORD) */
;  124	#define BS_DrvNum32			64		/* FAT32: Physical drive number for int13h (BYTE) */
;  125	#define BS_NTres32			65		/* FAT32: Error flag (BYTE) */
;  126	#define BS_BootSig32		66		/* FAT32: Extended boot signature (BYTE) */
;  127	#define BS_VolID32			67		/* FAT32: Volume serial number (DWORD) */
;  128	#define BS_VolLab32			71		/* FAT32: Volume label string (8-byte) */
;  129	#define BS_FilSysType32		82		/* FAT32: Filesystem type string (8-byte) */
;  130	#define BS_BootCode32		90		/* FAT32: Boot code (420-byte) */
;  131	
;  132	#define BPB_ZeroedEx		11		/* exFAT: MBZ field (53-byte) */
;  133	#define BPB_VolOfsEx		64		/* exFAT: Volume offset from top of the drive [sector] (QWORD) */
;  134	#define BPB_TotSecEx		72		/* exFAT: Volume size [sector] (QWORD) */
;  135	#define BPB_FatOfsEx		80		/* exFAT: FAT offset from top of the volume [sector] (DWORD) */
;  136	#define BPB_FatSzEx			84		/* exFAT: FAT size [sector] (DWORD) */
;  137	#define BPB_DataOfsEx		88		/* exFAT: Data offset from top of the volume [sector] (DWORD) */
;  138	#define BPB_NumClusEx		92		/* exFAT: Number of clusters (DWORD) */
;  139	#define BPB_RootClusEx		96		/* exFAT: Root directory start cluster (DWORD) */
;  140	#define BPB_VolIDEx			100		/* exFAT: Volume serial number (DWORD) */
;  141	#define BPB_FSVerEx			104		/* exFAT: Filesystem version (WORD) */
;  142	#define BPB_VolFlagEx		106		/* exFAT: Volume flags (WORD) */
;  143	#define BPB_BytsPerSecEx	108		/* exFAT: Log2 of sector size in unit of byte (BYTE) */
;  144	#define BPB_SecPerClusEx	109		/* exFAT: Log2 of cluster size in unit of sector (BYTE) */
;  145	#define BPB_NumFATsEx		110		/* exFAT: Number of FATs (BYTE) */
;  146	#define BPB_DrvNumEx		111		/* exFAT: Physical drive number for int13h (BYTE) */
;  147	#define BPB_PercInUseEx		112		/* exFAT: Percent in use (BYTE) */
;  148	#define BPB_RsvdEx			113		/* exFAT: Reserved (7-byte) */
;  149	#define BS_BootCodeEx		120		/* exFAT: Boot code (390-byte) */
;  150	
;  151	#define DIR_Name			0		/* Short file name (11-byte) */
;  152	#define DIR_Attr			11		/* Attribute (BYTE) */
;  153	#define DIR_NTres			12		/* Lower case flag (BYTE) */
;  154	#define DIR_CrtTime10		13		/* Created time sub-second (BYTE) */
;  155	#define DIR_CrtTime			14		/* Created time (DWORD) */
;  156	#define DIR_LstAccDate		18		/* Last accessed date (WORD) */
;  157	#define DIR_FstClusHI		20		/* Higher 16-bit of first cluster (WORD) */
;  158	#define DIR_ModTime			22		/* Modified time (DWORD) */
;  159	#define DIR_FstClusLO		26		/* Lower 16-bit of first cluster (WORD) */
;  160	#define DIR_FileSize		28		/* File size (DWORD) */
;  161	#define LDIR_Ord			0		/* LFN: LFN order and LLE flag (BYTE) */
;  162	#define LDIR_Attr			11		/* LFN: LFN attribute (BYTE) */
;  163	#define LDIR_Type			12		/* LFN: Entry type (BYTE) */
;  164	#define LDIR_Chksum			13		/* LFN: Checksum of the SFN (BYTE) */
;  165	#define LDIR_FstClusLO		26		/* LFN: MBZ field (WORD) */
;  166	#define XDIR_Type			0		/* exFAT: Type of exFAT directory entry (BYTE) */
;  167	#define XDIR_NumLabel		1		/* exFAT: Number of volume label characters (BYTE) */
;  168	#define XDIR_Label			2		/* exFAT: Volume label (11-WORD) */
;  169	#define XDIR_CaseSum		4		/* exFAT: Sum of case conversion table (DWORD) */
;  170	#define XDIR_NumSec			1		/* exFAT: Number of secondary entries (BYTE) */
;  171	#define XDIR_SetSum			2		/* exFAT: Sum of the set of directory entries (WORD) */
;  172	#define XDIR_Attr			4		/* exFAT: File attribute (WORD) */
;  173	#define XDIR_CrtTime		8		/* exFAT: Created time (DWORD) */
;  174	#define XDIR_ModTime		12		/* exFAT: Modified time (DWORD) */
;  175	#define XDIR_AccTime		16		/* exFAT: Last accessed time (DWORD) */
;  176	#define XDIR_CrtTime10		20		/* exFAT: Created time subsecond (BYTE) */
;  177	#define XDIR_ModTime10		21		/* exFAT: Modified time subsecond (BYTE) */
;  178	#define XDIR_CrtTZ			22		/* exFAT: Created timezone (BYTE) */
;  179	#define XDIR_ModTZ			23		/* exFAT: Modified timezone (BYTE) */
;  180	#define XDIR_AccTZ			24		/* exFAT: Last accessed timezone (BYTE) */
;  181	#define XDIR_GenFlags		33		/* exFAT: General secondary flags (BYTE) */
;  182	#define XDIR_NumName		35		/* exFAT: Number of file name characters (BYTE) */
;  183	#define XDIR_NameHash		36		/* exFAT: Hash of file name (WORD) */
;  184	#define XDIR_ValidFileSize	40		/* exFAT: Valid file size (QWORD) */
;  185	#define XDIR_FstClus		52		/* exFAT: First cluster of the file data (DWORD) */
;  186	#define XDIR_FileSize		56		/* exFAT: File/Directory size (QWORD) */
;  187	
;  188	#define SZDIRE				32		/* Size of a directory entry */
;  189	#define DDEM				0xE5	/* Deleted directory entry mark set to DIR_Name[0] */
;  190	#define RDDEM				0x05	/* Replacement of the character collides with DDEM */
;  191	#define LLEF				0x40	/* Last long entry flag in LDIR_Ord */
;  192	
;  193	#define FSI_LeadSig			0		/* FAT32 FSI: Leading signature (DWORD) */
;  194	#define FSI_StrucSig		484		/* FAT32 FSI: Structure signature (DWORD) */
;  195	#define FSI_Free_Count		488		/* FAT32 FSI: Number of free clusters (DWORD) */
;  196	#define FSI_Nxt_Free		492		/* FAT32 FSI: Last allocated cluster (DWORD) */
;  197	
;  198	#define MBR_Table			446		/* MBR: Offset of partition table in the MBR */
;  199	#define SZ_PTE				16		/* MBR: Size of a partition table entry */
;  200	#define PTE_Boot			0		/* MBR PTE: Boot indicator */
;  201	#define PTE_StHead			1		/* MBR PTE: Start head */
;  202	#define PTE_StSec			2		/* MBR PTE: Start sector */
;  203	#define PTE_StCyl			3		/* MBR PTE: Start cylinder */
;  204	#define PTE_System			4		/* MBR PTE: System ID */
;  205	#define PTE_EdHead			5		/* MBR PTE: End head */
;  206	#define PTE_EdSec			6		/* MBR PTE: End sector */
;  207	#define PTE_EdCyl			7		/* MBR PTE: End cylinder */
;  208	#define PTE_StLba			8		/* MBR PTE: Start in LBA */
;  209	#define PTE_SizLba			12		/* MBR PTE: Size in LBA */
;  210	
;  211	#define GPTH_Sign			0		/* GPT: Header signature (8-byte) */
;  212	#define GPTH_Rev			8		/* GPT: Revision (DWORD) */
;  213	#define GPTH_Size			12		/* GPT: Header size (DWORD) */
;  214	#define GPTH_Bcc			16		/* GPT: Header BCC (DWORD) */
;  215	#define GPTH_CurLba			24		/* GPT: Main header LBA (QWORD) */
;  216	#define GPTH_BakLba			32		/* GPT: Backup header LBA (QWORD) */
;  217	#define GPTH_FstLba			40		/* GPT: First LBA for partitions (QWORD) */
;  218	#define GPTH_LstLba			48		/* GPT: Last LBA for partitions (QWORD) */
;  219	#define GPTH_DskGuid		56		/* GPT: Disk GUID (16-byte) */
;  220	#define GPTH_PtOfs			72		/* GPT: Partation table LBA (QWORD) */
;  221	#define GPTH_PtNum			80		/* GPT: Number of table entries (DWORD) */
;  222	#define GPTH_PteSize		84		/* GPT: Size of table entry (DWORD) */
;  223	#define GPTH_PtBcc			88		/* GPT: Partation table BCC (DWORD) */
;  224	#define SZ_GPTE				128		/* GPT: Size of partition table entry */
;  225	#define GPTE_PtGuid			0		/* GPT PTE: Partition type GUID (16-byte) */
;  226	#define GPTE_UpGuid			16		/* GPT PTE: Partition unique GUID (16-byte) */
;  227	#define GPTE_FstLba			32		/* GPT PTE: First LBA (QWORD) */
;  228	#define GPTE_LstLba			40		/* GPT PTE: Last LBA inclusive (QWORD) */
;  229	#define GPTE_Flags			48		/* GPT PTE: Flags (QWORD) */
;  230	#define GPTE_Name			56		/* GPT PTE: Name */
;  231	
;  232	
;  233	/* Post process on fatal error in the file operations */
;  234	#define ABORT(fs, res)		{ fp->err = (BYTE)(res); LEAVE_FF(fs, res); }
;  235	
;  236	
;  237	/* Re-entrancy related */
;  238	#if FF_FS_REENTRANT
;  239	#if FF_USE_LFN == 1
;  240	#error Static LFN work area cannot be used in thread-safe configuration
;  241	#endif
;  242	#define LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
;  243	#else
;  244	#define LEAVE_FF(fs, res)	return res
;  245	#endif
;  246	
;  247	
;  248	/* Definitions of logical drive - physical location conversion */
;  249	#if FF_MULTI_PARTITION
;  250	#define LD2PD(vol) VolToPart[vol].pd	/* Get physical drive number */
;  251	#define LD2PT(vol) VolToPart[vol].pt	/* Get partition number (0:auto search, 1..:forced partition number) */
;  252	#else
;  253	#define LD2PD(vol) (BYTE)(vol)	/* Each logical drive is associated with the same physical drive number */
;  254	#define LD2PT(vol) 0			/* Auto partition search */
;  255	#endif
;  256	
;  257	
;  258	/* Definitions of sector size */
;  259	#if (FF_MAX_SS < FF_MIN_SS) || (FF_MAX_SS != 512 && FF_MAX_SS != 1024 && FF_MAX_SS != 2048 && FF_MAX_SS != 4096) || (FF_MIN_SS != 512 && FF_MIN_SS != 1024 && FF_MIN_SS != 2048 && FF_MIN_SS != 4096)
;  260	#error Wrong sector size configuration
;  261	#endif
;  262	#if FF_MAX_SS == FF_MIN_SS
;  263	#define SS(fs)	((UINT)FF_MAX_SS)	/* Fixed sector size */
;  264	#else
;  265	#define SS(fs)	((fs)->ssize)	/* Variable sector size */
;  266	#endif
;  267	
;  268	
;  269	/* Timestamp */
;  270	#if FF_FS_NORTC == 1
;  271	#if FF_NORTC_YEAR < 1980 || FF_NORTC_YEAR > 2107 || FF_NORTC_MON < 1 || FF_NORTC_MON > 12 || FF_NORTC_MDAY < 1 || FF_NORTC_MDAY > 31
;  272	#error Invalid FF_FS_NORTC settings
;  273	#endif
;  274	#define GET_FATTIME()	((DWORD)(FF_NORTC_YEAR - 1980) << 25 | (DWORD)FF_NORTC_MON << 21 | (DWORD)FF_NORTC_MDAY << 16)
;  275	#else
;  276	#define GET_FATTIME()	get_fattime()
;  277	#endif
;  278	
;  279	
;  280	/* File lock controls */
;  281	#if FF_FS_LOCK != 0
;  282	#if FF_FS_READONLY
;  283	#error FF_FS_LOCK must be 0 at read-only configuration
;  284	#endif
;  285	typedef struct {
;  286		FATFS *fs;		/* Object ID 1, volume (NULL:blank entry) */
;  287		DWORD clu;		/* Object ID 2, containing directory (0:root) */
;  288		DWORD ofs;		/* Object ID 3, offset in the directory */
;  289		WORD ctr;		/* Object open counter, 0:none, 0x01..0xFF:read mode open count, 0x100:write mode */
;  290	} FILESEM;
;  291	#endif
;  292	
;  293	
;  294	/* SBCS up-case tables (\x80-\xFF) */
;  295	#define TBL_CT437  {0x80,0x9A,0x45,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, \
;  296						0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
;  297						0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
;  298						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
;  299						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  300						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
;  301						0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
;  302						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
;  303	#define TBL_CT720  {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
;  304						0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
;  305						0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
;  306						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
;  307						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  308						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
;  309						0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
;  310						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
;  311	#define TBL_CT737  {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
;  312						0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
;  313						0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96, \
;  314						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
;  315						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  316						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
;  317						0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xEF,0xF5,0xF0,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
;  318						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
;  319	#define TBL_CT771  {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
;  320						0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
;  321						0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
;  322						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
;  323						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  324						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDC,0xDE,0xDE, \
;  325						0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
;  326						0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFE,0xFF}
;  327	#define TBL_CT775  {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F, \
;  328						0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
;  329						0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
;  330						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
;  331						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  332						0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
;  333						0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF, \
;  334						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
;  335	#define TBL_CT850  {0x43,0x55,0x45,0x41,0x41,0x41,0x41,0x43,0x45,0x45,0x45,0x49,0x49,0x49,0x41,0x41, \
;  336						0x45,0x92,0x92,0x4F,0x4F,0x4F,0x55,0x55,0x59,0x4F,0x55,0x4F,0x9C,0x4F,0x9E,0x9F, \
;  337						0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
;  338						0xB0,0xB1,0xB2,0xB3,0xB4,0x41,0x41,0x41,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
;  339						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0x41,0x41,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  340						0xD1,0xD1,0x45,0x45,0x45,0x49,0x49,0x49,0x49,0xD9,0xDA,0xDB,0xDC,0xDD,0x49,0xDF, \
;  341						0x4F,0xE1,0x4F,0x4F,0x4F,0x4F,0xE6,0xE8,0xE8,0x55,0x55,0x55,0x59,0x59,0xEE,0xEF, \
;  342						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
;  343	#define TBL_CT852  {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F, \
;  344						0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0xAC, \
;  345						0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF, \
;  346						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
;  347						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  348						0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
;  349						0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF, \
;  350						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
;  351	#define TBL_CT855  {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F, \
;  352						0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
;  353						0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF, \
;  354						0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
;  355						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  356						0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
;  357						0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF, \
;  358						0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
;  359	#define TBL_CT857  {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x49,0x8E,0x8F, \
;  360						0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
;  361						0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
;  362						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
;  363						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  364						0xD0,0xD1,0xD2,0xD3,0xD4,0x49,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
;  365						0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0xED,0xEE,0xEF, \
;  366						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
;  367	#define TBL_CT860  {0x80,0x9A,0x90,0x8F,0x8E,0x91,0x86,0x80,0x89,0x89,0x92,0x8B,0x8C,0x98,0x8E,0x8F, \
;  368						0x90,0x91,0x92,0x8C,0x99,0xA9,0x96,0x9D,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
;  369						0x86,0x8B,0x9F,0x96,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
;  370						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
;  371						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  372						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
;  373						0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
;  374						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
;  375	#define TBL_CT861  {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x8B,0x8B,0x8D,0x8E,0x8F, \
;  376						0x90,0x92,0x92,0x4F,0x99,0x8D,0x55,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
;  377						0xA4,0xA5,0xA6,0xA7,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
;  378						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
;  379						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  380						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
;  381						0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
;  382						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
;  383	#define TBL_CT862  {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
;  384						0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
;  385						0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
;  386						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
;  387						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  388						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
;  389						0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
;  390						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
;  391	#define TBL_CT863  {0x43,0x55,0x45,0x41,0x41,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x41,0x8F, \
;  392						0x45,0x45,0x45,0x4F,0x45,0x49,0x55,0x55,0x98,0x4F,0x55,0x9B,0x9C,0x55,0x55,0x9F, \
;  393						0xA0,0xA1,0x4F,0x55,0xA4,0xA5,0xA6,0xA7,0x49,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
;  394						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
;  395						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  396						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
;  397						0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
;  398						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
;  399	#define TBL_CT864  {0x80,0x9A,0x45,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, \
;  400						0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
;  401						0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
;  402						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
;  403						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  404						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
;  405						0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
;  406						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
;  407	#define TBL_CT865  {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, \
;  408						0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
;  409						0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
;  410						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
;  411						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  412						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
;  413						0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
;  414						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
;  415	#define TBL_CT866  {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
;  416						0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
;  417						0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
;  418						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
;  419						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  420						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
;  421						0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
;  422						0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
;  423	#define TBL_CT869  {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
;  424						0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x86,0x9C,0x8D,0x8F,0x90, \
;  425						0x91,0x90,0x92,0x95,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
;  426						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
;  427						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  428						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xA4,0xA5,0xA6,0xD9,0xDA,0xDB,0xDC,0xA7,0xA8,0xDF, \
;  429						0xA9,0xAA,0xAC,0xAD,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xCF,0xCF,0xD0,0xEF, \
;  430						0xF0,0xF1,0xD1,0xD2,0xD3,0xF5,0xD4,0xF7,0xF8,0xF9,0xD5,0x96,0x95,0x98,0xFE,0xFF}
;  431	
;  432	
;  433	/* DBCS code range |----- 1st byte -----|  |----------- 2nd byte -----------| */
;  434	/*                  <------>    <------>    <------>    <------>    <------>  */
;  435	#define TBL_DC932 {0x81, 0x9F, 0xE0, 0xFC, 0x40, 0x7E, 0x80, 0xFC, 0x00, 0x00}
;  436	#define TBL_DC936 {0x81, 0xFE, 0x00, 0x00, 0x40, 0x7E, 0x80, 0xFE, 0x00, 0x00}
;  437	#define TBL_DC949 {0x81, 0xFE, 0x00, 0x00, 0x41, 0x5A, 0x61, 0x7A, 0x81, 0xFE}
;  438	#define TBL_DC950 {0x81, 0xFE, 0x00, 0x00, 0x40, 0x7E, 0xA1, 0xFE, 0x00, 0x00}
;  439	
;  440	
;  441	/* Macros for table definitions */
;  442	#define MERGE_2STR(a, b) a ## b
;  443	#define MKCVTBL(hd, cp) MERGE_2STR(hd, cp)
;  444	
;  445	
;  446	
;  447	
;  448	/*--------------------------------------------------------------------------
;  449	
;  450	   Module Private Work Area
;  451	
;  452	---------------------------------------------------------------------------*/
;  453	/* Remark: Variables defined here without initial value shall be guaranteed
;  454	/  zero/null at start-up. If not, the linker option or start-up routine is
;  455	/  not compliance with C standard. */
;  456	
;  457	/*--------------------------------*/
;  458	/* File/Volume controls           */
;  459	/*--------------------------------*/
;  460	
;  461	#if FF_VOLUMES < 1 || FF_VOLUMES > 10
;  462	#error Wrong FF_VOLUMES setting
;  463	#endif
;  464	static FATFS* FatFs[FF_VOLUMES];	/* Pointer to the filesystem objects (logical drives) */
;  465	static WORD Fsid;					/* Filesystem mount ID */
;  466	
;  467	#if FF_FS_RPATH != 0
;  468	static BYTE CurrVol;				/* Current drive */
;  469	#endif
;  470	
;  471	#if FF_FS_LOCK != 0
;  472	static FILESEM Files[FF_FS_LOCK];	/* Open object lock semaphores */
;  473	#endif
;  474	
;  475	#if FF_STR_VOLUME_ID
;  476	#ifdef FF_VOLUME_STRS
;  477	static const char* const VolumeStr[FF_VOLUMES] = {FF_VOLUME_STRS};	/* Pre-defined volume ID */
;  478	#endif
;  479	#endif
;  480	
;  481	#if FF_LBA64
;  482	#if FF_MIN_GPT > 0x100000000
;  483	#error Wrong FF_MIN_GPT setting
;  484	#endif
;  485	static const BYTE GUID_MS_Basic[16] = {0xA2,0xA0,0xD0,0xEB,0xE5,0xB9,0x33,0x44,0x87,0xC0,0x68,0xB6,0xB7,0x26,0x99,0xC7};
;  486	#endif
;  487	
;  488	
;  489	
;  490	/*--------------------------------*/
;  491	/* LFN/Directory working buffer   */
;  492	/*--------------------------------*/
;  493	
;  494	#if FF_USE_LFN == 0		/* Non-LFN configuration */
;  495	#if FF_FS_EXFAT
;  496	#error LFN must be enabled when enable exFAT
;  497	#endif
;  498	#define DEF_NAMBUF
;  499	#define INIT_NAMBUF(fs)
;  500	#define FREE_NAMBUF()
;  501	#define LEAVE_MKFS(res)	return res
;  502	
;  503	#else					/* LFN configurations */
;  504	#if FF_MAX_LFN < 12 || FF_MAX_LFN > 255
;  505	#error Wrong setting of FF_MAX_LFN
;  506	#endif
;  507	#if FF_LFN_BUF < FF_SFN_BUF || FF_SFN_BUF < 12
;  508	#error Wrong setting of FF_LFN_BUF or FF_SFN_BUF
;  509	#endif
;  510	#if FF_LFN_UNICODE < 0 || FF_LFN_UNICODE > 3
;  511	#error Wrong setting of FF_LFN_UNICODE
;  512	#endif
;  513	static const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* FAT: Offset of LFN characters in the directory entry */
;  514	#define MAXDIRB(nc)	((nc + 44U) / 15 * SZDIRE)	/* exFAT: Size of directory entry block scratchpad buffer needed for the name length */
;  515	
;  516	#if FF_USE_LFN == 1		/* LFN enabled with static working buffer */
;  517	#if FF_FS_EXFAT
;  518	static BYTE	DirBuf[MAXDIRB(FF_MAX_LFN)];	/* Directory entry block scratchpad buffer */
;  519	#endif
;  520	static WCHAR LfnBuf[FF_MAX_LFN + 1];		/* LFN working buffer */
;  521	#define DEF_NAMBUF
;  522	#define INIT_NAMBUF(fs)
;  523	#define FREE_NAMBUF()
;  524	#define LEAVE_MKFS(res)	return res
;  525	
;  526	#elif FF_USE_LFN == 2 	/* LFN enabled with dynamic working buffer on the stack */
;  527	#if FF_FS_EXFAT
;  528	#define DEF_NAMBUF		WCHAR lbuf[FF_MAX_LFN+1]; BYTE dbuf[MAXDIRB(FF_MAX_LFN)];	/* LFN working buffer and directory entry block scratchpad buffer */
;  529	#define INIT_NAMBUF(fs)	{ (fs)->lfnbuf = lbuf; (fs)->dirbuf = dbuf; }
;  530	#define FREE_NAMBUF()
;  531	#else
;  532	#define DEF_NAMBUF		WCHAR lbuf[FF_MAX_LFN+1];	/* LFN working buffer */
;  533	#define INIT_NAMBUF(fs)	{ (fs)->lfnbuf = lbuf; }
;  534	#define FREE_NAMBUF()
;  535	#endif
;  536	#define LEAVE_MKFS(res)	return res
;  537	
;  538	#elif FF_USE_LFN == 3 	/* LFN enabled with dynamic working buffer on the heap */
;  539	#if FF_FS_EXFAT
;  540	#define DEF_NAMBUF		WCHAR *lfn;	/* Pointer to LFN working buffer and directory entry block scratchpad buffer */
;  541	#define INIT_NAMBUF(fs)	{ lfn = ff_memalloc((FF_MAX_LFN+1)*2 + MAXDIRB(FF_MAX_LFN)); if (!lfn) LEAVE_FF(fs, FR_NOT_ENOUGH_CORE); (fs)->lfnbuf = lfn; (fs)->dirbuf = (BYTE*)(lfn+FF_MAX_LFN+1); }
;  542	#define FREE_NAMBUF()	ff_memfree(lfn)
;  543	#else
;  544	#define DEF_NAMBUF		WCHAR *lfn;	/* Pointer to LFN working buffer */
;  545	#define INIT_NAMBUF(fs)	{ lfn = ff_memalloc((FF_MAX_LFN+1)*2); if (!lfn) LEAVE_FF(fs, FR_NOT_ENOUGH_CORE); (fs)->lfnbuf = lfn; }
;  546	#define FREE_NAMBUF()	ff_memfree(lfn)
;  547	#endif
;  548	#define LEAVE_MKFS(res)	{ if (!work) ff_memfree(buf); return res; }
;  549	#define MAX_MALLOC	0x8000	/* Must be >=FF_MAX_SS */
;  550	
;  551	#else
;  552	#error Wrong setting of FF_USE_LFN
;  553	
;  554	#endif	/* FF_USE_LFN == 1 */
;  555	#endif	/* FF_USE_LFN == 0 */
;  556	
;  557	
;  558	
;  559	/*--------------------------------*/
;  560	/* Code conversion tables         */
;  561	/*--------------------------------*/
;  562	
;  563	#if FF_CODE_PAGE == 0	/* Run-time code page configuration */
;  564	#define CODEPAGE CodePage
;  565	static WORD CodePage;	/* Current code page */
;  566	static const BYTE *ExCvt, *DbcTbl;	/* Pointer to current SBCS up-case table and DBCS code range table below */
;  567	
;  568	static const BYTE Ct437[] = TBL_CT437;
;  569	static const BYTE Ct720[] = TBL_CT720;
;  570	static const BYTE Ct737[] = TBL_CT737;
;  571	static const BYTE Ct771[] = TBL_CT771;
;  572	static const BYTE Ct775[] = TBL_CT775;
;  573	static const BYTE Ct850[] = TBL_CT850;
;  574	static const BYTE Ct852[] = TBL_CT852;
;  575	static const BYTE Ct855[] = TBL_CT855;
;  576	static const BYTE Ct857[] = TBL_CT857;
;  577	static const BYTE Ct860[] = TBL_CT860;
;  578	static const BYTE Ct861[] = TBL_CT861;
;  579	static const BYTE Ct862[] = TBL_CT862;
;  580	static const BYTE Ct863[] = TBL_CT863;
;  581	static const BYTE Ct864[] = TBL_CT864;
;  582	static const BYTE Ct865[] = TBL_CT865;
;  583	static const BYTE Ct866[] = TBL_CT866;
;  584	static const BYTE Ct869[] = TBL_CT869;
;  585	static const BYTE Dc932[] = TBL_DC932;
;  586	static const BYTE Dc936[] = TBL_DC936;
;  587	static const BYTE Dc949[] = TBL_DC949;
;  588	static const BYTE Dc950[] = TBL_DC950;
;  589	
;  590	#elif FF_CODE_PAGE < 900	/* Static code page configuration (SBCS) */
;  591	#define CODEPAGE FF_CODE_PAGE
;  592	static const BYTE ExCvt[] = MKCVTBL(TBL_CT, FF_CODE_PAGE);
	SEGMENT CODE
;  593	
;  594	#else					/* Static code page configuration (DBCS) */
;  595	#define CODEPAGE FF_CODE_PAGE
;  596	static const BYTE DbcTbl[] = MKCVTBL(TBL_DC, FF_CODE_PAGE);
;  597	
;  598	#endif
;  599	
;  600	
;  601	
;  602	
;  603	/*--------------------------------------------------------------------------
;  604	
;  605	   Module Private Functions
;  606	
;  607	---------------------------------------------------------------------------*/
;  608	
;  609	
;  610	/*-----------------------------------------------------------------------*/
;  611	/* Load/Store multi-byte word in the FAT structure                       */
;  612	/*-----------------------------------------------------------------------*/
;  613	
;  614	static WORD ld_word (const BYTE* ptr)	/*	 Load a 2-byte little-endian word */
;  615	{
_ld_word:
.DEFINE "_ld_word"

.VALUE _ld_word

.CLASS 3

.TYPE 77

.ENDEF

.BEGFUNC "ld_word",615,"_ld_word"

.LINE 615

.DEFINE "ptr"

.CLASS 65

.VALUE 6

.TYPE 204

.ENDEF

.DEFINE "rv"

.CLASS 65

.VALUE -2

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
	DEC	SP
;  616		WORD rv;
;  617	
;  618		rv = ptr[1];
.LINE 618

	LD	HL,(IX+%6)
	INC	HL
	LD	C,(HL)
	LD	B,%0
	LD	HL,BC
	LD	(IX+%FFFFFFFE),L
	LD	(IX+%FFFFFFFF),H
;  619		rv = rv << 8 | ptr[0];
.LINE 619

	LD	HL,(IX+%6)
	LD	C,(HL)
	LD	DE,BC
	LD	HL,(IX+%FFFFFFFE)
	LD	H,L
	LD	L,%0
	LD	BC,HL
	LD	HL,DE
	CALL	__sor
	LD	(IX+%FFFFFFFE),L
	LD	(IX+%FFFFFFFF),H
;  620		return rv;
.LINE 620

	LD	HL,(IX+%FFFFFFFE)
;  621	}
.LINE 621

	LD	SP,IX
	POP	IX
	RET	


;**************************** _ld_word ***************************
;Name                         Addr/Register   Size   Type
;rv                                    IX-2      2   variable
;ptr                                   IX+6      3   parameter


; Stack Frame Size: 11 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "ld_word",621,"_ld_word"
;  622	
;  623	static DWORD ld_dword (const BYTE* ptr)	/* Load a 4-byte little-endian word */
;  624	{
_ld_dword:
.DEFINE "_ld_dword"

.VALUE _ld_dword

.CLASS 3

.TYPE 79

.ENDEF

.BEGFUNC "ld_dword",624,"_ld_dword"

.LINE 624

.DEFINE "ptr"

.CLASS 65

.VALUE 6

.TYPE 204

.ENDEF

.DEFINE "rv"

.CLASS 65

.VALUE -4

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF3
	LD	SP,HL
;  625		DWORD rv;
;  626	
;  627		rv = ptr[3];
.LINE 627

	LD	IY,(IX+%6)
	UEXT	HL
	LD	L,(IY+%3)
	LD	BC,HL
	LD	(IX+%FFFFFFFC),BC
	LD	(IX+%FFFFFFFF),H
;  628		rv = rv << 8 | ptr[2];
.LINE 628

	UEXT	HL
	LD	L,(IY+%2)
	LD	(IX+%FFFFFFF9),HL
	LD	E,H
	LD	A,(IX+%FFFFFFFF)
	LD	L,%8
	CALL	__lshl
	LD	HL,(IX+%FFFFFFF9)
	CALL	__lor
	LD	BC,HL
	LD	(IX+%FFFFFFFC),BC
	LD	(IX+%FFFFFFFF),E
;  629		rv = rv << 8 | ptr[1];
.LINE 629

	UEXT	HL
	LD	L,(IY+%1)
	LD	(IX+%FFFFFFF6),HL
	LD	E,H
	LD	A,(IX+%FFFFFFFF)
	LD	L,%8
	CALL	__lshl
	LD	HL,(IX+%FFFFFFF6)
	CALL	__lor
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),E
;  630		rv = rv << 8 | ptr[0];
.LINE 630

	LD	BC,HL
	LD	A,(IX+%FFFFFFFF)
	LD	L,%8
	CALL	__lshl
	LD	(IX+%FFFFFFF3),BC
	LD	E,A
	UEXT	HL
	LD	L,(IY)
	LD	BC,HL
	LD	A,H
	LD	HL,(IX+%FFFFFFF3)
	CALL	__lor
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),E
;  631		return rv;
.LINE 631

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
;  632	}
.LINE 632

	LD	SP,IX
	POP	IX
	RET	


;**************************** _ld_dword ***************************
;Name                         Addr/Register   Size   Type
;rv                                    IX-4      4   variable
;ptr                                   IX+6      3   parameter


; Stack Frame Size: 22 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "ld_dword",632,"_ld_dword"
;  633	
;  634	#if FF_FS_EXFAT
;  635	static QWORD ld_qword (const BYTE* ptr)	/* Load an 8-byte little-endian word */
;  636	{
;  637		QWORD rv;
;  638	
;  639		rv = ptr[7];
;  640		rv = rv << 8 | ptr[6];
;  641		rv = rv << 8 | ptr[5];
;  642		rv = rv << 8 | ptr[4];
;  643		rv = rv << 8 | ptr[3];
;  644		rv = rv << 8 | ptr[2];
;  645		rv = rv << 8 | ptr[1];
;  646		rv = rv << 8 | ptr[0];
;  647		return rv;
;  648	}
;  649	#endif
;  650	
;  651	#if !FF_FS_READONLY
;  652	static void st_word (BYTE* ptr, WORD val)	/* Store a 2-byte word in little-endian */
;  653	{
;  654		*ptr++ = (BYTE)val; val >>= 8;
;  655		*ptr++ = (BYTE)val;
;  656	}
;  657	
;  658	static void st_dword (BYTE* ptr, DWORD val)	/* Store a 4-byte word in little-endian */
;  659	{
;  660		*ptr++ = (BYTE)val; val >>= 8;
;  661		*ptr++ = (BYTE)val; val >>= 8;
;  662		*ptr++ = (BYTE)val; val >>= 8;
;  663		*ptr++ = (BYTE)val;
;  664	}
;  665	
;  666	#if FF_FS_EXFAT
;  667	static void st_qword (BYTE* ptr, QWORD val)	/* Store an 8-byte word in little-endian */
;  668	{
;  669		*ptr++ = (BYTE)val; val >>= 8;
;  670		*ptr++ = (BYTE)val; val >>= 8;
;  671		*ptr++ = (BYTE)val; val >>= 8;
;  672		*ptr++ = (BYTE)val; val >>= 8;
;  673		*ptr++ = (BYTE)val; val >>= 8;
;  674		*ptr++ = (BYTE)val; val >>= 8;
;  675		*ptr++ = (BYTE)val; val >>= 8;
;  676		*ptr++ = (BYTE)val;
;  677	}
;  678	#endif
;  679	#endif	/* !FF_FS_READONLY */
;  680	
;  681	
;  682	
;  683	/*-----------------------------------------------------------------------*/
;  684	/* String functions                                                      */
;  685	/*-----------------------------------------------------------------------*/
;  686	
;  687	/* Test if the byte is DBC 1st byte */
;  688	static int dbc_1st (BYTE c)
;  689	{
_dbc_1st:
.DEFINE "_dbc_1st"

.VALUE _dbc_1st

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "dbc_1st",689,"_dbc_1st"

.LINE 689

.DEFINE "c"

.CLASS 65

.VALUE 6

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  690	#if FF_CODE_PAGE == 0		/* Variable code page */
;  691		if (DbcTbl && c >= DbcTbl[0]) {
;  692			if (c <= DbcTbl[1]) return 1;					/* 1st byte range 1 */
;  693			if (c >= DbcTbl[2] && c <= DbcTbl[3]) return 1;	/* 1st byte range 2 */
;  694		}
;  695	#elif FF_CODE_PAGE >= 900	/* DBCS fixed code page */
;  696		if (c >= DbcTbl[0]) {
;  697			if (c <= DbcTbl[1]) return 1;
;  698			if (c >= DbcTbl[2] && c <= DbcTbl[3]) return 1;
;  699		}
;  700	#else						/* SBCS fixed code page */
;  701		if (c != 0) return 0;	/* Always false */
.LINE 701

	LD	A,(IX+%6)
	OR	A,A
	JR	Z,L_3
	OR	A,A
	SBC	HL,HL
	JR	L_4
L_3:
;  702	#endif
;  703		return 0;
.LINE 703

	OR	A,A
	SBC	HL,HL
;  704	}
L_4:
.LINE 704

	LD	SP,IX
	POP	IX
	RET	


;**************************** _dbc_1st ***************************
;Name                         Addr/Register   Size   Type
;c                                     IX+6      1   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "dbc_1st",704,"_dbc_1st"
;  705	
;  706	
;  707	/* Test if the byte is DBC 2nd byte */
;  708	static int dbc_2nd (BYTE c)
;  709	{
_dbc_2nd:
.DEFINE "_dbc_2nd"

.VALUE _dbc_2nd

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "dbc_2nd",709,"_dbc_2nd"

.LINE 709

.DEFINE "c"

.CLASS 65

.VALUE 6

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  710	#if FF_CODE_PAGE == 0		/* Variable code page */
;  711		if (DbcTbl && c >= DbcTbl[4]) {
;  712			if (c <= DbcTbl[5]) return 1;					/* 2nd byte range 1 */
;  713			if (c >= DbcTbl[6] && c <= DbcTbl[7]) return 1;	/* 2nd byte range 2 */
;  714			if (c >= DbcTbl[8] && c <= DbcTbl[9]) return 1;	/* 2nd byte range 3 */
;  715		}
;  716	#elif FF_CODE_PAGE >= 900	/* DBCS fixed code page */
;  717		if (c >= DbcTbl[4]) {
;  718			if (c <= DbcTbl[5]) return 1;
;  719			if (c >= DbcTbl[6] && c <= DbcTbl[7]) return 1;
;  720			if (c >= DbcTbl[8] && c <= DbcTbl[9]) return 1;
;  721		}
;  722	#else						/* SBCS fixed code page */
;  723		if (c != 0) return 0;	/* Always false */
.LINE 723

	LD	A,(IX+%6)
	OR	A,A
	JR	Z,L_6
	OR	A,A
	SBC	HL,HL
	JR	L_7
L_6:
;  724	#endif
;  725		return 0;
.LINE 725

	OR	A,A
	SBC	HL,HL
;  726	}
L_7:
.LINE 726

	LD	SP,IX
	POP	IX
	RET	


;**************************** _dbc_2nd ***************************
;Name                         Addr/Register   Size   Type
;c                                     IX+6      1   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "dbc_2nd",726,"_dbc_2nd"
;  727	
;  728	
;  729	#if FF_USE_LFN
;  730	
;  731	/* Get a Unicode code point from the TCHAR string in defined API encodeing */
;  732	static DWORD tchar2uni (	/* Returns a character in UTF-16 encoding (>=0x10000 on surrogate pair, 0xFFFFFFFF on decode error) */
;  733		const TCHAR** str		/* Pointer to pointer to TCHAR string in configured encoding */
;  734	)
;  735	{
_tchar2uni:
.DEFINE "_tchar2uni"

.VALUE _tchar2uni

.CLASS 3

.TYPE 79

.ENDEF

.BEGFUNC "tchar2uni",735,"_tchar2uni"

.LINE 735

.DEFINE "str"

.CLASS 65

.VALUE 6

.TYPE 1570

.ENDEF

.DEFINE "p"

.CLASS 65

.VALUE -3

.TYPE 194

.ENDEF

.DEFINE "wc"

.CLASS 65

.VALUE -5

.TYPE 13

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE -6

.TYPE 12

.ENDEF

.DEFINE "uc"

.CLASS 65

.VALUE -10

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	PUSH	BC
	DEC	SP
;  736		DWORD uc;
;  737		const TCHAR *p = *str;
.LINE 737

	LD	HL,(IX+%6)
	LD	BC,(HL)
	LD	(IX+%FFFFFFFD),BC
;  738	
;  739	#if FF_LFN_UNICODE == 1		/* UTF-16 input */
;  740		WCHAR wc;
;  741	
;  742		uc = *p++;	/* Get a unit */
;  743		if (IsSurrogate(uc)) {	/* Surrogate? */
;  744			wc = *p++;		/* Get low surrogate */
;  745			if (!IsSurrogateH(uc) || !IsSurrogateL(wc)) return 0xFFFFFFFF;	/* Wrong surrogate? */
;  746			uc = uc << 16 | wc;
;  747		}
;  748	
;  749	#elif FF_LFN_UNICODE == 2	/* UTF-8 input */
;  750		BYTE b;
;  751		int nf;
;  752	
;  753		uc = (BYTE)*p++;	/* Get an encoding unit */
;  754		if (uc & 0x80) {	/* Multiple byte code? */
;  755			if        ((uc & 0xE0) == 0xC0) {	/* 2-byte sequence? */
;  756				uc &= 0x1F; nf = 1;
;  757			} else if ((uc & 0xF0) == 0xE0) {	/* 3-byte sequence? */
;  758				uc &= 0x0F; nf = 2;
;  759			} else if ((uc & 0xF8) == 0xF0) {	/* 4-byte sequence? */
;  760				uc &= 0x07; nf = 3;
;  761			} else {							/* Wrong sequence */
;  762				return 0xFFFFFFFF;
;  763			}
;  764			do {	/* Get trailing bytes */
;  765				b = (BYTE)*p++;
;  766				if ((b & 0xC0) != 0x80) return 0xFFFFFFFF;	/* Wrong sequence? */
;  767				uc = uc << 6 | (b & 0x3F);
;  768			} while (--nf != 0);
;  769			if (uc < 0x80 || IsSurrogate(uc) || uc >= 0x110000) return 0xFFFFFFFF;	/* Wrong code? */
;  770			if (uc >= 0x010000) uc = 0xD800DC00 | ((uc - 0x10000) << 6 & 0x3FF0000) | (uc & 0x3FF);	/* Make a surrogate pair if needed */
;  771		}
;  772	
;  773	#elif FF_LFN_UNICODE == 3	/* UTF-32 input */
;  774		uc = (TCHAR)*p++;	/* Get a unit */
;  775		if (uc >= 0x110000 || IsSurrogate(uc)) return 0xFFFFFFFF;	/* Wrong code? */
;  776		if (uc >= 0x010000) uc = 0xD800DC00 | ((uc - 0x10000) << 6 & 0x3FF0000) | (uc & 0x3FF);	/* Make a surrogate pair if needed */
;  777	
;  778	#else		/* ANSI/OEM input */
;  779		BYTE b;
;  780		WCHAR wc;
;  781	
;  782		wc = (BYTE)*p++;			/* Get a byte */
.LINE 782

	LD	HL,BC
	LD	C,(HL)
	LD	B,%0
	LD	HL,BC
	LD	(IX+%FFFFFFFB),L
	LD	(IX+%FFFFFFFC),H
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
;  783		if (dbc_1st((BYTE)wc)) {	/* Is it a DBC 1st byte? */
.LINE 783

	LD	C,(IX+%FFFFFFFB)
	LD	B,%0
	PUSH	BC
	CALL	_dbc_1st
	POP	BC
	CALL	__icmpzero
	JR	Z,L_15
;  784			b = (BYTE)*p++;			/* Get 2nd byte */
.LINE 784

	LD	HL,(IX+%FFFFFFFD)
	LD	A,(HL)
	LD	(IX+%FFFFFFFA),A
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
;  785			if (!dbc_2nd(b)) return 0xFFFFFFFF;	/* Invalid code? */
.LINE 785

	LD	C,(IX+%FFFFFFFA)
	LD	B,%0
	PUSH	BC
	CALL	_dbc_2nd
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_11
	LD	HL,16777215
	LD	E,%FF
	JR	L_17
L_11:
;  786			wc = (wc << 8) + b;		/* Make a DBC */
.LINE 786

	LD	HL,(IX+%FFFFFFFB)
	LD	H,L
	LD	L,%0
	LD	C,(IX+%FFFFFFFA)
	LD	B,%0
	ADD.SIS	HL,BC
	LD	(IX+%FFFFFFFB),L
	LD	(IX+%FFFFFFFC),H
;  787		}
L_15:
.LINE 787

;  788		if (wc != 0) {
.LINE 788

	LD	HL,(IX+%FFFFFFFB)
	CALL	__scmpzero
	JR	Z,L_16
;  789			wc = ff_oem2uni(wc, CODEPAGE);	/* ANSI/OEM ==> Unicode */
.LINE 789

	LD	BC,437
	PUSH	BC
	LD	BC,(IX+%FFFFFFFB)
	PUSH	BC
	CALL	_ff_oem2uni
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFB),L
	LD	(IX+%FFFFFFFC),H
;  790			if (wc == 0) return 0xFFFFFFFF;	/* Invalid code? */
.LINE 790

	LD	HL,(IX+%FFFFFFFB)
	CALL	__scmpzero
	JR	NZ,L_16
	LD	HL,16777215
	LD	E,%FF
	JR	L_17
;  791		}
L_16:
.LINE 791

;  792		uc = wc;
.LINE 792

	LD	BC,(IX+%FFFFFFFB)
	CALL	__stoiu
	XOR	A,A
	LD	(IX+%FFFFFFF6),HL
	LD	(IX+%FFFFFFF9),A
;  793	
;  794	#endif
;  795		*str = p;	/* Next read pointer */
.LINE 795

	LD	HL,(IX+%6)
	LD	BC,(IX+%FFFFFFFD)
	LD	(HL),BC
;  796		return uc;
.LINE 796

	LD	HL,(IX+%FFFFFFF6)
	LD	E,(IX+%FFFFFFF9)
;  797	}
L_17:
.LINE 797

	LD	SP,IX
	POP	IX
	RET	


;**************************** _tchar2uni ***************************
;Name                         Addr/Register   Size   Type
;_ff_oem2uni                         IMPORT  -----   function
;uc                                   IX-10      4   variable
;b                                     IX-6      1   variable
;wc                                    IX-5      2   variable
;p                                     IX-3      3   variable
;str                                   IX+6      3   parameter


; Stack Frame Size: 19 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "tchar2uni",797,"_tchar2uni"
;  798	
;  799	
;  800	/* Store a Unicode char in defined API encoding */
;  801	static UINT put_utf (	/* Returns number of encoding units written (0:buffer overflow or wrong encoding) */
;  802		DWORD chr,	/* UTF-16 encoded character (Surrogate pair if >=0x10000) */
;  803		TCHAR* buf,	/* Output buffer */
;  804		UINT szb	/* Size of the buffer */
;  805	)
;  806	{
_put_utf:
.DEFINE "_put_utf"

.VALUE _put_utf

.CLASS 3

.TYPE 78

.ENDEF

.BEGFUNC "put_utf",806,"_put_utf"

.LINE 806

.DEFINE "chr"

.CLASS 65

.VALUE 6

.TYPE 15

.ENDEF

.DEFINE "buf"

.CLASS 65

.VALUE 12

.TYPE 34

.ENDEF

.DEFINE "szb"

.CLASS 65

.VALUE 15

.TYPE 14

.ENDEF

.DEFINE "wc"

.CLASS 65

.VALUE -2

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
	DEC	SP
;  807	#if FF_LFN_UNICODE == 1	/* UTF-16 output */
;  808		WCHAR hs, wc;
;  809	
;  810		hs = (WCHAR)(chr >> 16);
;  811		wc = (WCHAR)chr;
;  812		if (hs == 0) {	/* Single encoding unit? */
;  813			if (szb < 1 || IsSurrogate(wc)) return 0;	/* Buffer overflow or wrong code? */
;  814			*buf = wc;
;  815			return 1;
;  816		}
;  817		if (szb < 2 || !IsSurrogateH(hs) || !IsSurrogateL(wc)) return 0;	/* Buffer overflow or wrong surrogate? */
;  818		*buf++ = hs;
;  819		*buf++ = wc;
;  820		return 2;
;  821	
;  822	#elif FF_LFN_UNICODE == 2	/* UTF-8 output */
;  823		DWORD hc;
;  824	
;  825		if (chr < 0x80) {	/* Single byte code? */
;  826			if (szb < 1) return 0;	/* Buffer overflow? */
;  827			*buf = (TCHAR)chr;
;  828			return 1;
;  829		}
;  830		if (chr < 0x800) {	/* 2-byte sequence? */
;  831			if (szb < 2) return 0;	/* Buffer overflow? */
;  832			*buf++ = (TCHAR)(0xC0 | (chr >> 6 & 0x1F));
;  833			*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));
;  834			return 2;
;  835		}
;  836		if (chr < 0x10000) {	/* 3-byte sequence? */
;  837			if (szb < 3 || IsSurrogate(chr)) return 0;	/* Buffer overflow or wrong code? */
;  838			*buf++ = (TCHAR)(0xE0 | (chr >> 12 & 0x0F));
;  839			*buf++ = (TCHAR)(0x80 | (chr >> 6 & 0x3F));
;  840			*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));
;  841			return 3;
;  842		}
;  843		/* 4-byte sequence */
;  844		if (szb < 4) return 0;	/* Buffer overflow? */
;  845		hc = ((chr & 0xFFFF0000) - 0xD8000000) >> 6;	/* Get high 10 bits */
;  846		chr = (chr & 0xFFFF) - 0xDC00;					/* Get low 10 bits */
;  847		if (hc >= 0x100000 || chr >= 0x400) return 0;	/* Wrong surrogate? */
;  848		chr = (hc | chr) + 0x10000;
;  849		*buf++ = (TCHAR)(0xF0 | (chr >> 18 & 0x07));
;  850		*buf++ = (TCHAR)(0x80 | (chr >> 12 & 0x3F));
;  851		*buf++ = (TCHAR)(0x80 | (chr >> 6 & 0x3F));
;  852		*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));
;  853		return 4;
;  854	
;  855	#elif FF_LFN_UNICODE == 3	/* UTF-32 output */
;  856		DWORD hc;
;  857	
;  858		if (szb < 1) return 0;	/* Buffer overflow? */
;  859		if (chr >= 0x10000) {	/* Out of BMP? */
;  860			hc = ((chr & 0xFFFF0000) - 0xD8000000) >> 6;	/* Get high 10 bits */
;  861			chr = (chr & 0xFFFF) - 0xDC00;					/* Get low 10 bits */
;  862			if (hc >= 0x100000 || chr >= 0x400) return 0;	/* Wrong surrogate? */
;  863			chr = (hc | chr) + 0x10000;
;  864		}
;  865		*buf++ = (TCHAR)chr;
;  866		return 1;
;  867	
;  868	#else						/* ANSI/OEM output */
;  869		WCHAR wc;
;  870	
;  871		wc = ff_uni2oem(chr, CODEPAGE);
.LINE 871

	LD	BC,437
	PUSH	BC
	LD	C,(IX+%9)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_ff_uni2oem
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFE),L
	LD	(IX+%FFFFFFFF),H
;  872		if (wc >= 0x100) {	/* Is this a DBC? */
.LINE 872

	LD.LIS	BC,256
	LD	HL,(IX+%FFFFFFFE)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_25
;  873			if (szb < 2) return 0;
.LINE 873

	LD	BC,2
	LD	HL,(IX+%F)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_20
	OR	A,A
	SBC	HL,HL
	JR	L_28
L_20:
;  874			*buf++ = (char)(wc >> 8);	/* Store DBC 1st byte */
.LINE 874

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	A,%8
	CALL	__ishrs_b
	LD	IY,(IX+%C)
	LD	(IY),L
	LD	BC,(IX+%C)
	INC	BC
	LD	(IX+%C),BC
;  875			*buf++ = (TCHAR)wc;			/* Store DBC 2nd byte */
.LINE 875

	LD	A,(IX+%FFFFFFFE)
	LD	HL,BC
	LD	(HL),A
;  876			return 2;
.LINE 876

	LD	HL,2
	JR	L_28
;  877		}
L_25:
.LINE 877

;  878		if (wc == 0 || szb < 1) return 0;	/* Invalid char or buffer overflow? */
.LINE 878

	LD	HL,(IX+%FFFFFFFE)
	CALL	__scmpzero
	JR	Z,L_24
	LD	BC,1
	LD	HL,(IX+%F)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_27
L_24:
	OR	A,A
	SBC	HL,HL
	JR	L_28
L_27:
;  879		*buf++ = (TCHAR)wc;					/* Store the character */
.LINE 879

	LD	A,(IX+%FFFFFFFE)
	LD	HL,(IX+%C)
	LD	(HL),A
;  880		return 1;
.LINE 880

	LD	HL,1
;  881	#endif
;  882	}
L_28:
.LINE 882

	LD	SP,IX
	POP	IX
	RET	


;**************************** _put_utf ***************************
;Name                         Addr/Register   Size   Type
;_ff_uni2oem                         IMPORT  -----   function
;wc                                    IX-2      2   variable
;szb                                  IX+15      3   parameter
;buf                                  IX+12      3   parameter
;chr                                   IX+6      4   parameter


; Stack Frame Size: 20 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "put_utf",882,"_put_utf"
;  883	#endif	/* FF_USE_LFN */
;  884	
;  885	
;  886	#if FF_FS_REENTRANT
;  887	/*-----------------------------------------------------------------------*/
;  888	/* Request/Release grant to access the volume                            */
;  889	/*-----------------------------------------------------------------------*/
;  890	static int lock_fs (		/* 1:Ok, 0:timeout */
;  891		FATFS* fs		/* Filesystem object */
;  892	)
;  893	{
;  894		return ff_req_grant(fs->sobj);
;  895	}
;  896	
;  897	
;  898	static void unlock_fs (
;  899		FATFS* fs,		/* Filesystem object */
;  900		FRESULT res		/* Result code to be returned */
;  901	)
;  902	{
;  903		if (fs && res != FR_NOT_ENABLED && res != FR_INVALID_DRIVE && res != FR_TIMEOUT) {
;  904			ff_rel_grant(fs->sobj);
;  905		}
;  906	}
;  907	
;  908	#endif
;  909	
;  910	
;  911	
;  912	#if FF_FS_LOCK != 0
;  913	/*-----------------------------------------------------------------------*/
;  914	/* File lock control functions                                           */
;  915	/*-----------------------------------------------------------------------*/
;  916	
;  917	static FRESULT chk_lock (	/* Check if the file can be accessed */
;  918		DIR* dp,		/* Directory object pointing the file to be checked */
;  919		int acc			/* Desired access type (0:Read mode open, 1:Write mode open, 2:Delete or rename) */
;  920	)
;  921	{
;  922		UINT i, be;
;  923	
;  924		/* Search open object table for the object */
;  925		be = 0;
;  926		for (i = 0; i < FF_FS_LOCK; i++) {
;  927			if (Files[i].fs) {	/* Existing entry */
;  928				if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matches with an open object */
;  929					Files[i].clu == dp->obj.sclust &&
;  930					Files[i].ofs == dp->dptr) break;
;  931			} else {			/* Blank entry */
;  932				be = 1;
;  933			}
;  934		}
;  935		if (i == FF_FS_LOCK) {	/* The object has not been opened */
;  936			return (!be && acc != 2) ? FR_TOO_MANY_OPEN_FILES : FR_OK;	/* Is there a blank entry for new object? */
;  937		}
;  938	
;  939		/* The object was opened. Reject any open against writing file and all write mode open */
;  940		return (acc != 0 || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
;  941	}
;  942	
;  943	
;  944	static int enq_lock (void)	/* Check if an entry is available for a new object */
;  945	{
;  946		UINT i;
;  947	
;  948		for (i = 0; i < FF_FS_LOCK && Files[i].fs; i++) ;
;  949		return (i == FF_FS_LOCK) ? 0 : 1;
;  950	}
;  951	
;  952	
;  953	static UINT inc_lock (	/* Increment object open counter and returns its index (0:Internal error) */
;  954		DIR* dp,	/* Directory object pointing the file to register or increment */
;  955		int acc		/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
;  956	)
;  957	{
;  958		UINT i;
;  959	
;  960	
;  961		for (i = 0; i < FF_FS_LOCK; i++) {	/* Find the object */
;  962			if (Files[i].fs == dp->obj.fs
;  963			 && Files[i].clu == dp->obj.sclust
;  964			 && Files[i].ofs == dp->dptr) break;
;  965		}
;  966	
;  967		if (i == FF_FS_LOCK) {			/* Not opened. Register it as new. */
;  968			for (i = 0; i < FF_FS_LOCK && Files[i].fs; i++) ;
;  969			if (i == FF_FS_LOCK) return 0;	/* No free entry to register (int err) */
;  970			Files[i].fs = dp->obj.fs;
;  971			Files[i].clu = dp->obj.sclust;
;  972			Files[i].ofs = dp->dptr;
;  973			Files[i].ctr = 0;
;  974		}
;  975	
;  976		if (acc >= 1 && Files[i].ctr) return 0;	/* Access violation (int err) */
;  977	
;  978		Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
;  979	
;  980		return i + 1;	/* Index number origin from 1 */
;  981	}
;  982	
;  983	
;  984	static FRESULT dec_lock (	/* Decrement object open counter */
;  985		UINT i			/* Semaphore index (1..) */
;  986	)
;  987	{
;  988		WORD n;
;  989		FRESULT res;
;  990	
;  991	
;  992		if (--i < FF_FS_LOCK) {	/* Index number origin from 0 */
;  993			n = Files[i].ctr;
;  994			if (n == 0x100) n = 0;	/* If write mode open, delete the entry */
;  995			if (n > 0) n--;			/* Decrement read mode open count */
;  996			Files[i].ctr = n;
;  997			if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
;  998			res = FR_OK;
;  999		} else {
; 1000			res = FR_INT_ERR;		/* Invalid index nunber */
; 1001		}
; 1002		return res;
; 1003	}
; 1004	
; 1005	
; 1006	static void clear_lock (	/* Clear lock entries of the volume */
; 1007		FATFS *fs
; 1008	)
; 1009	{
; 1010		UINT i;
; 1011	
; 1012		for (i = 0; i < FF_FS_LOCK; i++) {
; 1013			if (Files[i].fs == fs) Files[i].fs = 0;
; 1014		}
; 1015	}
; 1016	
; 1017	#endif	/* FF_FS_LOCK != 0 */
; 1018	
; 1019	
; 1020	
; 1021	/*-----------------------------------------------------------------------*/
; 1022	/* Move/Flush disk access window in the filesystem object                */
; 1023	/*-----------------------------------------------------------------------*/
; 1024	#if !FF_FS_READONLY
; 1025	static FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERR */
; 1026		FATFS* fs			/* Filesystem object */
; 1027	)
; 1028	{
; 1029		FRESULT res = FR_OK;
; 1030	
; 1031	
; 1032		if (fs->wflag) {	/* Is the disk access window dirty? */
; 1033			if (disk_write(fs->pdrv, fs->win, fs->winsect, 1) == RES_OK) {	/* Write it back into the volume */
; 1034				fs->wflag = 0;	/* Clear window dirty flag */
; 1035				if (fs->winsect - fs->fatbase < fs->fsize) {	/* Is it in the 1st FAT? */
; 1036					if (fs->n_fats == 2) disk_write(fs->pdrv, fs->win, fs->winsect + fs->fsize, 1);	/* Reflect it to 2nd FAT if needed */
; 1037				}
; 1038			} else {
; 1039				res = FR_DISK_ERR;
; 1040			}
; 1041		}
; 1042		return res;
; 1043	}
; 1044	#endif
; 1045	
; 1046	
; 1047	static FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERR */
; 1048		FATFS* fs,		/* Filesystem object */
; 1049		LBA_t sect		/* Sector LBA to make appearance in the fs->win[] */
; 1050	)
; 1051	{
_move_window:
.DEFINE "_move_window"

.VALUE _move_window

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "move_window",1051,"_move_window"

.LINE 1051

.DEFINE "fs"

.CLASS 65

.VALUE 6

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "sect"

.CLASS 65

.VALUE 9

.TYPE 15

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
; 1052		FRESULT res = FR_OK;
.LINE 1052

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
; 1053	
; 1054	
; 1055		if (sect != fs->winsect) {	/* Window offset changed? */
.LINE 1055

	LD	IY,(IX+%6)
	LD	HL,(IY+%2A)
	LD	E,(IY+%2D)
	LD	BC,(IX+%9)
	LD	A,(IX+%C)
	CALL	__lcmpu
	JR	Z,L_33
; 1056	#if !FF_FS_READONLY
; 1057			res = sync_window(fs);		/* Flush the window */
; 1058	#endif
; 1059			if (res == FR_OK) {			/* Fill sector window with new data */
; 1060				if (disk_read(fs->pdrv, fs->win, sect, 1) != RES_OK) {
.LINE 1060

	LD	BC,1
	PUSH	BC
	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%9)
	PUSH	BC
	LD	IY,(IX+%6)
	PEA	IY+%2E
	LD	C,(IY+%1)
	LD	B,%0
	PUSH	BC
	CALL	_disk_read
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	Z,L_30
; 1061					sect = (LBA_t)0 - 1;	/* Invalidate window if read data is not valid */
.LINE 1061

	LD	BC,16777215
	LD	A,%FF
	LD	(IX+%9),BC
	LD	(IX+%C),A
; 1062					res = FR_DISK_ERR;
.LINE 1062

	LD	BC,1
	LD	(IX+%FFFFFFFD),BC
; 1063				}
L_30:
.LINE 1063

; 1064				fs->winsect = sect;
.LINE 1064

	LD	BC,(IX+%9)
	LD	A,(IX+%C)
	LD	IY,(IX+%6)
	LD	(IY+%2A),BC
	LD	(IY+%2D),A
; 1065			}
; 1066		}
L_33:
.LINE 1066

; 1067		return res;
.LINE 1067

	LD	HL,(IX+%FFFFFFFD)
; 1068	}
.LINE 1068

	LD	SP,IX
	POP	IX
	RET	


;**************************** _move_window ***************************
;Name                         Addr/Register   Size   Type
;_disk_read                          IMPORT  -----   function
;res                                   IX-3      3   variable
;sect                                  IX+9      4   parameter
;fs                                    IX+6      3   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "move_window",1068,"_move_window"
; 1069	
; 1070	
; 1071	
; 1072	
; 1073	#if !FF_FS_READONLY
; 1074	/*-----------------------------------------------------------------------*/
; 1075	/* Synchronize filesystem and data on the storage                        */
; 1076	/*-----------------------------------------------------------------------*/
; 1077	
; 1078	static FRESULT sync_fs (	/* Returns FR_OK or FR_DISK_ERR */
; 1079		FATFS* fs		/* Filesystem object */
; 1080	)
; 1081	{
; 1082		FRESULT res;
; 1083	
; 1084	
; 1085		res = sync_window(fs);
; 1086		if (res == FR_OK) {
; 1087			if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {	/* FAT32: Update FSInfo sector if needed */
; 1088				/* Create FSInfo structure */
; 1089				memset(fs->win, 0, sizeof fs->win);
; 1090				st_word(fs->win + BS_55AA, 0xAA55);					/* Boot signature */
; 1091				st_dword(fs->win + FSI_LeadSig, 0x41615252);		/* Leading signature */
; 1092				st_dword(fs->win + FSI_StrucSig, 0x61417272);		/* Structure signature */
; 1093				st_dword(fs->win + FSI_Free_Count, fs->free_clst);	/* Number of free clusters */
; 1094				st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);	/* Last allocated culuster */
; 1095				fs->winsect = fs->volbase + 1;						/* Write it into the FSInfo sector (Next to VBR) */
; 1096				disk_write(fs->pdrv, fs->win, fs->winsect, 1);
; 1097				fs->fsi_flag = 0;
; 1098			}
; 1099			/* Make sure that no pending write process in the lower layer */
; 1100			if (disk_ioctl(fs->pdrv, CTRL_SYNC, 0) != RES_OK) res = FR_DISK_ERR;
; 1101		}
; 1102	
; 1103		return res;
; 1104	}
; 1105	
; 1106	#endif
; 1107	
; 1108	
; 1109	
; 1110	/*-----------------------------------------------------------------------*/
; 1111	/* Get physical sector number from cluster number                        */
; 1112	/*-----------------------------------------------------------------------*/
; 1113	
; 1114	static LBA_t clst2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
; 1115		FATFS* fs,		/* Filesystem object */
; 1116		DWORD clst		/* Cluster# to be converted */
; 1117	)
; 1118	{
_clst2sect:
.DEFINE "_clst2sect"

.VALUE _clst2sect

.CLASS 3

.TYPE 79

.ENDEF

.BEGFUNC "clst2sect",1118,"_clst2sect"

.LINE 1118

.DEFINE "fs"

.CLASS 65

.VALUE 6

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "clst"

.CLASS 65

.VALUE 9

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
; 1119		clst -= 2;		/* Cluster number is origin from 2 */
.LINE 1119

	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	LD	BC,2
	XOR	A,A
	CALL	__lsub
	LD	(IX+%9),HL
	LD	(IX+%C),E
; 1120		if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
.LINE 1120

	LD	IY,(IX+%6)
	LD	HL,(IY+%12)
	LD	E,(IY+%15)
	LD	BC,2
	XOR	A,A
	CALL	__lsub
	LD	A,E
	LD	BC,HL
	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	CALL	__lcmpu
	JR	C,L_36
	OR	A,A
	SBC	HL,HL
	LD	E,%0
	JR	L_37
L_36:
; 1121		return fs->database + (LBA_t)fs->csize * clst;	/* Start sector number of the cluster */
.LINE 1121

	LD	IY,(IX+%6)
	LD	BC,(IY+%9)
	CALL	__stoiu
	LD	E,%0
	LD	BC,(IX+%9)
	LD	A,(IX+%C)
	CALL	__lmulu
	LD	BC,(IY+%26)
	LD	A,(IY+%29)
	CALL	__ladd
; 1122	}
L_37:
.LINE 1122

	LD	SP,IX
	POP	IX
	RET	


;**************************** _clst2sect ***************************
;Name                         Addr/Register   Size   Type
;clst                                  IX+9      4   parameter
;fs                                    IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "clst2sect",1122,"_clst2sect"
; 1123	
; 1124	
; 1125	
; 1126	
; 1127	/*-----------------------------------------------------------------------*/
; 1128	/* FAT access - Read value of an FAT entry                               */
; 1129	/*-----------------------------------------------------------------------*/
; 1130	
; 1131	static DWORD get_fat (		/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
; 1132		FFOBJID* obj,	/* Corresponding object */
; 1133		DWORD clst		/* Cluster number to get the value */
; 1134	)
; 1135	{
_get_fat:
.DEFINE "_get_fat"

.VALUE _get_fat

.CLASS 3

.TYPE 79

.ENDEF

.BEGFUNC "get_fat",1135,"_get_fat"

.LINE 1135

.DEFINE "obj"

.CLASS 65

.VALUE 6

.TAG "NONAME1"

.TYPE 40

.ENDEF

.DEFINE "clst"

.CLASS 65

.VALUE 9

.TYPE 15

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -3

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "bc"

.CLASS 65

.VALUE -6

.TYPE 14

.ENDEF

.DEFINE "val"

.CLASS 65

.VALUE -10

.TYPE 15

.ENDEF

.DEFINE "wc"

.CLASS 65

.VALUE -13

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF0
	LD	SP,HL
; 1136		UINT wc, bc;
; 1137		DWORD val;
; 1138		FATFS *fs = obj->fs;
.LINE 1138

	LD	IY,(IX+%6)
	LD	BC,(IY+%0)
	LD	(IX+%FFFFFFFD),BC
; 1139	
; 1140	
; 1141		if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
.LINE 1141

	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	LD	BC,2
	XOR	A,A
	CALL	__lcmpu
	JR	C,L_56
	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%12)
	LD	A,(IY+%15)
	CALL	__lcmpu
	JR	C,L_57
L_56:
; 1142			val = 1;	/* Internal error */
.LINE 1142

	LD	BC,1
	XOR	A,A
	LD	(IX+%FFFFFFF6),BC
	LD	(IX+%FFFFFFF9),A
; 1143	
; 1144		} else {
.LINE 1144

	JR	L_58
L_57:
; 1145			val = 0xFFFFFFFF;	/* Default value falls on disk error */
.LINE 1145

	LD	BC,16777215
	LD	A,%FF
	LD	(IX+%FFFFFFF6),BC
	LD	(IX+%FFFFFFF9),A
; 1146	
; 1147			switch (fs->fs_type) {
.LINE 1147

	LD	IY,(IX+%FFFFFFFD)
	LD	A,(IY+%0)
	UEXT	HL
	LD	L,A
	CALL	__seqcaseD
	JP	(HL)
L__23:
	DW	3
	DW	1
	DB	0
	DW24	L_39	

	DW24	L_49	

	DW24	L_52	

	DW24	L_55	

; 1148			case FS_FAT12 :
L_39:
.LINE 1148

; 1149				bc = (UINT)clst; bc += bc / 2;
.LINE 1149

	LD	HL,(IX+%9)
	LD	A,%1
	CALL	__ishru_b
	LD	BC,(IX+%9)
	ADD	HL,BC
	LD	(IX+%FFFFFFFA),HL
; 1150				if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
.LINE 1150

	LD	A,%9
	CALL	__ishru_b
	LD	BC,HL
	XOR	A,A
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%1E)
	LD	E,(IY+%21)
	CALL	__ladd
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_move_window
	POP	BC
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_58
; 1151				wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
.LINE 1151

	LD	BC,511
	LD	HL,(IX+%FFFFFFFA)
	CALL	__iand
	LD	BC,HL
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%2E
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	(IX+%FFFFFFF3),HL
	LD	BC,(IX+%FFFFFFFA)
	INC	BC
	LD	(IX+%FFFFFFFA),BC
; 1152				if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
.LINE 1152

	LD	HL,BC
	LD	A,%9
	CALL	__ishru_b
	LD	BC,HL
	XOR	A,A
	LD	HL,(IY+%1E)
	LD	E,(IY+%21)
	CALL	__ladd
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_move_window
	POP	BC
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_58
; 1153				wc |= fs->win[bc % SS(fs)] << 8;	/* Merge 2nd byte of the entry */
.LINE 1153

	LD	BC,511
	LD	HL,(IX+%FFFFFFFA)
	CALL	__iand
	LD	BC,HL
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%2E
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,%8
	CALL	__ishl_b
	LD	BC,(IX+%FFFFFFF3)
	CALL	__ior
	LD	(IX+%FFFFFFF3),HL
; 1154				val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);	/* Adjust bit position */
.LINE 1154

	LD	A,(IX+%9)
	AND	A,%1
	UEXT	HL
	LD	L,A
	LD	E,H
	CALL	__lcmpzero
	JR	Z,L_47
	LD	HL,(IX+%FFFFFFF3)
	LD	A,%4
	CALL	__ishru_b
	LD	(IX+%FFFFFFF0),HL
	JR	L_48
L_47:
	LD	BC,4095
	LD	HL,(IX+%FFFFFFF3)
	CALL	__iand
	LD	(IX+%FFFFFFF0),HL
L_48:
	LD	BC,(IX+%FFFFFFF0)
	XOR	A,A
	LD	(IX+%FFFFFFF6),BC
	LD	(IX+%FFFFFFF9),A
; 1155				break;
.LINE 1155

	JR	L_58
; 1156	
; 1157			case FS_FAT16 :
L_49:
.LINE 1157

; 1158				if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
.LINE 1158

	LD	BC,(IX+%9)
	LD	A,(IX+%C)
	LD	L,%8
	CALL	__lshru
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%1E)
	LD	E,(IY+%21)
	CALL	__ladd
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_move_window
	POP	BC
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_58
; 1159				val = ld_word(fs->win + clst * 2 % SS(fs));		/* Simple WORD array */
.LINE 1159

	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	LD	BC,2
	XOR	A,A
	CALL	__lmulu
	LD	BC,511
	XOR	A,A
	CALL	__land
	LD	BC,HL
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%2E
	ADD	HL,BC
	PUSH	HL
	CALL	_ld_word
	POP	BC
	LD	BC,HL
	CALL	__stoiu
	XOR	A,A
	LD	(IX+%FFFFFFF6),HL
	LD	(IX+%FFFFFFF9),A
; 1160				break;
.LINE 1160

	JR	L_58
; 1161	
; 1162			case FS_FAT32 :
L_52:
.LINE 1162

; 1163				if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
.LINE 1163

	LD	BC,(IX+%9)
	LD	A,(IX+%C)
	LD	L,%7
	CALL	__lshru
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%1E)
	LD	E,(IY+%21)
	CALL	__ladd
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_move_window
	POP	BC
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_58
; 1164				val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;	/* Simple DWORD array but mask out upper 4 bits */
.LINE 1164

	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	LD	BC,4
	XOR	A,A
	CALL	__lmulu
	LD	BC,511
	XOR	A,A
	CALL	__land
	LD	BC,HL
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%2E
	ADD	HL,BC
	PUSH	HL
	CALL	_ld_dword
	POP	BC
	LD	BC,16777215
	LD	A,%F
	CALL	__land
	LD	(IX+%FFFFFFF6),HL
	LD	(IX+%FFFFFFF9),E
; 1165				break;
.LINE 1165

	JR	L_58
; 1166	#if FF_FS_EXFAT
; 1167			case FS_EXFAT :
; 1168				if ((obj->objsize != 0 && obj->sclust != 0) || obj->stat == 0) {	/* Object except root dir must have valid data length */
; 1169					DWORD cofs = clst - obj->sclust;	/* Offset from start cluster */
; 1170					DWORD clen = (DWORD)((LBA_t)((obj->objsize - 1) / SS(fs)) / fs->csize);	/* Number of clusters - 1 */
; 1171	
; 1172					if (obj->stat == 2 && cofs <= clen) {	/* Is it a contiguous chain? */
; 1173						val = (cofs == clen) ? 0x7FFFFFFF : clst + 1;	/* No data on the FAT, generate the value */
; 1174						break;
; 1175					}
; 1176					if (obj->stat == 3 && cofs < obj->n_cont) {	/* Is it in the 1st fragment? */
; 1177						val = clst + 1; 	/* Generate the value */
; 1178						break;
; 1179					}
; 1180					if (obj->stat != 2) {	/* Get value from FAT if FAT chain is valid */
; 1181						if (obj->n_frag != 0) {	/* Is it on the growing edge? */
; 1182							val = 0x7FFFFFFF;	/* Generate EOC */
; 1183						} else {
; 1184							if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
; 1185							val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x7FFFFFFF;
; 1186						}
; 1187						break;
; 1188					}
; 1189				}
; 1190				val = 1;	/* Internal error */
; 1191				break;
; 1192	#endif
; 1193			default:
L_55:
.LINE 1193

; 1194				val = 1;	/* Internal error */
.LINE 1194

	LD	BC,1
	XOR	A,A
	LD	(IX+%FFFFFFF6),BC
	LD	(IX+%FFFFFFF9),A
; 1195			}
; 1196		}
L_58:
.LINE 1196

; 1197	
; 1198		return val;
.LINE 1198

	LD	HL,(IX+%FFFFFFF6)
	LD	E,(IX+%FFFFFFF9)
; 1199	}
.LINE 1199

	LD	SP,IX
	POP	IX
	RET	


;**************************** _get_fat ***************************
;Name                         Addr/Register   Size   Type
;temp45                               IX-16      3   variable
;wc                                   IX-13      3   variable
;val                                  IX-10      4   variable
;bc                                    IX-6      3   variable
;fs                                    IX-3      3   variable
;clst                                  IX+9      4   parameter
;obj                                   IX+6      3   parameter


; Stack Frame Size: 31 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "get_fat",1199,"_get_fat"
; 1200	
; 1201	
; 1202	
; 1203	
; 1204	#if !FF_FS_READONLY
; 1205	/*-----------------------------------------------------------------------*/
; 1206	/* FAT access - Change value of an FAT entry                             */
; 1207	/*-----------------------------------------------------------------------*/
; 1208	
; 1209	static FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
; 1210		FATFS* fs,		/* Corresponding filesystem object */
; 1211		DWORD clst,		/* FAT index number (cluster number) to be changed */
; 1212		DWORD val		/* New value to be set to the entry */
; 1213	)
; 1214	{
; 1215		UINT bc;
; 1216		BYTE *p;
; 1217		FRESULT res = FR_INT_ERR;
; 1218	
; 1219	
; 1220		if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
; 1221			switch (fs->fs_type) {
; 1222			case FS_FAT12:
; 1223				bc = (UINT)clst; bc += bc / 2;	/* bc: byte offset of the entry */
; 1224				res = move_window(fs, fs->fatbase + (bc / SS(fs)));
; 1225				if (res != FR_OK) break;
; 1226				p = fs->win + bc++ % SS(fs);
; 1227				*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;	/* Update 1st byte */
; 1228				fs->wflag = 1;
; 1229				res = move_window(fs, fs->fatbase + (bc / SS(fs)));
; 1230				if (res != FR_OK) break;
; 1231				p = fs->win + bc % SS(fs);
; 1232				*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));	/* Update 2nd byte */
; 1233				fs->wflag = 1;
; 1234				break;
; 1235	
; 1236			case FS_FAT16:
; 1237				res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
; 1238				if (res != FR_OK) break;
; 1239				st_word(fs->win + clst * 2 % SS(fs), (WORD)val);	/* Simple WORD array */
; 1240				fs->wflag = 1;
; 1241				break;
; 1242	
; 1243			case FS_FAT32:
; 1244	#if FF_FS_EXFAT
; 1245			case FS_EXFAT:
; 1246	#endif
; 1247				res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
; 1248				if (res != FR_OK) break;
; 1249				if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {
; 1250					val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
; 1251				}
; 1252				st_dword(fs->win + clst * 4 % SS(fs), val);
; 1253				fs->wflag = 1;
; 1254				break;
; 1255			}
; 1256		}
; 1257		return res;
; 1258	}
; 1259	
; 1260	#endif /* !FF_FS_READONLY */
; 1261	
; 1262	
; 1263	
; 1264	
; 1265	#if FF_FS_EXFAT && !FF_FS_READONLY
; 1266	/*-----------------------------------------------------------------------*/
; 1267	/* exFAT: Accessing FAT and Allocation Bitmap                            */
; 1268	/*-----------------------------------------------------------------------*/
; 1269	
; 1270	/*--------------------------------------*/
; 1271	/* Find a contiguous free cluster block */
; 1272	/*--------------------------------------*/
; 1273	
; 1274	static DWORD find_bitmap (	/* 0:Not found, 2..:Cluster block found, 0xFFFFFFFF:Disk error */
; 1275		FATFS* fs,	/* Filesystem object */
; 1276		DWORD clst,	/* Cluster number to scan from */
; 1277		DWORD ncl	/* Number of contiguous clusters to find (1..) */
; 1278	)
; 1279	{
; 1280		BYTE bm, bv;
; 1281		UINT i;
; 1282		DWORD val, scl, ctr;
; 1283	
; 1284	
; 1285		clst -= 2;	/* The first bit in the bitmap corresponds to cluster #2 */
; 1286		if (clst >= fs->n_fatent - 2) clst = 0;
; 1287		scl = val = clst; ctr = 0;
; 1288		for (;;) {
; 1289			if (move_window(fs, fs->bitbase + val / 8 / SS(fs)) != FR_OK) return 0xFFFFFFFF;
; 1290			i = val / 8 % SS(fs); bm = 1 << (val % 8);
; 1291			do {
; 1292				do {
; 1293					bv = fs->win[i] & bm; bm <<= 1;		/* Get bit value */
; 1294					if (++val >= fs->n_fatent - 2) {	/* Next cluster (with wrap-around) */
; 1295						val = 0; bm = 0; i = SS(fs);
; 1296					}
; 1297					if (bv == 0) {	/* Is it a free cluster? */
; 1298						if (++ctr == ncl) return scl + 2;	/* Check if run length is sufficient for required */
; 1299					} else {
; 1300						scl = val; ctr = 0;		/* Encountered a cluster in-use, restart to scan */
; 1301					}
; 1302					if (val == clst) return 0;	/* All cluster scanned? */
; 1303				} while (bm != 0);
; 1304				bm = 1;
; 1305			} while (++i < SS(fs));
; 1306		}
; 1307	}
; 1308	
; 1309	
; 1310	/*----------------------------------------*/
; 1311	/* Set/Clear a block of allocation bitmap */
; 1312	/*----------------------------------------*/
; 1313	
; 1314	static FRESULT change_bitmap (
; 1315		FATFS* fs,	/* Filesystem object */
; 1316		DWORD clst,	/* Cluster number to change from */
; 1317		DWORD ncl,	/* Number of clusters to be changed */
; 1318		int bv		/* bit value to be set (0 or 1) */
; 1319	)
; 1320	{
; 1321		BYTE bm;
; 1322		UINT i;
; 1323		LBA_t sect;
; 1324	
; 1325	
; 1326		clst -= 2;	/* The first bit corresponds to cluster #2 */
; 1327		sect = fs->bitbase + clst / 8 / SS(fs);	/* Sector address */
; 1328		i = clst / 8 % SS(fs);					/* Byte offset in the sector */
; 1329		bm = 1 << (clst % 8);					/* Bit mask in the byte */
; 1330		for (;;) {
; 1331			if (move_window(fs, sect++) != FR_OK) return FR_DISK_ERR;
; 1332			do {
; 1333				do {
; 1334					if (bv == (int)((fs->win[i] & bm) != 0)) return FR_INT_ERR;	/* Is the bit expected value? */
; 1335					fs->win[i] ^= bm;	/* Flip the bit */
; 1336					fs->wflag = 1;
; 1337					if (--ncl == 0) return FR_OK;	/* All bits processed? */
; 1338				} while (bm <<= 1);		/* Next bit */
; 1339				bm = 1;
; 1340			} while (++i < SS(fs));		/* Next byte */
; 1341			i = 0;
; 1342		}
; 1343	}
; 1344	
; 1345	
; 1346	/*---------------------------------------------*/
; 1347	/* Fill the first fragment of the FAT chain    */
; 1348	/*---------------------------------------------*/
; 1349	
; 1350	static FRESULT fill_first_frag (
; 1351		FFOBJID* obj	/* Pointer to the corresponding object */
; 1352	)
; 1353	{
; 1354		FRESULT res;
; 1355		DWORD cl, n;
; 1356	
; 1357	
; 1358		if (obj->stat == 3) {	/* Has the object been changed 'fragmented' in this session? */
; 1359			for (cl = obj->sclust, n = obj->n_cont; n; cl++, n--) {	/* Create cluster chain on the FAT */
; 1360				res = put_fat(obj->fs, cl, cl + 1);
; 1361				if (res != FR_OK) return res;
; 1362			}
; 1363			obj->stat = 0;	/* Change status 'FAT chain is valid' */
; 1364		}
; 1365		return FR_OK;
; 1366	}
; 1367	
; 1368	
; 1369	/*---------------------------------------------*/
; 1370	/* Fill the last fragment of the FAT chain     */
; 1371	/*---------------------------------------------*/
; 1372	
; 1373	static FRESULT fill_last_frag (
; 1374		FFOBJID* obj,	/* Pointer to the corresponding object */
; 1375		DWORD lcl,		/* Last cluster of the fragment */
; 1376		DWORD term		/* Value to set the last FAT entry */
; 1377	)
; 1378	{
; 1379		FRESULT res;
; 1380	
; 1381	
; 1382		while (obj->n_frag > 0) {	/* Create the chain of last fragment */
; 1383			res = put_fat(obj->fs, lcl - obj->n_frag + 1, (obj->n_frag > 1) ? lcl - obj->n_frag + 2 : term);
; 1384			if (res != FR_OK) return res;
; 1385			obj->n_frag--;
; 1386		}
; 1387		return FR_OK;
; 1388	}
; 1389	
; 1390	#endif	/* FF_FS_EXFAT && !FF_FS_READONLY */
; 1391	
; 1392	
; 1393	
; 1394	#if !FF_FS_READONLY
; 1395	/*-----------------------------------------------------------------------*/
; 1396	/* FAT handling - Remove a cluster chain                                 */
; 1397	/*-----------------------------------------------------------------------*/
; 1398	
; 1399	static FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
; 1400		FFOBJID* obj,		/* Corresponding object */
; 1401		DWORD clst,			/* Cluster to remove a chain from */
; 1402		DWORD pclst			/* Previous cluster of clst (0 if entire chain) */
; 1403	)
; 1404	{
; 1405		FRESULT res = FR_OK;
; 1406		DWORD nxt;
; 1407		FATFS *fs = obj->fs;
; 1408	#if FF_FS_EXFAT || FF_USE_TRIM
; 1409		DWORD scl = clst, ecl = clst;
; 1410	#endif
; 1411	#if FF_USE_TRIM
; 1412		LBA_t rt[2];
; 1413	#endif
; 1414	
; 1415		if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
; 1416	
; 1417		/* Mark the previous cluster 'EOC' on the FAT if it exists */
; 1418		if (pclst != 0 && (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {
; 1419			res = put_fat(fs, pclst, 0xFFFFFFFF);
; 1420			if (res != FR_OK) return res;
; 1421		}
; 1422	
; 1423		/* Remove the chain */
; 1424		do {
; 1425			nxt = get_fat(obj, clst);			/* Get cluster status */
; 1426			if (nxt == 0) break;				/* Empty cluster? */
; 1427			if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
; 1428			if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
; 1429			if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {
; 1430				res = put_fat(fs, clst, 0);		/* Mark the cluster 'free' on the FAT */
; 1431				if (res != FR_OK) return res;
; 1432			}
; 1433			if (fs->free_clst < fs->n_fatent - 2) {	/* Update FSINFO */
; 1434				fs->free_clst++;
; 1435				fs->fsi_flag |= 1;
; 1436			}
; 1437	#if FF_FS_EXFAT || FF_USE_TRIM
; 1438			if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
; 1439				ecl = nxt;
; 1440			} else {				/* End of contiguous cluster block */
; 1441	#if FF_FS_EXFAT
; 1442				if (fs->fs_type == FS_EXFAT) {
; 1443					res = change_bitmap(fs, scl, ecl - scl + 1, 0);	/* Mark the cluster block 'free' on the bitmap */
; 1444					if (res != FR_OK) return res;
; 1445				}
; 1446	#endif
; 1447	#if FF_USE_TRIM
; 1448				rt[0] = clst2sect(fs, scl);					/* Start of data area to be freed */
; 1449				rt[1] = clst2sect(fs, ecl) + fs->csize - 1;	/* End of data area to be freed */
; 1450				disk_ioctl(fs->pdrv, CTRL_TRIM, rt);		/* Inform storage device that the data in the block may be erased */
; 1451	#endif
; 1452				scl = ecl = nxt;
; 1453			}
; 1454	#endif
; 1455			clst = nxt;					/* Next cluster */
; 1456		} while (clst < fs->n_fatent);	/* Repeat while not the last link */
; 1457	
; 1458	#if FF_FS_EXFAT
; 1459		/* Some post processes for chain status */
; 1460		if (fs->fs_type == FS_EXFAT) {
; 1461			if (pclst == 0) {	/* Has the entire chain been removed? */
; 1462				obj->stat = 0;		/* Change the chain status 'initial' */
; 1463			} else {
; 1464				if (obj->stat == 0) {	/* Is it a fragmented chain from the beginning of this session? */
; 1465					clst = obj->sclust;		/* Follow the chain to check if it gets contiguous */
; 1466					while (clst != pclst) {
; 1467						nxt = get_fat(obj, clst);
; 1468						if (nxt < 2) return FR_INT_ERR;
; 1469						if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;
; 1470						if (nxt != clst + 1) break;	/* Not contiguous? */
; 1471						clst++;
; 1472					}
; 1473					if (clst == pclst) {	/* Has the chain got contiguous again? */
; 1474						obj->stat = 2;		/* Change the chain status 'contiguous' */
; 1475					}
; 1476				} else {
; 1477					if (obj->stat == 3 && pclst >= obj->sclust && pclst <= obj->sclust + obj->n_cont) {	/* Was the chain fragmented in this session and got contiguous again? */
; 1478						obj->stat = 2;	/* Change the chain status 'contiguous' */
; 1479					}
; 1480				}
; 1481			}
; 1482		}
; 1483	#endif
; 1484		return FR_OK;
; 1485	}
; 1486	
; 1487	
; 1488	
; 1489	
; 1490	/*-----------------------------------------------------------------------*/
; 1491	/* FAT handling - Stretch a chain or Create a new chain                  */
; 1492	/*-----------------------------------------------------------------------*/
; 1493	
; 1494	static DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
; 1495		FFOBJID* obj,		/* Corresponding object */
; 1496		DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
; 1497	)
; 1498	{
; 1499		DWORD cs, ncl, scl;
; 1500		FRESULT res;
; 1501		FATFS *fs = obj->fs;
; 1502	
; 1503	
; 1504		if (clst == 0) {	/* Create a new chain */
; 1505			scl = fs->last_clst;				/* Suggested cluster to start to find */
; 1506			if (scl == 0 || scl >= fs->n_fatent) scl = 1;
; 1507		}
; 1508		else {				/* Stretch a chain */
; 1509			cs = get_fat(obj, clst);			/* Check the cluster status */
; 1510			if (cs < 2) return 1;				/* Test for insanity */
; 1511			if (cs == 0xFFFFFFFF) return cs;	/* Test for disk error */
; 1512			if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
; 1513			scl = clst;							/* Cluster to start to find */
; 1514		}
; 1515		if (fs->free_clst == 0) return 0;		/* No free cluster */
; 1516	
; 1517	#if FF_FS_EXFAT
; 1518		if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
; 1519			ncl = find_bitmap(fs, scl, 1);				/* Find a free cluster */
; 1520			if (ncl == 0 || ncl == 0xFFFFFFFF) return ncl;	/* No free cluster or hard error? */
; 1521			res = change_bitmap(fs, ncl, 1, 1);			/* Mark the cluster 'in use' */
; 1522			if (res == FR_INT_ERR) return 1;
; 1523			if (res == FR_DISK_ERR) return 0xFFFFFFFF;
; 1524			if (clst == 0) {							/* Is it a new chain? */
; 1525				obj->stat = 2;							/* Set status 'contiguous' */
; 1526			} else {									/* It is a stretched chain */
; 1527				if (obj->stat == 2 && ncl != scl + 1) {	/* Is the chain got fragmented? */
; 1528					obj->n_cont = scl - obj->sclust;	/* Set size of the contiguous part */
; 1529					obj->stat = 3;						/* Change status 'just fragmented' */
; 1530				}
; 1531			}
; 1532			if (obj->stat != 2) {	/* Is the file non-contiguous? */
; 1533				if (ncl == clst + 1) {	/* Is the cluster next to previous one? */
; 1534					obj->n_frag = obj->n_frag ? obj->n_frag + 1 : 2;	/* Increment size of last framgent */
; 1535				} else {				/* New fragment */
; 1536					if (obj->n_frag == 0) obj->n_frag = 1;
; 1537					res = fill_last_frag(obj, clst, ncl);	/* Fill last fragment on the FAT and link it to new one */
; 1538					if (res == FR_OK) obj->n_frag = 1;
; 1539				}
; 1540			}
; 1541		} else
; 1542	#endif
; 1543		{	/* On the FAT/FAT32 volume */
; 1544			ncl = 0;
; 1545			if (scl == clst) {						/* Stretching an existing chain? */
; 1546				ncl = scl + 1;						/* Test if next cluster is free */
; 1547				if (ncl >= fs->n_fatent) ncl = 2;
; 1548				cs = get_fat(obj, ncl);				/* Get next cluster status */
; 1549				if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* Test for error */
; 1550				if (cs != 0) {						/* Not free? */
; 1551					cs = fs->last_clst;				/* Start at suggested cluster if it is valid */
; 1552					if (cs >= 2 && cs < fs->n_fatent) scl = cs;
; 1553					ncl = 0;
; 1554				}
; 1555			}
; 1556			if (ncl == 0) {	/* The new cluster cannot be contiguous and find another fragment */
; 1557				ncl = scl;	/* Start cluster */
; 1558				for (;;) {
; 1559					ncl++;							/* Next cluster */
; 1560					if (ncl >= fs->n_fatent) {		/* Check wrap-around */
; 1561						ncl = 2;
; 1562						if (ncl > scl) return 0;	/* No free cluster found? */
; 1563					}
; 1564					cs = get_fat(obj, ncl);			/* Get the cluster status */
; 1565					if (cs == 0) break;				/* Found a free cluster? */
; 1566					if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* Test for error */
; 1567					if (ncl == scl) return 0;		/* No free cluster found? */
; 1568				}
; 1569			}
; 1570			res = put_fat(fs, ncl, 0xFFFFFFFF);		/* Mark the new cluster 'EOC' */
; 1571			if (res == FR_OK && clst != 0) {
; 1572				res = put_fat(fs, clst, ncl);		/* Link it from the previous one if needed */
; 1573			}
; 1574		}
; 1575	
; 1576		if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
; 1577			fs->last_clst = ncl;
; 1578			if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
; 1579			fs->fsi_flag |= 1;
; 1580		} else {
; 1581			ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
; 1582		}
; 1583	
; 1584		return ncl;		/* Return new cluster number or error status */
; 1585	}
; 1586	
; 1587	#endif /* !FF_FS_READONLY */
; 1588	
; 1589	
; 1590	
; 1591	
; 1592	#if FF_USE_FASTSEEK
; 1593	/*-----------------------------------------------------------------------*/
; 1594	/* FAT handling - Convert offset into cluster with link map table        */
; 1595	/*-----------------------------------------------------------------------*/
; 1596	
; 1597	static DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
; 1598		FIL* fp,		/* Pointer to the file object */
; 1599		FSIZE_t ofs		/* File offset to be converted to cluster# */
; 1600	)
; 1601	{
; 1602		DWORD cl, ncl, *tbl;
; 1603		FATFS *fs = fp->obj.fs;
; 1604	
; 1605	
; 1606		tbl = fp->cltbl + 1;	/* Top of CLMT */
; 1607		cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
; 1608		for (;;) {
; 1609			ncl = *tbl++;			/* Number of cluters in the fragment */
; 1610			if (ncl == 0) return 0;	/* End of table? (error) */
; 1611			if (cl < ncl) break;	/* In this fragment? */
; 1612			cl -= ncl; tbl++;		/* Next fragment */
; 1613		}
; 1614		return cl + *tbl;	/* Return the cluster number */
; 1615	}
; 1616	
; 1617	#endif	/* FF_USE_FASTSEEK */
; 1618	
; 1619	
; 1620	
; 1621	
; 1622	/*-----------------------------------------------------------------------*/
; 1623	/* Directory handling - Fill a cluster with zeros                        */
; 1624	/*-----------------------------------------------------------------------*/
; 1625	
; 1626	#if !FF_FS_READONLY
; 1627	static FRESULT dir_clear (	/* Returns FR_OK or FR_DISK_ERR */
; 1628		FATFS *fs,		/* Filesystem object */
; 1629		DWORD clst		/* Directory table to clear */
; 1630	)
; 1631	{
; 1632		LBA_t sect;
; 1633		UINT n, szb;
; 1634		BYTE *ibuf;
; 1635	
; 1636	
; 1637		if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
; 1638		sect = clst2sect(fs, clst);		/* Top of the cluster */
; 1639		fs->winsect = sect;				/* Set window to top of the cluster */
; 1640		memset(fs->win, 0, sizeof fs->win);	/* Clear window buffer */
; 1641	#if FF_USE_LFN == 3		/* Quick table clear by using multi-secter write */
; 1642		/* Allocate a temporary buffer */
; 1643		for (szb = ((DWORD)fs->csize * SS(fs) >= MAX_MALLOC) ? MAX_MALLOC : fs->csize * SS(fs), ibuf = 0; szb > SS(fs) && (ibuf = ff_memalloc(szb)) == 0; szb /= 2) ;
; 1644		if (szb > SS(fs)) {		/* Buffer allocated? */
; 1645			memset(ibuf, 0, szb);
; 1646			szb /= SS(fs);		/* Bytes -> Sectors */
; 1647			for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* Fill the cluster with 0 */
; 1648			ff_memfree(ibuf);
; 1649		} else
; 1650	#endif
; 1651		{
; 1652			ibuf = fs->win; szb = 1;	/* Use window buffer (many single-sector writes may take a time) */
; 1653			for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* Fill the cluster with 0 */
; 1654		}
; 1655		return (n == fs->csize) ? FR_OK : FR_DISK_ERR;
; 1656	}
; 1657	#endif	/* !FF_FS_READONLY */
; 1658	
; 1659	
; 1660	
; 1661	
; 1662	/*-----------------------------------------------------------------------*/
; 1663	/* Directory handling - Set directory index                              */
; 1664	/*-----------------------------------------------------------------------*/
; 1665	
; 1666	static FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
; 1667		DIR* dp,		/* Pointer to directory object */
; 1668		DWORD ofs		/* Offset of directory table */
; 1669	)
; 1670	{
_dir_sdi:
.DEFINE "_dir_sdi"

.VALUE _dir_sdi

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "dir_sdi",1670,"_dir_sdi"

.LINE 1670

.DEFINE "dp"

.CLASS 65

.VALUE 6

.TAG "NONAME3"

.TYPE 40

.ENDEF

.DEFINE "ofs"

.CLASS 65

.VALUE 9

.TYPE 15

.ENDEF

.DEFINE "clst"

.CLASS 65

.VALUE -4

.TYPE 15

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -7

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "csz"

.CLASS 65

.VALUE -11

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF0
	LD	SP,HL
; 1671		DWORD csz, clst;
; 1672		FATFS *fs = dp->obj.fs;
.LINE 1672

	LD	IY,(IX+%6)
	LD	BC,(IY+%0)
	LD	(IX+%FFFFFFF9),BC
; 1673	
; 1674	
; 1675		if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
.LINE 1675

	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	LD	BC,2097152
	XOR	A,A
	CALL	__lcmpu
	JR	NC,L_61
	LD	A,(IX+%9)
	AND	A,%1F
	UEXT	HL
	LD	L,A
	LD	E,H
	CALL	__lcmpzero
	JR	Z,L_62
L_61:
; 1676			return FR_INT_ERR;
.LINE 1676

	LD	HL,2
	JR	L_82
; 1677		}
L_62:
.LINE 1677

; 1678		dp->dptr = ofs;				/* Set current offset */
.LINE 1678

	LD	BC,(IX+%9)
	LD	A,(IX+%C)
	LD	IY,(IX+%6)
	LD	(IY+%F),BC
	LD	(IY+%12),A
; 1679		clst = dp->obj.sclust;		/* Table start cluster (0:root) */
.LINE 1679

	LD	BC,(IY+%7)
	LD	A,(IY+%A)
	LD	(IX+%FFFFFFFC),BC
	LD	(IX+%FFFFFFFF),A
; 1680		if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
.LINE 1680

	LD	HL,BC
	LD	E,(IX+%FFFFFFFF)
	CALL	__lcmpzero
	JR	NZ,L_78
	LD	IY,(IX+%FFFFFFF9)
	LD	A,(IY+%0)
	CP	A,%3
	JR	C,L_78
; 1681			clst = (DWORD)fs->dirbase;
.LINE 1681

	LD	IY,(IX+%FFFFFFF9)
	LD	BC,(IY+%22)
	LD	A,(IY+%25)
	LD	(IX+%FFFFFFFC),BC
	LD	(IX+%FFFFFFFF),A
; 1682			if (FF_FS_EXFAT) dp->obj.stat = 0;	/* exFAT: Root dir has an FAT chain */
; 1683		}
L_78:
.LINE 1683

; 1684	
; 1685		if (clst == 0) {	/* Static table (root-directory on the FAT volume) */
.LINE 1685

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	CALL	__lcmpzero
	JR	NZ,L_77
; 1686			if (ofs / SZDIRE >= fs->n_rootdir) return FR_INT_ERR;	/* Is index out of range? */
.LINE 1686

	LD	IY,(IX+%FFFFFFF9)
	LD	BC,(IY+%7)
	CALL	__stoiu
	LD	(IX+%FFFFFFF2),HL
	LD	B,%0
	LD	(IX+%FFFFFFF0),B	; spill
	LD	BC,(IX+%9)
	LD	A,(IX+%C)
	LD	L,%5
	CALL	__lshru
	LD	E,A
	LD	HL,BC
	LD	B,(IX+%FFFFFFF0)	; unspill
	LD	A,B
	LD	BC,(IX+%FFFFFFF2)
	CALL	__lcmpu
	JR	C,L_67
	LD	HL,2
	JR	L_82
L_67:
; 1687			dp->sect = fs->dirbase;
.LINE 1687

	LD	IY,(IX+%FFFFFFF9)
	LD	BC,(IY+%22)
	LD	A,(IY+%25)
	LD	IY,(IX+%6)
	LD	(IY+%17),BC
	LD	(IY+%1A),A
; 1688	
; 1689		} else {			/* Dynamic table (sub-directory or root-directory on the FAT32/exFAT volume) */
.LINE 1689

	JR	L_79
L_77:
; 1690			csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
.LINE 1690

	LD	IY,(IX+%FFFFFFF9)
	LD	BC,(IY+%9)
	CALL	__stoiu
	LD	E,%0
	LD	BC,512
	XOR	A,A
	CALL	__lmulu
	LD	(IX+%FFFFFFF5),HL
	LD	(IX+%FFFFFFF8),E
; 1691			while (ofs >= csz) {				/* Follow cluster chain */
.LINE 1691

	JR	L_73
L_74:
; 1692				clst = get_fat(&dp->obj, clst);				/* Get next cluster */
.LINE 1692

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFFC)
	PUSH	BC
	LD	IY,(IX+%6)
	PEA	IY+%0
	CALL	_get_fat
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),E
; 1693				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
.LINE 1693

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,16777215
	LD	A,%FF
	CALL	__lcmpu
	JR	NZ,L_71
	LD	HL,1
	JR	L_82
L_71:
; 1694				if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
.LINE 1694

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,2
	XOR	A,A
	CALL	__lcmpu
	JR	C,L_70
	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	IY,(IX+%FFFFFFF9)
	LD	BC,(IY+%12)
	LD	A,(IY+%15)
	CALL	__lcmpu
	JR	C,L_72
L_70:
	LD	HL,2
	JR	L_82
L_72:
; 1695				ofs -= csz;
.LINE 1695

	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	LD	BC,(IX+%FFFFFFF5)
	LD	A,(IX+%FFFFFFF8)
	CALL	__lsub
	LD	(IX+%9),HL
	LD	(IX+%C),E
; 1696			}
L_73:
.LINE 1696

	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	LD	BC,(IX+%FFFFFFF5)
	LD	A,(IX+%FFFFFFF8)
	CALL	__lcmpu
	JR	NC,L_74
; 1697			dp->sect = clst2sect(fs, clst);
.LINE 1697

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFFC)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF9)
	PUSH	BC
	CALL	_clst2sect
	POP	BC
	POP	BC
	POP	BC
	LD	IY,(IX+%6)
	LD	(IY+%17),HL
	LD	(IY+%1A),E
; 1698		}
L_79:
.LINE 1698

; 1699		dp->clust = clst;					/* Current cluster# */
.LINE 1699

	LD	BC,(IX+%FFFFFFFC)
	LD	A,(IX+%FFFFFFFF)
	LD	IY,(IX+%6)
	LD	(IY+%13),BC
	LD	(IY+%16),A
; 1700		if (dp->sect == 0) return FR_INT_ERR;
.LINE 1700

	LD	HL,(IY+%17)
	LD	E,(IY+%1A)
	CALL	__lcmpzero
	JR	NZ,L_81
	LD	HL,2
	JR	L_82
L_81:
; 1701		dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
.LINE 1701

	LD	BC,(IX+%9)
	LD	A,(IX+%C)
	LD	L,%9
	CALL	__lshru
	LD	IY,(IX+%6)
	LD	HL,(IY+%17)
	LD	E,(IY+%1A)
	CALL	__ladd
	LD	(IY+%17),HL
	LD	(IY+%1A),E
; 1702		dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
.LINE 1702

	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	LD	BC,511
	XOR	A,A
	CALL	__land
	LD	BC,HL
	LD	IY,(IX+%FFFFFFF9)
	LEA	HL,IY+%2E
	ADD	HL,BC
	LD	IY,(IX+%6)
	LD	(IY+%1B),HL
; 1703	
; 1704		return FR_OK;
.LINE 1704

	OR	A,A
	SBC	HL,HL
; 1705	}
L_82:
.LINE 1705

	LD	SP,IX
	POP	IX
	RET	


;**************************** _dir_sdi ***************************
;Name                         Addr/Register   Size   Type
;csz                                  IX-11      4   variable
;fs                                    IX-7      3   variable
;clst                                  IX-4      4   variable
;ofs                                   IX+9      4   parameter
;dp                                    IX+6      3   parameter


; Stack Frame Size: 31 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "dir_sdi",1705,"_dir_sdi"
; 1706	
; 1707	
; 1708	
; 1709	
; 1710	/*-----------------------------------------------------------------------*/
; 1711	/* Directory handling - Move directory table index next                  */
; 1712	/*-----------------------------------------------------------------------*/
; 1713	
; 1714	static FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
; 1715		DIR* dp,				/* Pointer to the directory object */
; 1716		int stretch				/* 0: Do not stretch table, 1: Stretch table if needed */
; 1717	)
; 1718	{
_dir_next:
.DEFINE "_dir_next"

.VALUE _dir_next

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "dir_next",1718,"_dir_next"

.LINE 1718

.DEFINE "dp"

.CLASS 65

.VALUE 6

.TAG "NONAME3"

.TYPE 40

.ENDEF

.DEFINE "stretch"

.CLASS 65

.VALUE 9

.TYPE 4

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -3

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "clst"

.CLASS 65

.VALUE -7

.TYPE 15

.ENDEF

.DEFINE "ofs"

.CLASS 65

.VALUE -11

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFE1
	LD	SP,HL
; 1719		DWORD ofs, clst;
; 1720		FATFS *fs = dp->obj.fs;
.LINE 1720

	LD	IY,(IX+%6)
	LD	BC,(IY+%0)
	LD	(IX+%FFFFFFFD),BC
; 1721	
; 1722	
; 1723		ofs = dp->dptr + SZDIRE;	/* Next entry */
.LINE 1723

	LD	HL,(IY+%F)
	LD	E,(IY+%12)
	LD	A,%20
	CALL	__ladd_b
	LD	(IX+%FFFFFFF5),HL
	LD	(IX+%FFFFFFF8),E
; 1724		if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) dp->sect = 0;	/* Disable it if the offset reached the max value */
.LINE 1724

	LD	HL,(IX+%FFFFFFF5)
	LD	E,(IX+%FFFFFFF8)
	LD	BC,2097152
	XOR	A,A
	CALL	__lcmpu
	JR	C,L_85
	LD	BC,0
	LD	IY,(IX+%6)
	LD	(IY+%17),BC
	LD	(IY+%1A),%0
L_85:
; 1725		if (dp->sect == 0) return FR_NO_FILE;	/* Report EOT if it has been disabled */
.LINE 1725

	LD	IY,(IX+%6)
	LD	BC,(IY+%17)
	LD	A,(IY+%1A)
	LD	(IX+%FFFFFFF1),BC
	LD	(IX+%FFFFFFF4),A
	LD	HL,BC
	LD	E,(IX+%FFFFFFF4)
	CALL	__lcmpzero
	JR	NZ,L_100
	LD	HL,4
	JR	L_102
L_100:
; 1726	
; 1727		if (ofs % SS(fs) == 0) {	/* Sector changed? */
.LINE 1727

	LD	HL,(IX+%FFFFFFF5)
	LD	E,(IX+%FFFFFFF8)
	LD	BC,511
	XOR	A,A
	CALL	__land
	LD	(IX+%FFFFFFED),HL
	LD	(IX+%FFFFFFF0),E
	LD	HL,(IX+%FFFFFFED)
	LD	E,(IX+%FFFFFFF0)
	CALL	__lcmpzero
	JR	NZ,L_101
; 1728			dp->sect++;				/* Next sector */
.LINE 1728

	LD	HL,(IX+%FFFFFFF1)
	LD	E,(IX+%FFFFFFF4)
	LD	A,%1
	CALL	__ladd_b
	LD	IY,(IX+%6)
	LD	(IY+%17),HL
	LD	(IY+%1A),E
; 1729	
; 1730			if (dp->clust == 0) {	/* Static table */
.LINE 1730

	LD	BC,(IY+%13)
	LD	A,(IY+%16)
	LD	(IX+%FFFFFFE9),BC
	LD	(IX+%FFFFFFEC),A
	LD	HL,BC
	LD	E,(IX+%FFFFFFEC)
	CALL	__lcmpzero
	JR	NZ,L_98
; 1731				if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
.LINE 1731

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%7)
	CALL	__stoiu
	LD	(IX+%FFFFFFE3),HL
	LD	B,%0
	LD	(IX+%FFFFFFE1),B	; spill
	LD	BC,(IX+%FFFFFFF5)
	LD	A,(IX+%FFFFFFF8)
	LD	L,%5
	CALL	__lshru
	LD	E,A
	LD	HL,BC
	LD	B,(IX+%FFFFFFE1)	; unspill
	LD	A,B
	LD	BC,(IX+%FFFFFFE3)
	CALL	__lcmpu
	JR	C,L_101
; 1732					dp->sect = 0; return FR_NO_FILE;
.LINE 1732

	LD	BC,0
	LD	IY,(IX+%6)
	LD	(IY+%17),BC
	LD	(IY+%1A),%0
	LD	HL,4
	JR	L_102
; 1733				}
; 1734			}
; 1735			else {					/* Dynamic table */
L_98:
.LINE 1735

; 1736				if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {	/* Cluster changed? */
.LINE 1736

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%9)
	CALL	__stoiu
	DEC	HL
	LD	BC,HL
	CALL	__itol
	LD	(IX+%FFFFFFE6),BC
	LD	E,A
	LD	BC,(IX+%FFFFFFF5)
	LD	A,(IX+%FFFFFFF8)
	LD	L,%9
	CALL	__lshru
	LD	HL,(IX+%FFFFFFE6)
	CALL	__land
	CALL	__lcmpzero
	JR	NZ,L_101
; 1737					clst = get_fat(&dp->obj, dp->clust);		/* Get next cluster */
.LINE 1737

	LD	C,(IX+%FFFFFFEC)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFE9)
	PUSH	BC
	LD	IY,(IX+%6)
	PEA	IY+%0
	CALL	_get_fat
	POP	BC
	POP	BC
	POP	BC
	LD	BC,HL
	LD	(IX+%FFFFFFF9),BC
	LD	(IX+%FFFFFFFC),E
; 1738					if (clst <= 1) return FR_INT_ERR;			/* Internal error */
.LINE 1738

	LD	HL,1
	LD	E,%0
	LD	A,(IX+%FFFFFFFC)
	CALL	__lcmpu
	JR	C,L_90
	LD	HL,2
	JR	L_102
L_90:
; 1739					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
.LINE 1739

	LD	HL,(IX+%FFFFFFF9)
	LD	E,(IX+%FFFFFFFC)
	LD	BC,16777215
	LD	A,%FF
	CALL	__lcmpu
	JR	NZ,L_94
	LD	HL,1
	JR	L_102
L_94:
; 1740					if (clst >= fs->n_fatent) {					/* It reached end of dynamic table */
.LINE 1740

	LD	HL,(IX+%FFFFFFF9)
	LD	E,(IX+%FFFFFFFC)
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%12)
	LD	A,(IY+%15)
	CALL	__lcmpu
	JR	C,L_95
; 1741	#if !FF_FS_READONLY
; 1742						if (!stretch) {								/* If no stretch, report EOT */
; 1743							dp->sect = 0; return FR_NO_FILE;
; 1744						}
; 1745						clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
; 1746						if (clst == 0) return FR_DENIED;			/* No free cluster */
; 1747						if (clst == 1) return FR_INT_ERR;			/* Internal error */
; 1748						if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
; 1749						if (dir_clear(fs, clst) != FR_OK) return FR_DISK_ERR;	/* Clean up the stretched table */
; 1750						if (FF_FS_EXFAT) dp->obj.stat |= 4;			/* exFAT: The directory has been stretched */
; 1751	#else
; 1752						if (!stretch) dp->sect = 0;					/* (this line is to suppress compiler warning) */
.LINE 1752

	LD	HL,(IX+%9)
	CALL	__icmpzero
	JR	NZ,L_92
	LD	BC,0
	LD	IY,(IX+%6)
	LD	(IY+%17),BC
	LD	(IY+%1A),%0
L_92:
; 1753						dp->sect = 0; return FR_NO_FILE;			/* Report EOT */
.LINE 1753

	LD	BC,0
	LD	IY,(IX+%6)
	LD	(IY+%17),BC
	LD	(IY+%1A),%0
	LD	HL,4
	JR	L_102
; 1754	#endif
; 1755					}
L_95:
.LINE 1755

; 1756					dp->clust = clst;		/* Initialize data for new cluster */
.LINE 1756

	LD	BC,(IX+%FFFFFFF9)
	LD	A,(IX+%FFFFFFFC)
	LD	IY,(IX+%6)
	LD	(IY+%13),BC
	LD	(IY+%16),A
; 1757					dp->sect = clst2sect(fs, clst);
.LINE 1757

	LD	C,(IX+%FFFFFFFC)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFF9)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_clst2sect
	POP	BC
	POP	BC
	POP	BC
	LD	IY,(IX+%6)
	LD	(IY+%17),HL
	LD	(IY+%1A),E
; 1758				}
; 1759			}
; 1760		}
L_101:
.LINE 1760

; 1761		dp->dptr = ofs;						/* Current entry */
.LINE 1761

	LD	BC,(IX+%FFFFFFF5)
	LD	A,(IX+%FFFFFFF8)
	LD	IY,(IX+%6)
	LD	(IY+%F),BC
	LD	(IY+%12),A
; 1762		dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
.LINE 1762

	LD	BC,(IX+%FFFFFFED)
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%2E
	ADD	HL,BC
	LD	IY,(IX+%6)
	LD	(IY+%1B),HL
; 1763	
; 1764		return FR_OK;
.LINE 1764

	OR	A,A
	SBC	HL,HL
; 1765	}
L_102:
.LINE 1765

	LD	SP,IX
	POP	IX
	RET	


;**************************** _dir_next ***************************
;Name                         Addr/Register   Size   Type
;G_1                                  IX-23      4   variable
;G_2                                  IX-19      4   variable
;G_0                                  IX-15      4   variable
;ofs                                  IX-11      4   variable
;clst                                  IX-7      4   variable
;fs                                    IX-3      3   variable
;stretch                               IX+9      3   parameter
;dp                                    IX+6      3   parameter


; Stack Frame Size: 43 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "dir_next",1765,"_dir_next"
; 1766	
; 1767	
; 1768	
; 1769	
; 1770	#if !FF_FS_READONLY
; 1771	/*-----------------------------------------------------------------------*/
; 1772	/* Directory handling - Reserve a block of directory entries             */
; 1773	/*-----------------------------------------------------------------------*/
; 1774	
; 1775	static FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
; 1776		DIR* dp,				/* Pointer to the directory object */
; 1777		UINT n_ent				/* Number of contiguous entries to allocate */
; 1778	)
; 1779	{
; 1780		FRESULT res;
; 1781		UINT n;
; 1782		FATFS *fs = dp->obj.fs;
; 1783	
; 1784	
; 1785		res = dir_sdi(dp, 0);
; 1786		if (res == FR_OK) {
; 1787			n = 0;
; 1788			do {
; 1789				res = move_window(fs, dp->sect);
; 1790				if (res != FR_OK) break;
; 1791	#if FF_FS_EXFAT
; 1792				if ((fs->fs_type == FS_EXFAT) ? (int)((dp->dir[XDIR_Type] & 0x80) == 0) : (int)(dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0)) {	/* Is the entry free? */
; 1793	#else
; 1794				if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {	/* Is the entry free? */
; 1795	#endif
; 1796					if (++n == n_ent) break;	/* Is a block of contiguous free entries found? */
; 1797				} else {
; 1798					n = 0;				/* Not a free entry, restart to search */
; 1799				}
; 1800				res = dir_next(dp, 1);	/* Next entry with table stretch enabled */
; 1801			} while (res == FR_OK);
; 1802		}
; 1803	
; 1804		if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
; 1805		return res;
; 1806	}
; 1807	
; 1808	#endif	/* !FF_FS_READONLY */
; 1809	
; 1810	
; 1811	
; 1812	
; 1813	/*-----------------------------------------------------------------------*/
; 1814	/* FAT: Directory handling - Load/Store start cluster number             */
; 1815	/*-----------------------------------------------------------------------*/
; 1816	
; 1817	static DWORD ld_clust (	/* Returns the top cluster value of the SFN entry */
; 1818		FATFS* fs,			/* Pointer to the fs object */
; 1819		const BYTE* dir		/* Pointer to the key entry */
; 1820	)
; 1821	{
_ld_clust:
.DEFINE "_ld_clust"

.VALUE _ld_clust

.CLASS 3

.TYPE 79

.ENDEF

.BEGFUNC "ld_clust",1821,"_ld_clust"

.LINE 1821

.DEFINE "fs"

.CLASS 65

.VALUE 6

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "dir"

.CLASS 65

.VALUE 9

.TYPE 204

.ENDEF

.DEFINE "cl"

.CLASS 65

.VALUE -4

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
; 1822		DWORD cl;
; 1823	
; 1824		cl = ld_word(dir + DIR_FstClusLO);
.LINE 1824

	LD	IY,(IX+%9)
	LEA	BC,IY+%1A
	PUSH	BC
	CALL	_ld_word
	POP	BC
	LD	BC,HL
	CALL	__stoiu
	XOR	A,A
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),A
; 1825		if (fs->fs_type == FS_FAT32) {
.LINE 1825

	LD	IY,(IX+%6)
	LD	A,(IY+%0)
	CP	A,%3
	JR	NZ,L_104
; 1826			cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
.LINE 1826

	LD	IY,(IX+%9)
	LEA	BC,IY+%14
	PUSH	BC
	CALL	_ld_word
	POP	BC
	LD	BC,HL
	CALL	__stoiu
	XOR	A,A
	LD	BC,HL
	LD	L,%10
	CALL	__lshl
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+%FFFFFFFC)
	LD	A,(IX+%FFFFFFFF)
	CALL	__lor
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),E
; 1827		}
L_104:
.LINE 1827

; 1828	
; 1829		return cl;
.LINE 1829

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
; 1830	}
.LINE 1830

	LD	SP,IX
	POP	IX
	RET	


;**************************** _ld_clust ***************************
;Name                         Addr/Register   Size   Type
;cl                                    IX-4      4   variable
;dir                                   IX+9      3   parameter
;fs                                    IX+6      3   parameter


; Stack Frame Size: 16 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "ld_clust",1830,"_ld_clust"
; 1831	
; 1832	
; 1833	#if !FF_FS_READONLY
; 1834	static void st_clust (
; 1835		FATFS* fs,	/* Pointer to the fs object */
; 1836		BYTE* dir,	/* Pointer to the key entry */
; 1837		DWORD cl	/* Value to be set */
; 1838	)
; 1839	{
; 1840		st_word(dir + DIR_FstClusLO, (WORD)cl);
; 1841		if (fs->fs_type == FS_FAT32) {
; 1842			st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
; 1843		}
; 1844	}
; 1845	#endif
; 1846	
; 1847	
; 1848	
; 1849	#if FF_USE_LFN
; 1850	/*--------------------------------------------------------*/
; 1851	/* FAT-LFN: Compare a part of file name with an LFN entry */
; 1852	/*--------------------------------------------------------*/
; 1853	
; 1854	static int cmp_lfn (		/* 1:matched, 0:not matched */
; 1855		const WCHAR* lfnbuf,	/* Pointer to the LFN working buffer to be compared */
; 1856		BYTE* dir				/* Pointer to the directory entry containing the part of LFN */
; 1857	)
; 1858	{
_cmp_lfn:
.DEFINE "_cmp_lfn"

.VALUE _cmp_lfn

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "cmp_lfn",1858,"_cmp_lfn"

.LINE 1858

.DEFINE "lfnbuf"

.CLASS 65

.VALUE 6

.TYPE 205

.ENDEF

.DEFINE "dir"

.CLASS 65

.VALUE 9

.TYPE 44

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -3

.TYPE 14

.ENDEF

.DEFINE "s"

.CLASS 65

.VALUE -6

.TYPE 14

.ENDEF

.DEFINE "wc"

.CLASS 65

.VALUE -8

.TYPE 13

.ENDEF

.DEFINE "uc"

.CLASS 65

.VALUE -10

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF2
	LD	SP,HL
; 1859		UINT i, s;
; 1860		WCHAR wc, uc;
; 1861	
; 1862	
; 1863		if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
.LINE 1863

	LD	IY,(IX+%9)
	LEA	BC,IY+%1A
	PUSH	BC
	CALL	_ld_word
	POP	BC
	CALL	__scmpzero
	JR	Z,L_107
	OR	A,A
	SBC	HL,HL
	JR	L_124
L_107:
; 1864	
; 1865		i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
.LINE 1865

	LD	HL,(IX+%9)
	LD	A,(HL)
	AND	A,%3F
	UEXT	HL
	LD	L,A
	DEC	HL
	LD	A,%D
	CALL	__imul_b
	LD	(IX+%FFFFFFFD),HL
; 1866	
; 1867		for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
.LINE 1867

	LD	(IX+%FFFFFFF8),%1
	LD	(IX+%FFFFFFF9),%0
	LD	BC,0
	LD	(IX+%FFFFFFFA),BC
	JR	L_118
L_116:
; 1868			uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
.LINE 1868

	LD	BC,_LfnOfs
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+%9)
	ADD	HL,BC
	PUSH	HL
	CALL	_ld_word
	POP	BC
	LD	(IX+%FFFFFFF6),L
	LD	(IX+%FFFFFFF7),H
; 1869			if (wc != 0) {
.LINE 1869

	LD	HL,(IX+%FFFFFFF8)
	CALL	__scmpzero
	JR	Z,L_115
; 1870				if (i >= FF_MAX_LFN + 1 || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
.LINE 1870

	LD	BC,256
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_111
	LD	HL,(IX+%FFFFFFFD)
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	ADD	HL,HL
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	C,%0
	LD	B,%0
	PUSH	BC
	PUSH	HL
	CALL	_ff_wtoupper
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFF5),E
	LD	(IX+%FFFFFFF2),HL
	LD	BC,(IX+%FFFFFFF6)
	CALL	__stoiu
	LD	C,%0
	LD	B,%0
	PUSH	BC
	PUSH	HL
	CALL	_ff_wtoupper
	POP	BC
	POP	BC
	LD	A,E
	LD	BC,HL
	LD	E,(IX+%FFFFFFF5)
	LD	HL,(IX+%FFFFFFF2)
	CALL	__lcmpu
	JR	Z,L_112
L_111:
; 1871					return 0;					/* Not matched */
.LINE 1871

	OR	A,A
	SBC	HL,HL
	JR	L_124
; 1872				}
L_112:
.LINE 1872

; 1873				wc = uc;
.LINE 1873

	LD	BC,(IX+%FFFFFFF6)
	LD	(IX+%FFFFFFF8),C
	LD	(IX+%FFFFFFF9),B
; 1874			} else {
.LINE 1874

	JR	L_117
L_115:
; 1875				if (uc != 0xFFFF) return 0;		/* Check filler */
.LINE 1875

	LD.LIS	BC,65535
	LD	HL,(IX+%FFFFFFF6)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_117
	OR	A,A
	SBC	HL,HL
	JR	L_124
; 1876			}
; 1877		}
L_117:
.LINE 1877

	LD	BC,(IX+%FFFFFFFA)
	INC	BC
	LD	(IX+%FFFFFFFA),BC
L_118:
	LD	BC,13
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	C,L_116
; 1878	
; 1879		if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i]) return 0;	/* Last segment matched but different length */
.LINE 1879

	LD	HL,(IX+%9)
	LD	A,(HL)
	AND	A,%40
	JR	Z,L_123
	LD	HL,(IX+%FFFFFFF8)
	CALL	__scmpzero
	JR	Z,L_123
	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	HL,(HL)
	CALL	__scmpzero
	JR	Z,L_123
	OR	A,A
	SBC	HL,HL
	JR	L_124
L_123:
; 1880	
; 1881		return 1;		/* The part of LFN matched */
.LINE 1881

	LD	HL,1
; 1882	}
L_124:
.LINE 1882

	LD	SP,IX
	POP	IX
	RET	


;**************************** _cmp_lfn ***************************
;Name                         Addr/Register   Size   Type
;_ff_wtoupper                        IMPORT  -----   function
;_LfnOfs                             STATIC     13   variable
;uc                                   IX-10      2   variable
;wc                                    IX-8      2   variable
;s                                     IX-6      3   variable
;i                                     IX-3      3   variable
;dir                                   IX+9      3   parameter
;lfnbuf                                IX+6      3   parameter


; Stack Frame Size: 26 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "cmp_lfn",1882,"_cmp_lfn"
; 1883	
; 1884	
; 1885	#if FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2 || FF_USE_LABEL || FF_FS_EXFAT
; 1886	/*-----------------------------------------------------*/
; 1887	/* FAT-LFN: Pick a part of file name from an LFN entry */
; 1888	/*-----------------------------------------------------*/
; 1889	
; 1890	static int pick_lfn (	/* 1:succeeded, 0:buffer overflow or invalid LFN entry */
; 1891		WCHAR* lfnbuf,		/* Pointer to the LFN working buffer */
; 1892		BYTE* dir			/* Pointer to the LFN entry */
; 1893	)
; 1894	{
_pick_lfn:
.DEFINE "_pick_lfn"

.VALUE _pick_lfn

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "pick_lfn",1894,"_pick_lfn"

.LINE 1894

.DEFINE "lfnbuf"

.CLASS 65

.VALUE 6

.TYPE 45

.ENDEF

.DEFINE "dir"

.CLASS 65

.VALUE 9

.TYPE 44

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -3

.TYPE 14

.ENDEF

.DEFINE "s"

.CLASS 65

.VALUE -6

.TYPE 14

.ENDEF

.DEFINE "wc"

.CLASS 65

.VALUE -8

.TYPE 13

.ENDEF

.DEFINE "uc"

.CLASS 65

.VALUE -10

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	PUSH	BC
	DEC	SP
; 1895		UINT i, s;
; 1896		WCHAR wc, uc;
; 1897	
; 1898	
; 1899		if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO is 0 */
.LINE 1899

	LD	IY,(IX+%9)
	LEA	BC,IY+%1A
	PUSH	BC
	CALL	_ld_word
	POP	BC
	CALL	__scmpzero
	JR	Z,L_126
	OR	A,A
	SBC	HL,HL
	JR	L_143
L_126:
; 1900	
; 1901		i = ((dir[LDIR_Ord] & ~LLEF) - 1) * 13;	/* Offset in the LFN buffer */
.LINE 1901

	LD	HL,(IX+%9)
	LD	A,(HL)
	RES	%6,A
	UEXT	HL
	LD	L,A
	DEC	HL
	LD	A,%D
	CALL	__imul_b
	LD	(IX+%FFFFFFFD),HL
; 1902	
; 1903		for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
.LINE 1903

	LD	(IX+%FFFFFFF8),%1
	LD	(IX+%FFFFFFF9),%0
	LD	BC,0
	LD	(IX+%FFFFFFFA),BC
	JR	L_136
L_134:
; 1904			uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
.LINE 1904

	LD	BC,_LfnOfs
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+%9)
	ADD	HL,BC
	PUSH	HL
	CALL	_ld_word
	POP	BC
	LD	(IX+%FFFFFFF6),L
	LD	(IX+%FFFFFFF7),H
; 1905			if (wc != 0) {
.LINE 1905

	LD	HL,(IX+%FFFFFFF8)
	CALL	__scmpzero
	JR	Z,L_133
; 1906				if (i >= FF_MAX_LFN + 1) return 0;	/* Buffer overflow? */
.LINE 1906

	LD	BC,256
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	C,L_130
	OR	A,A
	SBC	HL,HL
	JR	L_143
L_130:
; 1907				lfnbuf[i++] = wc = uc;			/* Store it */
.LINE 1907

	LD	BC,(IX+%FFFFFFF6)
	LD	(IX+%FFFFFFF8),C
	LD	(IX+%FFFFFFF9),B
	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	A,(IX+%FFFFFFF6)
	LD	(HL),A
	INC	HL
	LD	A,(IX+%FFFFFFF7)
	LD	(HL),A
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
; 1908			} else {
.LINE 1908

	JR	L_135
L_133:
; 1909				if (uc != 0xFFFF) return 0;		/* Check filler */
.LINE 1909

	LD.LIS	BC,65535
	LD	HL,(IX+%FFFFFFF6)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_135
	OR	A,A
	SBC	HL,HL
	JR	L_143
; 1910			}
; 1911		}
L_135:
.LINE 1911

	LD	BC,(IX+%FFFFFFFA)
	INC	BC
	LD	(IX+%FFFFFFFA),BC
L_136:
	LD	BC,13
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	C,L_134
; 1912	
; 1913		if (dir[LDIR_Ord] & LLEF && wc != 0) {	/* Put terminator if it is the last LFN part and not terminated */
.LINE 1913

	LD	HL,(IX+%9)
	LD	A,(HL)
	AND	A,%40
	JR	Z,L_142
	LD	HL,(IX+%FFFFFFF8)
	CALL	__scmpzero
	JR	Z,L_142
; 1914			if (i >= FF_MAX_LFN + 1) return 0;	/* Buffer overflow? */
.LINE 1914

	LD	BC,256
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	C,L_139
	OR	A,A
	SBC	HL,HL
	JR	L_143
L_139:
; 1915			lfnbuf[i] = 0;
.LINE 1915

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	(HL),%0
	INC	HL
	LD	(HL),%0
; 1916		}
L_142:
.LINE 1916

; 1917	
; 1918		return 1;		/* The part of LFN is valid */
.LINE 1918

	LD	HL,1
; 1919	}
L_143:
.LINE 1919

	LD	SP,IX
	POP	IX
	RET	


;**************************** _pick_lfn ***************************
;Name                         Addr/Register   Size   Type
;_LfnOfs                             STATIC     13   variable
;uc                                   IX-10      2   variable
;wc                                    IX-8      2   variable
;s                                     IX-6      3   variable
;i                                     IX-3      3   variable
;dir                                   IX+9      3   parameter
;lfnbuf                                IX+6      3   parameter


; Stack Frame Size: 22 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "pick_lfn",1919,"_pick_lfn"
; 1920	#endif
; 1921	
; 1922	
; 1923	#if !FF_FS_READONLY
; 1924	/*-----------------------------------------*/
; 1925	/* FAT-LFN: Create an entry of LFN entries */
; 1926	/*-----------------------------------------*/
; 1927	
; 1928	static void put_lfn (
; 1929		const WCHAR* lfn,	/* Pointer to the LFN */
; 1930		BYTE* dir,			/* Pointer to the LFN entry to be created */
; 1931		BYTE ord,			/* LFN order (1-20) */
; 1932		BYTE sum			/* Checksum of the corresponding SFN */
; 1933	)
; 1934	{
; 1935		UINT i, s;
; 1936		WCHAR wc;
; 1937	
; 1938	
; 1939		dir[LDIR_Chksum] = sum;			/* Set checksum */
; 1940		dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
; 1941		dir[LDIR_Type] = 0;
; 1942		st_word(dir + LDIR_FstClusLO, 0);
; 1943	
; 1944		i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
; 1945		s = wc = 0;
; 1946		do {
; 1947			if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
; 1948			st_word(dir + LfnOfs[s], wc);		/* Put it */
; 1949			if (wc == 0) wc = 0xFFFF;			/* Padding characters for following items */
; 1950		} while (++s < 13);
; 1951		if (wc == 0xFFFF || !lfn[i]) ord |= LLEF;	/* Last LFN part is the start of LFN sequence */
; 1952		dir[LDIR_Ord] = ord;			/* Set the LFN order */
; 1953	}
; 1954	
; 1955	#endif	/* !FF_FS_READONLY */
; 1956	#endif	/* FF_USE_LFN */
; 1957	
; 1958	
; 1959	
; 1960	#if FF_USE_LFN && !FF_FS_READONLY
; 1961	/*-----------------------------------------------------------------------*/
; 1962	/* FAT-LFN: Create a Numbered SFN                                        */
; 1963	/*-----------------------------------------------------------------------*/
; 1964	
; 1965	static void gen_numname (
; 1966		BYTE* dst,			/* Pointer to the buffer to store numbered SFN */
; 1967		const BYTE* src,	/* Pointer to SFN in directory form */
; 1968		const WCHAR* lfn,	/* Pointer to LFN */
; 1969		UINT seq			/* Sequence number */
; 1970	)
; 1971	{
; 1972		BYTE ns[8], c;
; 1973		UINT i, j;
; 1974		WCHAR wc;
; 1975		DWORD sreg;
; 1976	
; 1977	
; 1978		memcpy(dst, src, 11);	/* Prepare the SFN to be modified */
; 1979	
; 1980		if (seq > 5) {	/* In case of many collisions, generate a hash number instead of sequential number */
; 1981			sreg = seq;
; 1982			while (*lfn) {	/* Create a CRC as hash value */
; 1983				wc = *lfn++;
; 1984				for (i = 0; i < 16; i++) {
; 1985					sreg = (sreg << 1) + (wc & 1);
; 1986					wc >>= 1;
; 1987					if (sreg & 0x10000) sreg ^= 0x11021;
; 1988				}
; 1989			}
; 1990			seq = (UINT)sreg;
; 1991		}
; 1992	
; 1993		/* Make suffix (~ + hexdecimal) */
; 1994		i = 7;
; 1995		do {
; 1996			c = (BYTE)((seq % 16) + '0'); seq /= 16;
; 1997			if (c > '9') c += 7;
; 1998			ns[i--] = c;
; 1999		} while (i && seq);
; 2000		ns[i] = '~';
; 2001	
; 2002		/* Append the suffix to the SFN body */
; 2003		for (j = 0; j < i && dst[j] != ' '; j++) {	/* Find the offset to append */
; 2004			if (dbc_1st(dst[j])) {	/* To avoid DBC break up */
; 2005				if (j == i - 1) break;
; 2006				j++;
; 2007			}
; 2008		}
; 2009		do {	/* Append the suffix */
; 2010			dst[j++] = (i < 8) ? ns[i++] : ' ';
; 2011		} while (j < 8);
; 2012	}
; 2013	#endif	/* FF_USE_LFN && !FF_FS_READONLY */
; 2014	
; 2015	
; 2016	
; 2017	#if FF_USE_LFN
; 2018	/*-----------------------------------------------------------------------*/
; 2019	/* FAT-LFN: Calculate checksum of an SFN entry                           */
; 2020	/*-----------------------------------------------------------------------*/
; 2021	
; 2022	static BYTE sum_sfn (
; 2023		const BYTE* dir		/* Pointer to the SFN entry */
; 2024	)
; 2025	{
_sum_sfn:
.DEFINE "_sum_sfn"

.VALUE _sum_sfn

.CLASS 3

.TYPE 76

.ENDEF

.BEGFUNC "sum_sfn",2025,"_sum_sfn"

.LINE 2025

.DEFINE "dir"

.CLASS 65

.VALUE 6

.TYPE 204

.ENDEF

.DEFINE "sum"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "n"

.CLASS 65

.VALUE -4

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
; 2026		BYTE sum = 0;
.LINE 2026

	LD	(IX+%FFFFFFFF),%0
; 2027		UINT n = 11;
.LINE 2027

	LD	BC,11
	LD	(IX+%FFFFFFFC),BC
; 2028	
; 2029		do {
L_145:
.LINE 2029

; 2030			sum = (sum >> 1) + (sum << 7) + *dir++;
.LINE 2030

	LD	A,(IX+%FFFFFFFF)
	UEXT	HL
	LD	L,A
	LD	A,%1
	CALL	__ishrs_b
	LD	B,%7
	LD	A,(IX+%FFFFFFFF)
	CALL	__bshl
	LD	B,A
	LD	A,L
	ADD	A,B
	LD	HL,(IX+%6)
	ADD	A,(HL)
	LD	(IX+%FFFFFFFF),A
	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
; 2031		} while (--n);
.LINE 2031

	LD	IY,(IX+%FFFFFFFC)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%FFFFFFFC),IY
	LD	HL,(IX+%FFFFFFFC)
	CALL	__icmpzero
	JR	NZ,L_145
; 2032		return sum;
.LINE 2032

	LD	A,(IX+%FFFFFFFF)
; 2033	}
.LINE 2033

	LD	SP,IX
	POP	IX
	RET	


;**************************** _sum_sfn ***************************
;Name                         Addr/Register   Size   Type
;n                                     IX-4      3   variable
;sum                                   IX-1      1   variable
;dir                                   IX+6      3   parameter


; Stack Frame Size: 13 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "sum_sfn",2033,"_sum_sfn"
; 2034	
; 2035	#endif	/* FF_USE_LFN */
; 2036	
; 2037	
; 2038	
; 2039	#if FF_FS_EXFAT
; 2040	/*-----------------------------------------------------------------------*/
; 2041	/* exFAT: Checksum                                                       */
; 2042	/*-----------------------------------------------------------------------*/
; 2043	
; 2044	static WORD xdir_sum (	/* Get checksum of the directoly entry block */
; 2045		const BYTE* dir		/* Directory entry block to be calculated */
; 2046	)
; 2047	{
; 2048		UINT i, szblk;
; 2049		WORD sum;
; 2050	
; 2051	
; 2052		szblk = (dir[XDIR_NumSec] + 1) * SZDIRE;	/* Number of bytes of the entry block */
; 2053		for (i = sum = 0; i < szblk; i++) {
; 2054			if (i == XDIR_SetSum) {	/* Skip 2-byte sum field */
; 2055				i++;
; 2056			} else {
; 2057				sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + dir[i];
; 2058			}
; 2059		}
; 2060		return sum;
; 2061	}
; 2062	
; 2063	
; 2064	
; 2065	static WORD xname_sum (	/* Get check sum (to be used as hash) of the file name */
; 2066		const WCHAR* name	/* File name to be calculated */
; 2067	)
; 2068	{
; 2069		WCHAR chr;
; 2070		WORD sum = 0;
; 2071	
; 2072	
; 2073		while ((chr = *name++) != 0) {
; 2074			chr = (WCHAR)ff_wtoupper(chr);		/* File name needs to be up-case converted */
; 2075			sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr & 0xFF);
; 2076			sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr >> 8);
; 2077		}
; 2078		return sum;
; 2079	}
; 2080	
; 2081	
; 2082	#if !FF_FS_READONLY && FF_USE_MKFS
; 2083	static DWORD xsum32 (	/* Returns 32-bit checksum */
; 2084		BYTE  dat,			/* Byte to be calculated (byte-by-byte processing) */
; 2085		DWORD sum			/* Previous sum value */
; 2086	)
; 2087	{
; 2088		sum = ((sum & 1) ? 0x80000000 : 0) + (sum >> 1) + dat;
; 2089		return sum;
; 2090	}
; 2091	#endif
; 2092	
; 2093	
; 2094	
; 2095	/*-----------------------------------*/
; 2096	/* exFAT: Get a directry entry block */
; 2097	/*-----------------------------------*/
; 2098	
; 2099	static FRESULT load_xdir (	/* FR_INT_ERR: invalid entry block */
; 2100		DIR* dp					/* Reading direcotry object pointing top of the entry block to load */
; 2101	)
; 2102	{
; 2103		FRESULT res;
; 2104		UINT i, sz_ent;
; 2105		BYTE *dirb = dp->obj.fs->dirbuf;	/* Pointer to the on-memory direcotry entry block 85+C0+C1s */
; 2106	
; 2107	
; 2108		/* Load file directory entry */
; 2109		res = move_window(dp->obj.fs, dp->sect);
; 2110		if (res != FR_OK) return res;
; 2111		if (dp->dir[XDIR_Type] != ET_FILEDIR) return FR_INT_ERR;	/* Invalid order */
; 2112		memcpy(dirb + 0 * SZDIRE, dp->dir, SZDIRE);
; 2113		sz_ent = (dirb[XDIR_NumSec] + 1) * SZDIRE;
; 2114		if (sz_ent < 3 * SZDIRE || sz_ent > 19 * SZDIRE) return FR_INT_ERR;
; 2115	
; 2116		/* Load stream extension entry */
; 2117		res = dir_next(dp, 0);
; 2118		if (res == FR_NO_FILE) res = FR_INT_ERR;	/* It cannot be */
; 2119		if (res != FR_OK) return res;
; 2120		res = move_window(dp->obj.fs, dp->sect);
; 2121		if (res != FR_OK) return res;
; 2122		if (dp->dir[XDIR_Type] != ET_STREAM) return FR_INT_ERR;	/* Invalid order */
; 2123		memcpy(dirb + 1 * SZDIRE, dp->dir, SZDIRE);
; 2124		if (MAXDIRB(dirb[XDIR_NumName]) > sz_ent) return FR_INT_ERR;
; 2125	
; 2126		/* Load file name entries */
; 2127		i = 2 * SZDIRE;	/* Name offset to load */
; 2128		do {
; 2129			res = dir_next(dp, 0);
; 2130			if (res == FR_NO_FILE) res = FR_INT_ERR;	/* It cannot be */
; 2131			if (res != FR_OK) return res;
; 2132			res = move_window(dp->obj.fs, dp->sect);
; 2133			if (res != FR_OK) return res;
; 2134			if (dp->dir[XDIR_Type] != ET_FILENAME) return FR_INT_ERR;	/* Invalid order */
; 2135			if (i < MAXDIRB(FF_MAX_LFN)) memcpy(dirb + i, dp->dir, SZDIRE);
; 2136		} while ((i += SZDIRE) < sz_ent);
; 2137	
; 2138		/* Sanity check (do it for only accessible object) */
; 2139		if (i <= MAXDIRB(FF_MAX_LFN)) {
; 2140			if (xdir_sum(dirb) != ld_word(dirb + XDIR_SetSum)) return FR_INT_ERR;
; 2141		}
; 2142		return FR_OK;
; 2143	}
; 2144	
; 2145	
; 2146	/*------------------------------------------------------------------*/
; 2147	/* exFAT: Initialize object allocation info with loaded entry block */
; 2148	/*------------------------------------------------------------------*/
; 2149	
; 2150	static void init_alloc_info (
; 2151		FATFS* fs,		/* Filesystem object */
; 2152		FFOBJID* obj	/* Object allocation information to be initialized */
; 2153	)
; 2154	{
; 2155		obj->sclust = ld_dword(fs->dirbuf + XDIR_FstClus);		/* Start cluster */
; 2156		obj->objsize = ld_qword(fs->dirbuf + XDIR_FileSize);	/* Size */
; 2157		obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;				/* Allocation status */
; 2158		obj->n_frag = 0;										/* No last fragment info */
; 2159	}
; 2160	
; 2161	
; 2162	
; 2163	#if !FF_FS_READONLY || FF_FS_RPATH != 0
; 2164	/*------------------------------------------------*/
; 2165	/* exFAT: Load the object's directory entry block */
; 2166	/*------------------------------------------------*/
; 2167	
; 2168	static FRESULT load_obj_xdir (
; 2169		DIR* dp,			/* Blank directory object to be used to access containing direcotry */
; 2170		const FFOBJID* obj	/* Object with its containing directory information */
; 2171	)
; 2172	{
; 2173		FRESULT res;
; 2174	
; 2175		/* Open object containing directory */
; 2176		dp->obj.fs = obj->fs;
; 2177		dp->obj.sclust = obj->c_scl;
; 2178		dp->obj.stat = (BYTE)obj->c_size;
; 2179		dp->obj.objsize = obj->c_size & 0xFFFFFF00;
; 2180		dp->obj.n_frag = 0;
; 2181		dp->blk_ofs = obj->c_ofs;
; 2182	
; 2183		res = dir_sdi(dp, dp->blk_ofs);	/* Goto object's entry block */
; 2184		if (res == FR_OK) {
; 2185			res = load_xdir(dp);		/* Load the object's entry block */
; 2186		}
; 2187		return res;
; 2188	}
; 2189	#endif
; 2190	
; 2191	
; 2192	#if !FF_FS_READONLY
; 2193	/*----------------------------------------*/
; 2194	/* exFAT: Store the directory entry block */
; 2195	/*----------------------------------------*/
; 2196	
; 2197	static FRESULT store_xdir (
; 2198		DIR* dp				/* Pointer to the direcotry object */
; 2199	)
; 2200	{
; 2201		FRESULT res;
; 2202		UINT nent;
; 2203		BYTE *dirb = dp->obj.fs->dirbuf;	/* Pointer to the direcotry entry block 85+C0+C1s */
; 2204	
; 2205		/* Create set sum */
; 2206		st_word(dirb + XDIR_SetSum, xdir_sum(dirb));
; 2207		nent = dirb[XDIR_NumSec] + 1;
; 2208	
; 2209		/* Store the direcotry entry block to the directory */
; 2210		res = dir_sdi(dp, dp->blk_ofs);
; 2211		while (res == FR_OK) {
; 2212			res = move_window(dp->obj.fs, dp->sect);
; 2213			if (res != FR_OK) break;
; 2214			memcpy(dp->dir, dirb, SZDIRE);
; 2215			dp->obj.fs->wflag = 1;
; 2216			if (--nent == 0) break;
; 2217			dirb += SZDIRE;
; 2218			res = dir_next(dp, 0);
; 2219		}
; 2220		return (res == FR_OK || res == FR_DISK_ERR) ? res : FR_INT_ERR;
; 2221	}
; 2222	
; 2223	
; 2224	
; 2225	/*-------------------------------------------*/
; 2226	/* exFAT: Create a new directory enrty block */
; 2227	/*-------------------------------------------*/
; 2228	
; 2229	static void create_xdir (
; 2230		BYTE* dirb,			/* Pointer to the direcotry entry block buffer */
; 2231		const WCHAR* lfn	/* Pointer to the object name */
; 2232	)
; 2233	{
; 2234		UINT i;
; 2235		BYTE nc1, nlen;
; 2236		WCHAR wc;
; 2237	
; 2238	
; 2239		/* Create file-directory and stream-extension entry */
; 2240		memset(dirb, 0, 2 * SZDIRE);
; 2241		dirb[0 * SZDIRE + XDIR_Type] = ET_FILEDIR;
; 2242		dirb[1 * SZDIRE + XDIR_Type] = ET_STREAM;
; 2243	
; 2244		/* Create file-name entries */
; 2245		i = SZDIRE * 2;	/* Top of file_name entries */
; 2246		nlen = nc1 = 0; wc = 1;
; 2247		do {
; 2248			dirb[i++] = ET_FILENAME; dirb[i++] = 0;
; 2249			do {	/* Fill name field */
; 2250				if (wc != 0 && (wc = lfn[nlen]) != 0) nlen++;	/* Get a character if exist */
; 2251				st_word(dirb + i, wc); 	/* Store it */
; 2252				i += 2;
; 2253			} while (i % SZDIRE != 0);
; 2254			nc1++;
; 2255		} while (lfn[nlen]);	/* Fill next entry if any char follows */
; 2256	
; 2257		dirb[XDIR_NumName] = nlen;		/* Set name length */
; 2258		dirb[XDIR_NumSec] = 1 + nc1;	/* Set secondary count (C0 + C1s) */
; 2259		st_word(dirb + XDIR_NameHash, xname_sum(lfn));	/* Set name hash */
; 2260	}
; 2261	
; 2262	#endif	/* !FF_FS_READONLY */
; 2263	#endif	/* FF_FS_EXFAT */
; 2264	
; 2265	
; 2266	
; 2267	#if FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2 || FF_USE_LABEL || FF_FS_EXFAT
; 2268	/*-----------------------------------------------------------------------*/
; 2269	/* Read an object from the directory                                     */
; 2270	/*-----------------------------------------------------------------------*/
; 2271	
; 2272	#define DIR_READ_FILE(dp) dir_read(dp, 0)
; 2273	#define DIR_READ_LABEL(dp) dir_read(dp, 1)
; 2274	
; 2275	static FRESULT dir_read (
; 2276		DIR* dp,		/* Pointer to the directory object */
; 2277		int vol			/* Filtered by 0:file/directory or 1:volume label */
; 2278	)
; 2279	{
_dir_read:
.DEFINE "_dir_read"

.VALUE _dir_read

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "dir_read",2279,"_dir_read"

.LINE 2279

.DEFINE "dp"

.CLASS 65

.VALUE 6

.TAG "NONAME3"

.TYPE 40

.ENDEF

.DEFINE "vol"

.CLASS 65

.VALUE 9

.TYPE 4

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "ord"

.CLASS 65

.VALUE -2

.TYPE 12

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -5

.TYPE 4

.ENDEF

.DEFINE "attr"

.CLASS 65

.VALUE -6

.TYPE 12

.ENDEF

.DEFINE "sum"

.CLASS 65

.VALUE -7

.TYPE 12

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -10

.TAG "NONAME0"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFE9
	LD	SP,HL
; 2280		FRESULT res = FR_NO_FILE;
.LINE 2280

	LD	BC,4
	LD	(IX+%FFFFFFFB),BC
; 2281		FATFS *fs = dp->obj.fs;
.LINE 2281

	LD	IY,(IX+%6)
	LD	BC,(IY+%0)
	LD	(IX+%FFFFFFF6),BC
; 2282		BYTE attr, b;
; 2283	#if FF_USE_LFN
; 2284		BYTE ord = 0xFF, sum = 0xFF;
.LINE 2284

	LD	(IX+%FFFFFFFE),%FF
	LD	(IX+%FFFFFFF9),%FF
; 2285	#endif
; 2286	
; 2287		while (dp->sect) {
.LINE 2287

	JR	L_172
L_173:
; 2288			res = move_window(fs, dp->sect);
.LINE 2288

	LD	C,(IX+%FFFFFFEC)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFE9)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF6)
	PUSH	BC
	CALL	_move_window
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFB),HL
; 2289			if (res != FR_OK) break;
.LINE 2289

	CALL	__icmpzero
	JR	NZ,L_175
; 2290			b = dp->dir[DIR_Name];	/* Test for the entry type */
.LINE 2290

	LD	IY,(IX+%6)
	LD	BC,(IY+%1B)
	LD	(IX+%FFFFFFF0),BC
	LD	HL,BC
	LD	A,(HL)
	LD	(IX+%FFFFFFFF),A
; 2291			if (b == 0) {
.LINE 2291

	OR	A,A
	JR	NZ,L_169
; 2292				res = FR_NO_FILE; break; /* Reached to end of the directory */
.LINE 2292

	LD	BC,4
	LD	(IX+%FFFFFFFB),BC
	JR	L_175
; 2293			}
L_169:
.LINE 2293

; 2294	#if FF_FS_EXFAT
; 2295			if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
; 2296				if (FF_USE_LABEL && vol) {
; 2297					if (b == ET_VLABEL) break;	/* Volume label entry? */
; 2298				} else {
; 2299					if (b == ET_FILEDIR) {		/* Start of the file entry block? */
; 2300						dp->blk_ofs = dp->dptr;	/* Get location of the block */
; 2301						res = load_xdir(dp);	/* Load the entry block */
; 2302						if (res == FR_OK) {
; 2303							dp->obj.attr = fs->dirbuf[XDIR_Attr] & AM_MASK;	/* Get attribute */
; 2304						}
; 2305						break;
; 2306					}
; 2307				}
; 2308			} else
; 2309	#endif
; 2310			{	/* On the FAT/FAT32 volume */
; 2311				dp->obj.attr = attr = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
.LINE 2311

	LD	IY,(IX+%FFFFFFF0)
	LD	A,(IY+%B)
	AND	A,%3F
	LD	(IX+%FFFFFFFA),A
	LD	IY,(IX+%6)
	LD	(IY+%5),A
; 2312	#if FF_USE_LFN		/* LFN configuration */
; 2313				if (b == DDEM || b == '.' || (int)((attr & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
.LINE 2313

	LD	A,(IX+%FFFFFFFF)
	CP	A,%E5
	JR	Z,L_167
	LD	A,(IX+%FFFFFFFF)
	CP	A,%2E
	JR	Z,L_167
	LD	A,(IX+%FFFFFFFA)
	RES	%5,A
	CP	A,%8
	JR	NZ,L__81
	LD	B,%1
	JR	L__82
L__81:
	LD	B,%0
L__82:
	LD	A,B
	SEXT	HL
	LD	L,B
	LD	BC,(IX+%9)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_168
L_167:
; 2314					ord = 0xFF;
.LINE 2314

	LD	(IX+%FFFFFFFE),%FF
; 2315				} else {
.LINE 2315

	JR	L_170
L_168:
; 2316					if (attr == AM_LFN) {	/* An LFN entry is found */
.LINE 2316

	LD	A,(IX+%FFFFFFFA)
	CP	A,%F
	JR	NZ,L_166
; 2317						if (b & LLEF) {		/* Is it start of an LFN sequence? */
.LINE 2317

	LD	A,(IX+%FFFFFFFF)
	AND	A,%40
	JR	Z,L_161
; 2318							sum = dp->dir[LDIR_Chksum];
.LINE 2318

	LD	IY,(IX+%6)
	LD	IY,(IY+%1B)
	LD	A,(IY+%D)
	LD	(IX+%FFFFFFF9),A
; 2319							b &= (BYTE)~LLEF; ord = b;
.LINE 2319

	LD	A,(IX+%FFFFFFFF)
	RES	%6,A
	LD	(IX+%FFFFFFFF),A
	LD	(IX+%FFFFFFFE),A
; 2320							dp->blk_ofs = dp->dptr;
.LINE 2320

	LD	IY,(IX+%6)
	LD	BC,(IY+%F)
	LD	A,(IY+%12)
	LD	(IY+%2A),BC
	LD	(IY+%2D),A
; 2321						}
L_161:
.LINE 2321

; 2322						/* Check LFN validity and capture it */
; 2323						ord = (b == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
.LINE 2323

	LD	A,(IX+%FFFFFFFF)
	CP	A,(IX+%FFFFFFFE)
	JR	NZ,L_159
	LD	IY,(IX+%6)
	LD	BC,(IY+%1B)
	LD	(IX+%FFFFFFED),BC
	LD	IY,(IX+%FFFFFFED)
	LD	A,(IY+%D)
	CP	A,(IX+%FFFFFFF9)
	JR	NZ,L_159
	LD	BC,(IX+%FFFFFFED)
	PUSH	BC
	LD	IY,(IX+%FFFFFFF6)
	LD	BC,(IY+%B)
	PUSH	BC
	CALL	_pick_lfn
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	Z,L_159
	LD	A,(IX+%FFFFFFFE)
	UEXT	HL
	LD	L,A
	DEC	HL
	LD	(IX+%FFFFFFF3),HL
	JR	L_160
L_159:
	LD	BC,255
	LD	(IX+%FFFFFFF3),BC
L_160:
	LD	A,(IX+%FFFFFFF3)
	LD	(IX+%FFFFFFFE),A
; 2324					} else {				/* An SFN entry is found */
.LINE 2324

	JR	L_170
L_166:
; 2325						if (ord != 0 || sum != sum_sfn(dp->dir)) {	/* Is there a valid LFN? */
.LINE 2325

	LD	A,(IX+%FFFFFFFE)
	OR	A,A
	JR	NZ,L_163
	LD	IY,(IX+%6)
	LD	BC,(IY+%1B)
	PUSH	BC
	CALL	_sum_sfn
	POP	BC
	CP	A,(IX+%FFFFFFF9)
	JR	Z,L_175
L_163:
; 2326							dp->blk_ofs = 0xFFFFFFFF;	/* It has no LFN. */
.LINE 2326

	LD	BC,16777215
	LD	IY,(IX+%6)
	LD	(IY+%2A),BC
	LD	(IY+%2D),%FF
; 2327						}
.LINE 2327

; 2328						break;
.LINE 2328

	JR	L_175
; 2329					}
; 2330				}
; 2331	#else		/* Non LFN configuration */
; 2332				if (b != DDEM && b != '.' && attr != AM_LFN && (int)((attr & ~AM_ARC) == AM_VOL) == vol) {	/* Is it a valid entry? */
; 2333					break;
; 2334				}
; 2335	#endif
; 2336			}
L_170:
.LINE 2336

; 2337			res = dir_next(dp, 0);		/* Next entry */
.LINE 2337

	LD	BC,0
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_dir_next
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFB),HL
; 2338			if (res != FR_OK) break;
.LINE 2338

	CALL	__icmpzero
	JR	NZ,L_175
; 2339		}
L_172:
.LINE 2339

	LD	IY,(IX+%6)
	LD	BC,(IY+%17)
	LD	A,(IY+%1A)
	LD	(IX+%FFFFFFE9),BC
	LD	(IX+%FFFFFFEC),A
	LD	HL,BC
	LD	E,(IX+%FFFFFFEC)
	CALL	__lcmpzero
	JR	NZ,L_173
L_175:
; 2340	
; 2341		if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
.LINE 2341

	LD	HL,(IX+%FFFFFFFB)
	CALL	__icmpzero
	JR	Z,L_176
	LD	BC,0
	LD	IY,(IX+%6)
	LD	(IY+%17),BC
	LD	(IY+%1A),%0
L_176:
; 2342		return res;
.LINE 2342

	LD	HL,(IX+%FFFFFFFB)
; 2343	}
.LINE 2343

	LD	SP,IX
	POP	IX
	RET	


;**************************** _dir_read ***************************
;Name                         Addr/Register   Size   Type
;G_3                                  IX-23      4   variable
;G_5                                  IX-19      3   variable
;G_4                                  IX-16      3   variable
;temp157                              IX-13      3   variable
;fs                                   IX-10      3   variable
;sum                                   IX-7      1   variable
;attr                                  IX-6      1   variable
;res                                   IX-5      3   variable
;ord                                   IX-2      1   variable
;b                                     IX-1      1   variable
;vol                                   IX+9      3   parameter
;dp                                    IX+6      3   parameter


; Stack Frame Size: 35 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "dir_read",2343,"_dir_read"
; 2344	
; 2345	#endif	/* FF_FS_MINIMIZE <= 1 || FF_USE_LABEL || FF_FS_RPATH >= 2 */
; 2346	
; 2347	
; 2348	
; 2349	/*-----------------------------------------------------------------------*/
; 2350	/* Directory handling - Find an object in the directory                  */
; 2351	/*-----------------------------------------------------------------------*/
; 2352	
; 2353	static FRESULT dir_find (	/* FR_OK(0):succeeded, !=0:error */
; 2354		DIR* dp					/* Pointer to the directory object with the file name */
; 2355	)
; 2356	{
_dir_find:
.DEFINE "_dir_find"

.VALUE _dir_find

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "dir_find",2356,"_dir_find"

.LINE 2356

.DEFINE "dp"

.CLASS 65

.VALUE 6

.TAG "NONAME3"

.TYPE 40

.ENDEF

.DEFINE "c"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "ord"

.CLASS 65

.VALUE -2

.TYPE 12

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -5

.TYPE 4

.ENDEF

.DEFINE "a"

.CLASS 65

.VALUE -6

.TYPE 12

.ENDEF

.DEFINE "sum"

.CLASS 65

.VALUE -7

.TYPE 12

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -10

.TAG "NONAME0"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFEA
	LD	SP,HL
; 2357		FRESULT res;
; 2358		FATFS *fs = dp->obj.fs;
.LINE 2358

	LD	IY,(IX+%6)
	LD	BC,(IY+%0)
	LD	(IX+%FFFFFFF6),BC
; 2359		BYTE c;
; 2360	#if FF_USE_LFN
; 2361		BYTE a, ord, sum;
; 2362	#endif
; 2363	
; 2364		res = dir_sdi(dp, 0);			/* Rewind directory object */
.LINE 2364

	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_dir_sdi
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFB),HL
; 2365		if (res != FR_OK) return res;
.LINE 2365

	CALL	__icmpzero
	JR	Z,L_179
	LD	HL,(IX+%FFFFFFFB)
	JR	L_209
L_179:
; 2366	#if FF_FS_EXFAT
; 2367		if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
; 2368			BYTE nc;
; 2369			UINT di, ni;
; 2370			WORD hash = xname_sum(fs->lfnbuf);		/* Hash value of the name to find */
; 2371	
; 2372			while ((res = DIR_READ_FILE(dp)) == FR_OK) {	/* Read an item */
; 2373	#if FF_MAX_LFN < 255
; 2374				if (fs->dirbuf[XDIR_NumName] > FF_MAX_LFN) continue;		/* Skip comparison if inaccessible object name */
; 2375	#endif
; 2376				if (ld_word(fs->dirbuf + XDIR_NameHash) != hash) continue;	/* Skip comparison if hash mismatched */
; 2377				for (nc = fs->dirbuf[XDIR_NumName], di = SZDIRE * 2, ni = 0; nc; nc--, di += 2, ni++) {	/* Compare the name */
; 2378					if ((di % SZDIRE) == 0) di += 2;
; 2379					if (ff_wtoupper(ld_word(fs->dirbuf + di)) != ff_wtoupper(fs->lfnbuf[ni])) break;
; 2380				}
; 2381				if (nc == 0 && !fs->lfnbuf[ni]) break;	/* Name matched? */
; 2382			}
; 2383			return res;
; 2384		}
; 2385	#endif
; 2386		/* On the FAT/FAT32 volume */
; 2387	#if FF_USE_LFN
; 2388		ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
.LINE 2388

	LD	(IX+%FFFFFFF9),%FF
	LD	(IX+%FFFFFFFE),%FF
	LD	BC,16777215
	LD	IY,(IX+%6)
	LD	(IY+%2A),BC
	LD	(IY+%2D),%FF
; 2389	#endif
; 2390		do {
L_206:
.LINE 2390

; 2391			res = move_window(fs, dp->sect);
.LINE 2391

	LD	IY,(IX+%6)
	LD	BC,(IY+%17)
	LD	A,(IY+%1A)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	LD	BC,(IX+%FFFFFFF6)
	PUSH	BC
	CALL	_move_window
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFB),HL
; 2392			if (res != FR_OK) break;
.LINE 2392

	CALL	__icmpzero
	JR	NZ,L_208
; 2393			c = dp->dir[DIR_Name];
.LINE 2393

	LD	IY,(IX+%6)
	LD	BC,(IY+%1B)
	LD	(IX+%FFFFFFF0),BC
	LD	HL,BC
	LD	A,(HL)
	LD	(IX+%FFFFFFFF),A
; 2394			if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
.LINE 2394

	OR	A,A
	JR	NZ,L_183
	LD	BC,4
	LD	(IX+%FFFFFFFB),BC
	JR	L_208
L_183:
; 2395	#if FF_USE_LFN		/* LFN configuration */
; 2396			dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
.LINE 2396

	LD	IY,(IX+%FFFFFFF0)
	LD	A,(IY+%B)
	AND	A,%3F
	LD	(IX+%FFFFFFFA),A
	LD	IY,(IX+%6)
	LD	(IY+%5),A
; 2397			if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
.LINE 2397

	LD	A,(IX+%FFFFFFFF)
	CP	A,%E5
	JR	Z,L_203
	LD	A,(IX+%FFFFFFFA)
	AND	A,%8
	JR	Z,L_204
	LD	A,(IX+%FFFFFFFA)
	CP	A,%F
	JR	Z,L_204
L_203:
; 2398				ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
.LINE 2398

	LD	(IX+%FFFFFFFE),%FF
	LD	BC,16777215
	LD	IY,(IX+%6)
	LD	(IY+%2A),BC
	LD	(IY+%2D),%FF
; 2399			} else {
.LINE 2399

	JR	L_205
L_204:
; 2400				if (a == AM_LFN) {			/* An LFN entry is found */
.LINE 2400

	LD	A,(IX+%FFFFFFFA)
	CP	A,%F
	JR	NZ,L_202
; 2401					if (!(dp->fn[NSFLAG] & NS_NOLFN)) {
.LINE 2401

	LD	IY,(IX+%6)
	LD	A,(IY+%29)
	AND	A,%40
	JR	NZ,L_205
; 2402						if (c & LLEF) {		/* Is it start of LFN sequence? */
.LINE 2402

	LD	A,(IX+%FFFFFFFF)
	AND	A,%40
	JR	Z,L_193
; 2403							sum = dp->dir[LDIR_Chksum];
.LINE 2403

	LD	IY,(IX+%6)
	LD	IY,(IY+%1B)
	LD	A,(IY+%D)
	LD	(IX+%FFFFFFF9),A
; 2404							c &= (BYTE)~LLEF; ord = c;	/* LFN start order */
.LINE 2404

	LD	A,(IX+%FFFFFFFF)
	RES	%6,A
	LD	(IX+%FFFFFFFF),A
	LD	(IX+%FFFFFFFE),A
; 2405							dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
.LINE 2405

	LD	IY,(IX+%6)
	LD	BC,(IY+%F)
	LD	A,(IY+%12)
	LD	(IY+%2A),BC
	LD	(IY+%2D),A
; 2406						}
L_193:
.LINE 2406

; 2407						/* Check validity of the LFN entry and compare it with given name */
; 2408						ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
.LINE 2408

	LD	A,(IX+%FFFFFFFF)
	CP	A,(IX+%FFFFFFFE)
	JR	NZ,L_191
	LD	IY,(IX+%6)
	LD	BC,(IY+%1B)
	LD	(IX+%FFFFFFED),BC
	LD	IY,(IX+%FFFFFFED)
	LD	A,(IY+%D)
	CP	A,(IX+%FFFFFFF9)
	JR	NZ,L_191
	LD	BC,(IX+%FFFFFFED)
	PUSH	BC
	LD	IY,(IX+%FFFFFFF6)
	LD	BC,(IY+%B)
	PUSH	BC
	CALL	_cmp_lfn
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	Z,L_191
	LD	A,(IX+%FFFFFFFE)
	UEXT	HL
	LD	L,A
	DEC	HL
	LD	(IX+%FFFFFFF3),HL
	JR	L_192
L_191:
	LD	BC,255
	LD	(IX+%FFFFFFF3),BC
L_192:
	LD	A,(IX+%FFFFFFF3)
	LD	(IX+%FFFFFFFE),A
; 2409					}
; 2410				} else {					/* An SFN entry is found */
.LINE 2410

	JR	L_205
L_202:
; 2411					if (ord == 0 && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
.LINE 2411

	LD	A,(IX+%FFFFFFFE)
	OR	A,A
	JR	NZ,L_199
	LD	IY,(IX+%6)
	LD	BC,(IY+%1B)
	PUSH	BC
	CALL	_sum_sfn
	POP	BC
	CP	A,(IX+%FFFFFFF9)
	JR	Z,L_208
L_199:
; 2412					if (!(dp->fn[NSFLAG] & NS_LOSS) && !memcmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
.LINE 2412

	LD	IY,(IX+%6)
	LEA	BC,IY+%1E
	LD	(IX+%FFFFFFEA),BC
	LD	IY,(IX+%FFFFFFEA)
	LD	A,(IY+%B)
	AND	A,%1
	JR	NZ,L_200
	LD	BC,11
	PUSH	BC
	LD	BC,(IX+%FFFFFFEA)
	PUSH	BC
	LD	IY,(IX+%6)
	LD	BC,(IY+%1B)
	PUSH	BC
	CALL	_memcmp
	POP	BC
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	Z,L_208
L_200:
; 2413					ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
.LINE 2413

	LD	(IX+%FFFFFFFE),%FF
	LD	BC,16777215
	LD	IY,(IX+%6)
	LD	(IY+%2A),BC
	LD	(IY+%2D),%FF
; 2414				}
; 2415			}
L_205:
.LINE 2415

; 2416	#else		/* Non LFN configuration */
; 2417			dp->obj.attr = dp->dir[DIR_Attr] & AM_MASK;
; 2418			if (!(dp->dir[DIR_Attr] & AM_VOL) && !memcmp(dp->dir, dp->fn, 11)) break;	/* Is it a valid entry? */
; 2419	#endif
; 2420			res = dir_next(dp, 0);	/* Next entry */
.LINE 2420

	LD	BC,0
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_dir_next
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFB),HL
; 2421		} while (res == FR_OK);
.LINE 2421

	CALL	__icmpzero
	JR	Z,L_206
L_208:
; 2422	
; 2423		return res;
.LINE 2423

	LD	HL,(IX+%FFFFFFFB)
; 2424	}
L_209:
.LINE 2424

	LD	SP,IX
	POP	IX
	RET	


;**************************** _dir_find ***************************
;Name                         Addr/Register   Size   Type
;_memcmp                             IMPORT  -----   function
;G_8                                  IX-22      3   variable
;G_7                                  IX-19      3   variable
;G_6                                  IX-16      3   variable
;temp189                              IX-13      3   variable
;fs                                   IX-10      3   variable
;sum                                   IX-7      1   variable
;a                                     IX-6      1   variable
;res                                   IX-5      3   variable
;ord                                   IX-2      1   variable
;c                                     IX-1      1   variable
;dp                                    IX+6      3   parameter


; Stack Frame Size: 31 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "dir_find",2424,"_dir_find"
; 2425	
; 2426	
; 2427	
; 2428	
; 2429	#if !FF_FS_READONLY
; 2430	/*-----------------------------------------------------------------------*/
; 2431	/* Register an object to the directory                                   */
; 2432	/*-----------------------------------------------------------------------*/
; 2433	
; 2434	static FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
; 2435		DIR* dp						/* Target directory with object name to be created */
; 2436	)
; 2437	{
; 2438		FRESULT res;
; 2439		FATFS *fs = dp->obj.fs;
; 2440	#if FF_USE_LFN		/* LFN configuration */
; 2441		UINT n, len, n_ent;
; 2442		BYTE sn[12], sum;
; 2443	
; 2444	
; 2445		if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
; 2446		for (len = 0; fs->lfnbuf[len]; len++) ;	/* Get lfn length */
; 2447	
; 2448	#if FF_FS_EXFAT
; 2449		if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
; 2450			n_ent = (len + 14) / 15 + 2;	/* Number of entries to allocate (85+C0+C1s) */
; 2451			res = dir_alloc(dp, n_ent);		/* Allocate directory entries */
; 2452			if (res != FR_OK) return res;
; 2453			dp->blk_ofs = dp->dptr - SZDIRE * (n_ent - 1);	/* Set the allocated entry block offset */
; 2454	
; 2455			if (dp->obj.stat & 4) {			/* Has the directory been stretched by new allocation? */
; 2456				dp->obj.stat &= ~4;
; 2457				res = fill_first_frag(&dp->obj);	/* Fill the first fragment on the FAT if needed */
; 2458				if (res != FR_OK) return res;
; 2459				res = fill_last_frag(&dp->obj, dp->clust, 0xFFFFFFFF);	/* Fill the last fragment on the FAT if needed */
; 2460				if (res != FR_OK) return res;
; 2461				if (dp->obj.sclust != 0) {		/* Is it a sub-directory? */
; 2462					DIR dj;
; 2463	
; 2464					res = load_obj_xdir(&dj, &dp->obj);	/* Load the object status */
; 2465					if (res != FR_OK) return res;
; 2466					dp->obj.objsize += (DWORD)fs->csize * SS(fs);		/* Increase the directory size by cluster size */
; 2467					st_qword(fs->dirbuf + XDIR_FileSize, dp->obj.objsize);
; 2468					st_qword(fs->dirbuf + XDIR_ValidFileSize, dp->obj.objsize);
; 2469					fs->dirbuf[XDIR_GenFlags] = dp->obj.stat | 1;		/* Update the allocation status */
; 2470					res = store_xdir(&dj);				/* Store the object status */
; 2471					if (res != FR_OK) return res;
; 2472				}
; 2473			}
; 2474	
; 2475			create_xdir(fs->dirbuf, fs->lfnbuf);	/* Create on-memory directory block to be written later */
; 2476			return FR_OK;
; 2477		}
; 2478	#endif
; 2479		/* On the FAT/FAT32 volume */
; 2480		memcpy(sn, dp->fn, 12);
; 2481		if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
; 2482			dp->fn[NSFLAG] = NS_NOLFN;		/* Find only SFN */
; 2483			for (n = 1; n < 100; n++) {
; 2484				gen_numname(dp->fn, sn, fs->lfnbuf, n);	/* Generate a numbered name */
; 2485				res = dir_find(dp);				/* Check if the name collides with existing SFN */
; 2486				if (res != FR_OK) break;
; 2487			}
; 2488			if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
; 2489			if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
; 2490			dp->fn[NSFLAG] = sn[NSFLAG];
; 2491		}
; 2492	
; 2493		/* Create an SFN with/without LFNs. */
; 2494		n_ent = (sn[NSFLAG] & NS_LFN) ? (len + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
; 2495		res = dir_alloc(dp, n_ent);		/* Allocate entries */
; 2496		if (res == FR_OK && --n_ent) {	/* Set LFN entry if needed */
; 2497			res = dir_sdi(dp, dp->dptr - n_ent * SZDIRE);
; 2498			if (res == FR_OK) {
; 2499				sum = sum_sfn(dp->fn);	/* Checksum value of the SFN tied to the LFN */
; 2500				do {					/* Store LFN entries in bottom first */
; 2501					res = move_window(fs, dp->sect);
; 2502					if (res != FR_OK) break;
; 2503					put_lfn(fs->lfnbuf, dp->dir, (BYTE)n_ent, sum);
; 2504					fs->wflag = 1;
; 2505					res = dir_next(dp, 0);	/* Next entry */
; 2506				} while (res == FR_OK && --n_ent);
; 2507			}
; 2508		}
; 2509	
; 2510	#else	/* Non LFN configuration */
; 2511		res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
; 2512	
; 2513	#endif
; 2514	
; 2515		/* Set SFN entry */
; 2516		if (res == FR_OK) {
; 2517			res = move_window(fs, dp->sect);
; 2518			if (res == FR_OK) {
; 2519				memset(dp->dir, 0, SZDIRE);	/* Clean the entry */
; 2520				memcpy(dp->dir + DIR_Name, dp->fn, 11);	/* Put SFN */
; 2521	#if FF_USE_LFN
; 2522				dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
; 2523	#endif
; 2524				fs->wflag = 1;
; 2525			}
; 2526		}
; 2527	
; 2528		return res;
; 2529	}
; 2530	
; 2531	#endif /* !FF_FS_READONLY */
; 2532	
; 2533	
; 2534	
; 2535	#if !FF_FS_READONLY && FF_FS_MINIMIZE == 0
; 2536	/*-----------------------------------------------------------------------*/
; 2537	/* Remove an object from the directory                                   */
; 2538	/*-----------------------------------------------------------------------*/
; 2539	
; 2540	static FRESULT dir_remove (	/* FR_OK:Succeeded, FR_DISK_ERR:A disk error */
; 2541		DIR* dp					/* Directory object pointing the entry to be removed */
; 2542	)
; 2543	{
; 2544		FRESULT res;
; 2545		FATFS *fs = dp->obj.fs;
; 2546	#if FF_USE_LFN		/* LFN configuration */
; 2547		DWORD last = dp->dptr;
; 2548	
; 2549		res = (dp->blk_ofs == 0xFFFFFFFF) ? FR_OK : dir_sdi(dp, dp->blk_ofs);	/* Goto top of the entry block if LFN is exist */
; 2550		if (res == FR_OK) {
; 2551			do {
; 2552				res = move_window(fs, dp->sect);
; 2553				if (res != FR_OK) break;
; 2554				if (FF_FS_EXFAT && fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
; 2555					dp->dir[XDIR_Type] &= 0x7F;	/* Clear the entry InUse flag. */
; 2556				} else {										/* On the FAT/FAT32 volume */
; 2557					dp->dir[DIR_Name] = DDEM;	/* Mark the entry 'deleted'. */
; 2558				}
; 2559				fs->wflag = 1;
; 2560				if (dp->dptr >= last) break;	/* If reached last entry then all entries of the object has been deleted. */
; 2561				res = dir_next(dp, 0);	/* Next entry */
; 2562			} while (res == FR_OK);
; 2563			if (res == FR_NO_FILE) res = FR_INT_ERR;
; 2564		}
; 2565	#else			/* Non LFN configuration */
; 2566	
; 2567		res = move_window(fs, dp->sect);
; 2568		if (res == FR_OK) {
; 2569			dp->dir[DIR_Name] = DDEM;	/* Mark the entry 'deleted'.*/
; 2570			fs->wflag = 1;
; 2571		}
; 2572	#endif
; 2573	
; 2574		return res;
; 2575	}
; 2576	
; 2577	#endif /* !FF_FS_READONLY && FF_FS_MINIMIZE == 0 */
; 2578	
; 2579	
; 2580	
; 2581	#if FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2
; 2582	/*-----------------------------------------------------------------------*/
; 2583	/* Get file information from directory entry                             */
; 2584	/*-----------------------------------------------------------------------*/
; 2585	
; 2586	static void get_fileinfo (
; 2587		DIR* dp,			/* Pointer to the directory object */
; 2588		FILINFO* fno		/* Pointer to the file information to be filled */
; 2589	)
; 2590	{
_get_fileinfo:
.DEFINE "_get_fileinfo"

.VALUE _get_fileinfo

.CLASS 3

.TYPE 65

.ENDEF

.BEGFUNC "get_fileinfo",2590,"_get_fileinfo"

.LINE 2590

.DEFINE "dp"

.CLASS 65

.VALUE 6

.TAG "NONAME3"

.TYPE 40

.ENDEF

.DEFINE "fno"

.CLASS 65

.VALUE 9

.TAG "NONAME4"

.TYPE 40

.ENDEF

.DEFINE "di"

.CLASS 65

.VALUE -3

.TYPE 14

.ENDEF

.DEFINE "wc"

.CLASS 65

.VALUE -5

.TYPE 13

.ENDEF

.DEFINE "si"

.CLASS 65

.VALUE -8

.TYPE 14

.ENDEF

.DEFINE "hs"

.CLASS 65

.VALUE -10

.TYPE 13

.ENDEF

.DEFINE "lcf"

.CLASS 65

.VALUE -11

.TYPE 12

.ENDEF

.DEFINE "nw"

.CLASS 65

.VALUE -23

.TYPE 14

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -29

.TAG "NONAME0"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFDF
	LD	SP,HL
; 2591		UINT si, di;
; 2592	#if FF_USE_LFN
; 2593		BYTE lcf;
; 2594		WCHAR wc, hs;
; 2595		FATFS *fs = dp->obj.fs;
.LINE 2595

	LD	IY,(IX+%6)
	LD	BC,(IY+%0)
	LD	(IX+%FFFFFFE3),BC
; 2596		UINT nw;
; 2597	#else
; 2598		TCHAR c;
; 2599	#endif
; 2600	
; 2601	
; 2602		fno->fname[0] = 0;			/* Invaidate file info */
.LINE 2602

	LD	IY,(IX+%9)
	LD	(IY+%16),%0
; 2603		if (dp->sect == 0) return;	/* Exit if read pointer has reached end of directory */
.LINE 2603

	LD	IY,(IX+%6)
	LD	HL,(IY+%17)
	LD	E,(IY+%1A)
	CALL	__lcmpzero
	JR	Z,L_257
; 2604	
; 2605	#if FF_USE_LFN		/* LFN configuration */
; 2606	#if FF_FS_EXFAT
; 2607		if (fs->fs_type == FS_EXFAT) {	/* exFAT volume */
; 2608			UINT nc = 0;
; 2609	
; 2610			si = SZDIRE * 2; di = 0;	/* 1st C1 entry in the entry block */
; 2611			hs = 0;
; 2612			while (nc < fs->dirbuf[XDIR_NumName]) {
; 2613				if (si >= MAXDIRB(FF_MAX_LFN)) { di = 0; break; }	/* Truncated directory block? */
; 2614				if ((si % SZDIRE) == 0) si += 2;		/* Skip entry type field */
; 2615				wc = ld_word(fs->dirbuf + si); si += 2; nc++;	/* Get a character */
; 2616				if (hs == 0 && IsSurrogate(wc)) {		/* Is it a surrogate? */
; 2617					hs = wc; continue;					/* Get low surrogate */
; 2618				}
; 2619				nw = put_utf((DWORD)hs << 16 | wc, &fno->fname[di], FF_LFN_BUF - di);	/* Store it in API encoding */
; 2620				if (nw == 0) { di = 0; break; }			/* Buffer overflow or wrong char? */
; 2621				di += nw;
; 2622				hs = 0;
; 2623			}
; 2624			if (hs != 0) di = 0;					/* Broken surrogate pair? */
; 2625			if (di == 0) fno->fname[di++] = '?';	/* Inaccessible object name? */
; 2626			fno->fname[di] = 0;						/* Terminate the name */
; 2627			fno->altname[0] = 0;					/* exFAT does not support SFN */
; 2628	
; 2629			fno->fattrib = fs->dirbuf[XDIR_Attr] & AM_MASKX;		/* Attribute */
; 2630			fno->fsize = (fno->fattrib & AM_DIR) ? 0 : ld_qword(fs->dirbuf + XDIR_FileSize);	/* Size */
; 2631			fno->ftime = ld_word(fs->dirbuf + XDIR_ModTime + 0);	/* Time */
; 2632			fno->fdate = ld_word(fs->dirbuf + XDIR_ModTime + 2);	/* Date */
; 2633			return;
; 2634		} else
; 2635	#endif
; 2636		{	/* FAT/FAT32 volume */
; 2637			if (dp->blk_ofs != 0xFFFFFFFF) {	/* Get LFN if available */
.LINE 2637

	LD	IY,(IX+%6)
	LD	HL,(IY+%2A)
	LD	E,(IY+%2D)
	LD	BC,16777215
	LD	A,%FF
	CALL	__lcmpu
	JR	Z,L_225
; 2638				si = di = 0;
.LINE 2638

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	LD	(IX+%FFFFFFF8),BC
; 2639				hs = 0;
.LINE 2639

	LD	(IX+%FFFFFFF6),%0
	LD	(IX+%FFFFFFF7),%0
; 2640				while (fs->lfnbuf[si] != 0) {
.LINE 2640

	JR	L_218
L_219:
; 2641					wc = fs->lfnbuf[si++];		/* Get an LFN character (UTF-16) */
.LINE 2641

	LD	HL,(IX+%FFFFFFF8)
	ADD	HL,HL
	LD	BC,(IX+%FFFFFFEF)
	ADD	HL,BC
	LD	BC,(HL)
	LD	(IX+%FFFFFFFB),C
	LD	(IX+%FFFFFFFC),B
	LD	BC,(IX+%FFFFFFF8)
	INC	BC
	LD	(IX+%FFFFFFF8),BC
; 2642					if (hs == 0 && IsSurrogate(wc)) {	/* Is it a surrogate? */
.LINE 2642

	LD	HL,(IX+%FFFFFFF6)
	CALL	__scmpzero
	JR	NZ,L_215
	LD.LIS	BC,55296
	LD	HL,(IX+%FFFFFFFB)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_215
	LD	BC,(IX+%FFFFFFFB)
	LD.LIS	HL,57343
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_215
; 2643						hs = wc; continue;		/* Get low surrogate */
.LINE 2643

	LD	BC,(IX+%FFFFFFFB)
	LD	(IX+%FFFFFFF6),C
	LD	(IX+%FFFFFFF7),B
	JR	L_218
; 2644					}
L_215:
.LINE 2644

; 2645					nw = put_utf((DWORD)hs << 16 | wc, &fno->fname[di], FF_LFN_BUF - di);	/* Store it in API encoding */
.LINE 2645

	LD	HL,255
	LD	BC,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	PUSH	HL
	LD	BC,(IX+%FFFFFFFD)
	LD	IY,(IX+%9)
	LEA	HL,IY+%16
	ADD	HL,BC
	PUSH	HL
	LD	BC,(IX+%FFFFFFF6)
	CALL	__stoiu
	XOR	A,A
	LD	BC,HL
	LD	L,%10
	CALL	__lshl
	LD	(IX+%FFFFFFE0),BC
	LD	E,A
	LD	BC,(IX+%FFFFFFFB)
	CALL	__stoiu
	LD	BC,HL
	XOR	A,A
	LD	HL,(IX+%FFFFFFE0)
	CALL	__lor
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	(IX+%FFFFFFDF),A
	CALL	_put_utf
	LD	A,(IX+%FFFFFFDF)
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFE9),HL
; 2646					if (nw == 0) { di = 0; break; }	/* Buffer overflow or wrong char? */
.LINE 2646

	CALL	__icmpzero
	JR	NZ,L_217
	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	JR	L_221
L_217:
; 2647					di += nw;
.LINE 2647

	LD	BC,(IX+%FFFFFFE9)
	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,BC
	LD	(IX+%FFFFFFFD),HL
; 2648					hs = 0;
.LINE 2648

	LD	(IX+%FFFFFFF6),%0
	LD	(IX+%FFFFFFF7),%0
; 2649				}
L_218:
.LINE 2649

	LD	IY,(IX+%FFFFFFE3)
	LD	BC,(IY+%B)
	LD	(IX+%FFFFFFEF),BC
	LD	HL,(IX+%FFFFFFF8)
	ADD	HL,HL
	LD	BC,(IX+%FFFFFFEF)
	ADD	HL,BC
	LD	HL,(HL)
	CALL	__scmpzero
	JR	NZ,L_219
L_221:
; 2650				if (hs != 0) di = 0;	/* Broken surrogate pair? */
.LINE 2650

	LD	HL,(IX+%FFFFFFF6)
	CALL	__scmpzero
	JR	Z,L_222
	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
L_222:
; 2651				fno->fname[di] = 0;		/* Terminate the LFN (null string means LFN is invalid) */
.LINE 2651

	LD	BC,(IX+%FFFFFFFD)
	LD	IY,(IX+%9)
	LEA	HL,IY+%16
	ADD	HL,BC
	LD	(HL),%0
; 2652			}
; 2653		}
L_225:
.LINE 2653

; 2654	
; 2655		si = di = 0;
.LINE 2655

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	LD	(IX+%FFFFFFF8),BC
; 2656		while (si < 11) {		/* Get SFN from SFN entry */
.LINE 2656

	JR	L_236
L_237:
; 2657			wc = dp->dir[si++];			/* Get a char */
.LINE 2657

	LD	BC,(IX+%FFFFFFF8)
	LD	IY,(IX+%6)
	LD	HL,(IY+%1B)
	ADD	HL,BC
	LD	C,(HL)
	LD	B,%0
	LD	HL,BC
	LD	(IX+%FFFFFFFB),L
	LD	(IX+%FFFFFFFC),H
	LD	BC,(IX+%FFFFFFF8)
	INC	BC
	LD	(IX+%FFFFFFF8),BC
; 2658			if (wc == ' ') continue;	/* Skip padding spaces */
.LINE 2658

	LD.LIS	BC,32
	LD	HL,(IX+%FFFFFFFB)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_236
; 2659			if (wc == RDDEM) wc = DDEM;	/* Restore replaced DDEM character */
.LINE 2659

	LD.LIS	BC,5
	LD	HL,(IX+%FFFFFFFB)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_233
	LD	(IX+%FFFFFFFB),%E5
	LD	(IX+%FFFFFFFC),%0
L_233:
; 2660			if (si == 9 && di < FF_SFN_BUF) fno->altname[di++] = '.';	/* Insert a . if extension is exist */
.LINE 2660

	LD	BC,9
	LD	HL,(IX+%FFFFFFF8)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_235
	LD	BC,12
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_235
	LD	BC,(IX+%FFFFFFFD)
	LD	IY,(IX+%9)
	LEA	HL,IY+%9
	ADD	HL,BC
	LD	(HL),%2E
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
L_235:
; 2661	#if FF_LFN_UNICODE >= 1	/* Unicode output */
; 2662			if (dbc_1st((BYTE)wc) && si != 8 && si != 11 && dbc_2nd(dp->dir[si])) {	/* Make a DBC if needed */
; 2663				wc = wc << 8 | dp->dir[si++];
; 2664			}
; 2665			wc = ff_oem2uni(wc, CODEPAGE);		/* ANSI/OEM -> Unicode */
; 2666			if (wc == 0) { di = 0; break; }		/* Wrong char in the current code page? */
; 2667			nw = put_utf(wc, &fno->altname[di], FF_SFN_BUF - di);	/* Store it in API encoding */
; 2668			if (nw == 0) { di = 0; break; }		/* Buffer overflow? */
; 2669			di += nw;
; 2670	#else					/* ANSI/OEM output */
; 2671			fno->altname[di++] = (TCHAR)wc;	/* Store it without any conversion */
.LINE 2671

	LD	A,(IX+%FFFFFFFB)
	LD	BC,(IX+%FFFFFFFD)
	LD	IY,(IX+%9)
	LEA	HL,IY+%9
	ADD	HL,BC
	LD	(HL),A
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
; 2672	#endif
; 2673		}
L_236:
.LINE 2673

	LD	BC,11
	LD	HL,(IX+%FFFFFFF8)
	OR	A,A
	SBC	HL,BC
	JR	C,L_237
; 2674		fno->altname[di] = 0;	/* Terminate the SFN  (null string means SFN is invalid) */
.LINE 2674

	LD	IY,(IX+%9)
	LEA	BC,IY+%9
	LD	(IX+%FFFFFFEC),BC
	LD	BC,(IX+%FFFFFFFD)
	LEA	HL,IY+%9
	ADD	HL,BC
	LD	(HL),%0
; 2675	
; 2676		if (fno->fname[0] == 0) {	/* If LFN is invalid, altname[] needs to be copied to fname[] */
.LINE 2676

	LEA	BC,IY+%16
	LD	(IX+%FFFFFFF2),BC
	LD	A,(IY+%16)
	OR	A,A
	JR	NZ,L_256
; 2677			if (di == 0) {	/* If LFN and SFN both are invalid, this object is inaccesible */
.LINE 2677

	LD	HL,(IX+%FFFFFFFD)
	CALL	__icmpzero
	JR	NZ,L_252
; 2678				fno->fname[di++] = '?';
.LINE 2678

	LD	IY,(IX+%9)
	LEA	BC,IY+%16
	LD	(IX+%FFFFFFF2),BC
	LD	BC,(IX+%FFFFFFFD)
	LEA	HL,IY+%16
	ADD	HL,BC
	LD	(HL),%3F
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
; 2679			} else {
.LINE 2679

	JR	L_253
L_252:
; 2680				for (si = di = 0, lcf = NS_BODY; fno->altname[si]; si++, di++) {	/* Copy altname[] to fname[] with case information */
.LINE 2680

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	LD	(IX+%FFFFFFF8),BC
	LD	(IX+%FFFFFFF5),%8
	JR	L_250
L_248:
; 2681					wc = (WCHAR)fno->altname[si];
.LINE 2681

	LD	HL,(IX+%FFFFFFE6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	(IX+%FFFFFFFB),B
	LD	(IX+%FFFFFFFC),H
; 2682					if (wc == '.') lcf = NS_EXT;
.LINE 2682

	LD.LIS	BC,46
	LD	HL,(IX+%FFFFFFFB)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_246
	LD	(IX+%FFFFFFF5),%10
L_246:
; 2683					if (IsUpper(wc) && (dp->dir[DIR_NTres] & lcf)) wc += 0x20;
.LINE 2683

	LD.LIS	BC,65
	LD	HL,(IX+%FFFFFFFB)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_247
	LD	BC,(IX+%FFFFFFFB)
	LD.LIS	HL,90
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_247
	LD	IY,(IX+%6)
	LD	IY,(IY+%1B)
	LD	A,(IY+%C)
	AND	A,(IX+%FFFFFFF5)
	JR	Z,L_247
	LD	IY,(IX+%FFFFFFFB)
	LEA	HL,IY+%20
	LD	(IX+%FFFFFFFB),L
	LD	(IX+%FFFFFFFC),H
L_247:
; 2684					fno->fname[di] = (TCHAR)wc;
.LINE 2684

	LD	IY,(IX+%9)
	LEA	BC,IY+%16
	LD	(IX+%FFFFFFF2),BC
	LD	A,(IX+%FFFFFFFB)
	LD	BC,(IX+%FFFFFFFD)
	LEA	HL,IY+%16
	ADD	HL,BC
	LD	(HL),A
	LD	BC,(IX+%FFFFFFF8)
	INC	BC
	LD	(IX+%FFFFFFF8),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
; 2685				}
L_250:
.LINE 2685

	LD	IY,(IX+%9)
	LEA	BC,IY+%9
	LD	(IX+%FFFFFFEC),BC
	LD	BC,(IX+%FFFFFFF8)
	LEA	HL,IY+%9
	ADD	HL,BC
	LD	(IX+%FFFFFFE6),HL
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_248
; 2686			}
L_253:
.LINE 2686

; 2687			fno->fname[di] = 0;	/* Terminate the LFN */
.LINE 2687

	LD	BC,(IX+%FFFFFFFD)
	LD	HL,(IX+%FFFFFFF2)
	ADD	HL,BC
	LD	(HL),%0
; 2688			if (!dp->dir[DIR_NTres]) fno->altname[0] = 0;	/* Altname is not needed if neither LFN nor case info is exist. */
.LINE 2688

	LD	IY,(IX+%6)
	LD	IY,(IY+%1B)
	LD	A,(IY+%C)
	OR	A,A
	JR	NZ,L_256
	LD	HL,(IX+%FFFFFFEC)
	LD	(HL),%0
; 2689		}
L_256:
.LINE 2689

; 2690	
; 2691	#else	/* Non-LFN configuration */
; 2692		si = di = 0;
; 2693		while (si < 11) {		/* Copy name body and extension */
; 2694			c = (TCHAR)dp->dir[si++];
; 2695			if (c == ' ') continue;		/* Skip padding spaces */
; 2696			if (c == RDDEM) c = DDEM;	/* Restore replaced DDEM character */
; 2697			if (si == 9) fno->fname[di++] = '.';/* Insert a . if extension is exist */
; 2698			fno->fname[di++] = c;
; 2699		}
; 2700		fno->fname[di] = 0;		/* Terminate the SFN */
; 2701	#endif
; 2702	
; 2703		fno->fattrib = dp->dir[DIR_Attr] & AM_MASK;			/* Attribute */
.LINE 2703

	LD	IY,(IX+%6)
	LD	IY,(IY+%1B)
	LEA	HL,IY+%B
	LD	A,(HL)
	AND	A,%3F
	LD	IY,(IX+%9)
	LD	(IY+%8),A
; 2704		fno->fsize = ld_dword(dp->dir + DIR_FileSize);		/* Size */
.LINE 2704

	LD	IY,(IX+%6)
	LD	IY,(IY+%1B)
	LEA	BC,IY+%1C
	PUSH	BC
	CALL	_ld_dword
	POP	BC
	LD	IY,(IX+%9)
	LD	(IY+%0),HL
	LD	(IY+%3),E
; 2705		fno->ftime = ld_word(dp->dir + DIR_ModTime + 0);	/* Time */
.LINE 2705

	LD	IY,(IX+%6)
	LD	IY,(IY+%1B)
	LEA	BC,IY+%16
	PUSH	BC
	CALL	_ld_word
	POP	BC
	LD	IY,(IX+%9)
	LD	BC,HL
	LD	(IY+%6),C
	LD	(IY+%7),B
; 2706		fno->fdate = ld_word(dp->dir + DIR_ModTime + 2);	/* Date */
.LINE 2706

	LD	IY,(IX+%6)
	LD	IY,(IY+%1B)
	LEA	BC,IY+%18
	PUSH	BC
	CALL	_ld_word
	POP	BC
	LD	IY,(IX+%9)
	LD	BC,HL
	LD	(IY+%4),C
	LD	(IY+%5),B
; 2707	}
L_257:
.LINE 2707

	LD	SP,IX
	POP	IX
	RET	


;**************************** _get_fileinfo ***************************
;Name                         Addr/Register   Size   Type
;fs                                   IX-29      3   variable
;G_11                                 IX-26      3   variable
;nw                                   IX-23      3   variable
;G_15                                 IX-20      3   variable
;G_9                                  IX-17      3   variable
;G_14                                 IX-14      3   variable
;lcf                                  IX-11      1   variable
;hs                                   IX-10      2   variable
;si                                    IX-8      3   variable
;wc                                    IX-5      2   variable
;di                                    IX-3      3   variable
;fno                                   IX+9      3   parameter
;dp                                    IX+6      3   parameter


; Stack Frame Size: 45 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "get_fileinfo",2707,"_get_fileinfo"
; 2708	
; 2709	#endif /* FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2 */
; 2710	
; 2711	
; 2712	
; 2713	#if FF_USE_FIND && FF_FS_MINIMIZE <= 1
; 2714	/*-----------------------------------------------------------------------*/
; 2715	/* Pattern matching                                                      */
; 2716	/*-----------------------------------------------------------------------*/
; 2717	
; 2718	#define FIND_RECURS	4	/* Maximum number of wildcard terms in the pattern to limit recursion */
; 2719	
; 2720	
; 2721	static DWORD get_achar (	/* Get a character and advance ptr */
; 2722		const TCHAR** ptr		/* Pointer to pointer to the ANSI/OEM or Unicode string */
; 2723	)
; 2724	{
; 2725		DWORD chr;
; 2726	
; 2727	
; 2728	#if FF_USE_LFN && FF_LFN_UNICODE >= 1	/* Unicode input */
; 2729		chr = tchar2uni(ptr);
; 2730		if (chr == 0xFFFFFFFF) chr = 0;		/* Wrong UTF encoding is recognized as end of the string */
; 2731		chr = ff_wtoupper(chr);
; 2732	
; 2733	#else									/* ANSI/OEM input */
; 2734		chr = (BYTE)*(*ptr)++;				/* Get a byte */
; 2735		if (IsLower(chr)) chr -= 0x20;		/* To upper ASCII char */
; 2736	#if FF_CODE_PAGE == 0
; 2737		if (ExCvt && chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
; 2738	#elif FF_CODE_PAGE < 900
; 2739		if (chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
; 2740	#endif
; 2741	#if FF_CODE_PAGE == 0 || FF_CODE_PAGE >= 900
; 2742		if (dbc_1st((BYTE)chr)) {	/* Get DBC 2nd byte if needed */
; 2743			chr = dbc_2nd((BYTE)**ptr) ? chr << 8 | (BYTE)*(*ptr)++ : 0;
; 2744		}
; 2745	#endif
; 2746	
; 2747	#endif
; 2748		return chr;
; 2749	}
; 2750	
; 2751	
; 2752	static int pattern_match (	/* 0:mismatched, 1:matched */
; 2753		const TCHAR* pat,	/* Matching pattern */
; 2754		const TCHAR* nam,	/* String to be tested */
; 2755		UINT skip,			/* Number of pre-skip chars (number of ?s, b8:infinite (* specified)) */
; 2756		UINT recur			/* Recursion count */
; 2757	)
; 2758	{
; 2759		const TCHAR *pptr, *nptr;
; 2760		DWORD pchr, nchr;
; 2761		UINT sk;
; 2762	
; 2763	
; 2764		while ((skip & 0xFF) != 0) {		/* Pre-skip name chars */
; 2765			if (!get_achar(&nam)) return 0;	/* Branch mismatched if less name chars */
; 2766			skip--;
; 2767		}
; 2768		if (*pat == 0 && skip) return 1;	/* Matched? (short circuit) */
; 2769	
; 2770		do {
; 2771			pptr = pat; nptr = nam;			/* Top of pattern and name to match */
; 2772			for (;;) {
; 2773				if (*pptr == '?' || *pptr == '*') {	/* Wildcard term? */
; 2774					if (recur == 0) return 0;	/* Too many wildcard terms? */
; 2775					sk = 0;
; 2776					do {	/* Analyze the wildcard term */
; 2777						if (*pptr++ == '?') sk++; else sk |= 0x100;
; 2778					} while (*pptr == '?' || *pptr == '*');
; 2779					if (pattern_match(pptr, nptr, sk, recur - 1)) return 1;	/* Test new branch (recursive call) */
; 2780					nchr = *nptr; break;	/* Branch mismatched */
; 2781				}
; 2782				pchr = get_achar(&pptr);	/* Get a pattern char */
; 2783				nchr = get_achar(&nptr);	/* Get a name char */
; 2784				if (pchr != nchr) break;	/* Branch mismatched? */
; 2785				if (pchr == 0) return 1;	/* Branch matched? (matched at end of both strings) */
; 2786			}
; 2787			get_achar(&nam);			/* nam++ */
; 2788		} while (skip && nchr);		/* Retry until end of name if infinite search is specified */
; 2789	
; 2790		return 0;
; 2791	}
; 2792	
; 2793	#endif /* FF_USE_FIND && FF_FS_MINIMIZE <= 1 */
; 2794	
; 2795	
; 2796	
; 2797	/*-----------------------------------------------------------------------*/
; 2798	/* Pick a top segment and create the object name in directory form       */
; 2799	/*-----------------------------------------------------------------------*/
; 2800	
; 2801	static FRESULT create_name (	/* FR_OK: successful, FR_INVALID_NAME: could not create */
; 2802		DIR* dp,					/* Pointer to the directory object */
; 2803		const TCHAR** path			/* Pointer to pointer to the segment in the path string */
; 2804	)
; 2805	{
_create_name:
.DEFINE "_create_name"

.VALUE _create_name

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "create_name",2805,"_create_name"

.LINE 2805

.DEFINE "dp"

.CLASS 65

.VALUE 6

.TAG "NONAME3"

.TYPE 40

.ENDEF

.DEFINE "path"

.CLASS 65

.VALUE 9

.TYPE 1570

.ENDEF

.DEFINE "di"

.CLASS 65

.VALUE -3

.TYPE 14

.ENDEF

.DEFINE "cf"

.CLASS 65

.VALUE -4

.TYPE 12

.ENDEF

.DEFINE "wc"

.CLASS 65

.VALUE -6

.TYPE 13

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -9

.TYPE 14

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE -10

.TYPE 12

.ENDEF

.DEFINE "si"

.CLASS 65

.VALUE -13

.TYPE 14

.ENDEF

.DEFINE "lfn"

.CLASS 65

.VALUE -16

.TYPE 45

.ENDEF

.DEFINE "uc"

.CLASS 65

.VALUE -20

.TYPE 15

.ENDEF

.DEFINE "p"

.CLASS 65

.VALUE -23

.TYPE 194

.ENDEF

.DEFINE "ni"

.CLASS 65

.VALUE -26

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFD4
	LD	SP,HL
; 2806	#if FF_USE_LFN		/* LFN configuration */
; 2807		BYTE b, cf;
; 2808		WCHAR wc, *lfn;
; 2809		DWORD uc;
; 2810		UINT i, ni, si, di;
; 2811		const TCHAR *p;
; 2812	
; 2813	
; 2814		/* Create LFN into LFN working buffer */
; 2815		p = *path; lfn = dp->obj.fs->lfnbuf; di = 0;
.LINE 2815

	LD	HL,(IX+%9)
	LD	BC,(HL)
	LD	(IX+%FFFFFFE9),BC
	LD	IY,(IX+%6)
	LD	IY,(IY+%0)
	LD	BC,(IY+%B)
	LD	(IX+%FFFFFFF0),BC
	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
; 2816		for (;;) {
L_273:
.LINE 2816

; 2817			uc = tchar2uni(&p);			/* Get a character */
.LINE 2817

	PEA	IX+%FFFFFFE9
	CALL	_tchar2uni
	POP	BC
	LD	(IX+%FFFFFFEC),HL
	LD	(IX+%FFFFFFEF),E
; 2818			if (uc == 0xFFFFFFFF) return FR_INVALID_NAME;		/* Invalid code or UTF decode error */
.LINE 2818

	LD	HL,(IX+%FFFFFFEC)
	LD	E,(IX+%FFFFFFEF)
	LD	BC,16777215
	LD	A,%FF
	CALL	__lcmpu
	JR	NZ,L_261
	LD	HL,6
	JR	L_371
L_261:
; 2819			if (uc >= 0x10000) lfn[di++] = (WCHAR)(uc >> 16);	/* Store high surrogate if needed */
.LINE 2819

	LD	HL,(IX+%FFFFFFEC)
	LD	E,(IX+%FFFFFFEF)
	LD	BC,65536
	XOR	A,A
	CALL	__lcmpu
	JR	C,L_262
	LD	BC,(IX+%FFFFFFEC)
	LD	A,(IX+%FFFFFFEF)
	LD	L,%10
	CALL	__lshru
	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	LD	DE,(IX+%FFFFFFF0)
	ADD	HL,DE
	LD	(HL),C
	INC	HL
	LD	(HL),B
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
L_262:
; 2820			wc = (WCHAR)uc;
; 2821			if (wc < ' ' || IsSeparator(wc)) break;	/* Break if end of the path or a separator is found */
.LINE 2821

	LD.LIS	BC,32
	LD	HL,(IX+%FFFFFFEC)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_283
	LD.LIS	BC,47
	LD	HL,(IX+%FFFFFFEC)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_283
	LD.LIS	BC,92
	LD	HL,(IX+%FFFFFFEC)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_283
; 2822			if (wc < 0x80 && strchr("*:<>|\"\?\x7F", (int)wc)) return FR_INVALID_NAME;	/* Reject illegal characters for LFN */
.LINE 2822

	LD.LIS	BC,128
	LD	HL,(IX+%FFFFFFEC)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NC,L_270
	LD	BC,(IX+%FFFFFFEC)
	CALL	__stoiu
	PUSH	HL
	LD	BC,L__141
	PUSH	BC
	CALL	_strchr
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	Z,L_270
	LD	HL,6
	JR	L_371
L_270:
; 2823			if (di >= FF_MAX_LFN) return FR_INVALID_NAME;	/* Reject too long name */
.LINE 2823

	LD	BC,255
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	C,L_272
	LD	HL,6
	JR	L_371
L_272:
; 2824			lfn[di++] = wc;				/* Store the Unicode character */
.LINE 2824

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	LD	BC,(IX+%FFFFFFF0)
	ADD	HL,BC
	LD	BC,(IX+%FFFFFFEC)
	LD	(HL),C
	INC	HL
	LD	(HL),B
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
; 2825		}
.LINE 2825

	JR	L_273
L_283:
; 2826		if (wc < ' ') {				/* Stopped at end of the path? */
.LINE 2826

	LD.LIS	BC,32
	LD	HL,(IX+%FFFFFFEC)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NC,L_277
; 2827			cf = NS_LAST;			/* Last segment */
.LINE 2827

	LD	(IX+%FFFFFFFC),%4
; 2828		} else {					/* Stopped at a separator */
.LINE 2828

	JR	L_284
; 2829			while (IsSeparator(*p)) p++;	/* Skip duplicated separators if exist */
.LINE 2829

L_278:
	LD	BC,(IX+%FFFFFFE9)
	LD	(IX+%FFFFFFD4),BC
	LD	BC,(IX+%FFFFFFE9)
	INC	BC
	LD	(IX+%FFFFFFE9),BC
L_277:
	LD	HL,(IX+%FFFFFFE9)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,47
	OR	A,A
	SBC	HL,BC
	JR	Z,L_278
	LD	HL,(IX+%FFFFFFE9)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,92
	OR	A,A
	SBC	HL,BC
	JR	Z,L_278
; 2830			cf = 0;					/* Next segment may follow */
.LINE 2830

	LD	(IX+%FFFFFFFC),%0
; 2831			if (IsTerminator(*p)) cf = NS_LAST;	/* Ignore terminating separator */
.LINE 2831

	LD	HL,(IX+%FFFFFFE9)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,32
	OR	A,A
	SBC	HL,BC
	JR	NC,L_284
	LD	(IX+%FFFFFFFC),%4
; 2832		}
L_284:
.LINE 2832

; 2833		*path = p;					/* Return pointer to the next segment */
.LINE 2833

	LD	HL,(IX+%9)
	LD	BC,(IX+%FFFFFFE9)
	LD	(HL),BC
; 2834	
; 2835	#if FF_FS_RPATH != 0
; 2836		if ((di == 1 && lfn[di - 1] == '.') ||
.LINE 2836

	LD	BC,1
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_288
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%FFFFFFFF
	ADD	HL,HL
	LD	BC,(IX+%FFFFFFF0)
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	BC,46
	OR	A,A
	SBC	HL,BC
	JR	Z,L_298
L_288:
; 2837			(di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) {	/* Is this segment a dot name? */
.LINE 2837

	LD	BC,2
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_303
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%FFFFFFFF
	ADD	HL,HL
	LD	BC,(IX+%FFFFFFF0)
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	BC,46
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_303
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%FFFFFFFE
	ADD	HL,HL
	LD	BC,(IX+%FFFFFFF0)
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	BC,46
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_303
L_298:
; 2838			lfn[di] = 0;
.LINE 2838

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	LD	BC,(IX+%FFFFFFF0)
	ADD	HL,BC
	LD	(HL),%0
	INC	HL
	LD	(HL),%0
; 2839			for (i = 0; i < 11; i++) {	/* Create dot name for SFN entry */
.LINE 2839

	LD	BC,0
	LD	(IX+%FFFFFFF7),BC
	JR	L_296
L_294:
; 2840				dp->fn[i] = (i < di) ? '.' : ' ';
.LINE 2840

	LD	BC,(IX+%FFFFFFFD)
	LD	HL,(IX+%FFFFFFF7)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_292
	LD	BC,46
	LD	(IX+%FFFFFFE3),BC
	JR	L_293
L_292:
	LD	BC,32
	LD	(IX+%FFFFFFE3),BC
L_293:
	LD	A,(IX+%FFFFFFE3)
	LD	BC,(IX+%FFFFFFF7)
	LD	IY,(IX+%6)
	LEA	HL,IY+%1E
	ADD	HL,BC
	LD	(HL),A
	LD	BC,(IX+%FFFFFFF7)
	INC	BC
	LD	(IX+%FFFFFFF7),BC
; 2841			}
L_296:
.LINE 2841

	LD	BC,11
	LD	HL,(IX+%FFFFFFF7)
	OR	A,A
	SBC	HL,BC
	JR	C,L_294
; 2842			dp->fn[i] = cf | NS_DOT;	/* This is a dot entry */
.LINE 2842

	LD	A,(IX+%FFFFFFFC)
	SET	%5,A
	LD	BC,(IX+%FFFFFFF7)
	LD	IY,(IX+%6)
	LEA	HL,IY+%1E
	ADD	HL,BC
	LD	(HL),A
; 2843			return FR_OK;
.LINE 2843

	OR	A,A
	SBC	HL,HL
	JR	L_371
; 2844		}
.LINE 2844

; 2845	#endif
; 2846		while (di) {					/* Snip off trailing spaces and dots if exist */
.LINE 2846

L_304:
; 2847			wc = lfn[di - 1];
.LINE 2847

	LD	IY,(IX+%FFFFFFFD)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%FFFFFFE0),IY
	LD	HL,(IX+%FFFFFFE0)
	ADD	HL,HL
	LD	BC,(IX+%FFFFFFF0)
	ADD	HL,BC
	LD	BC,(HL)
	LD	(IX+%FFFFFFFA),C
	LD	(IX+%FFFFFFFB),B
; 2848			if (wc != ' ' && wc != '.') break;
.LINE 2848

	LD.LIS	BC,32
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_302
	LD.LIS	BC,46
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_306
L_302:
; 2849			di--;
.LINE 2849

	LD	BC,(IX+%FFFFFFE0)
	LD	(IX+%FFFFFFFD),BC
; 2850		}
L_303:
.LINE 2850

	LD	HL,(IX+%FFFFFFFD)
	CALL	__icmpzero
	JR	NZ,L_304
L_306:
; 2851		lfn[di] = 0;							/* LFN is created into the working buffer */
.LINE 2851

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	LD	BC,(IX+%FFFFFFF0)
	ADD	HL,BC
	LD	(HL),%0
	INC	HL
	LD	(HL),%0
; 2852		if (di == 0) return FR_INVALID_NAME;	/* Reject null name */
.LINE 2852

	LD	HL,(IX+%FFFFFFFD)
	CALL	__icmpzero
	JR	NZ,L_312
	LD	HL,6
	JR	L_371
L_312:
; 2853	
; 2854		/* Create SFN in directory form */
; 2855		for (si = 0; lfn[si] == ' '; si++) ;	/* Remove leading spaces */
.LINE 2855

	LD	BC,0
	LD	(IX+%FFFFFFF3),BC
	JR	L_311
L_309:
	LD	BC,(IX+%FFFFFFF3)
	INC	BC
	LD	(IX+%FFFFFFF3),BC
L_311:
	LD	HL,(IX+%FFFFFFF3)
	ADD	HL,HL
	LD	BC,(IX+%FFFFFFF0)
	ADD	HL,BC
	LD	(IX+%FFFFFFDD),HL
	LD	BC,(HL)
	CALL	__stoiu
	LD	BC,32
	OR	A,A
	SBC	HL,BC
	JR	Z,L_309
; 2856		if (si > 0 || lfn[si] == '.') cf |= NS_LOSS | NS_LFN;	/* Is there any leading space or dot? */
.LINE 2856

	LD	BC,(IX+%FFFFFFF3)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	C,L_314
	LD	HL,(IX+%FFFFFFDD)
	LD	BC,(HL)
	CALL	__stoiu
	LD	BC,46
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_318
L_314:
	LD	A,(IX+%FFFFFFFC)
	OR	A,%3
	LD	(IX+%FFFFFFFC),A
; 2857		while (di > 0 && lfn[di - 1] != '.') di--;	/* Find last dot (di<=si: no extension) */
.LINE 2857

	JR	L_318
L_319:
	LD	BC,(IX+%FFFFFFDA)
	LD	(IX+%FFFFFFFD),BC
L_318:
	LD	BC,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	NC,L_321
	LD	IY,(IX+%FFFFFFFD)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%FFFFFFDA),IY
	LD	HL,(IX+%FFFFFFDA)
	ADD	HL,HL
	LD	BC,(IX+%FFFFFFF0)
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	BC,46
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_319
L_321:
; 2858	
; 2859		memset(dp->fn, ' ', 11);
.LINE 2859

	LD	BC,11
	PUSH	BC
	LD	BC,32
	PUSH	BC
	LD	IY,(IX+%6)
	PEA	IY+%1E
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
; 2860		i = b = 0; ni = 8;
.LINE 2860

	LD	(IX+%FFFFFFF6),%0
	LD	BC,0
	LD	(IX+%FFFFFFF7),BC
	LD	BC,8
	LD	(IX+%FFFFFFE6),BC
; 2861		for (;;) {
L_356:
.LINE 2861

; 2862			wc = lfn[si++];					/* Get an LFN character */
.LINE 2862

	LD	HL,(IX+%FFFFFFF3)
	ADD	HL,HL
	LD	BC,(IX+%FFFFFFF0)
	ADD	HL,BC
	LD	BC,(HL)
	LD	(IX+%FFFFFFFA),C
	LD	(IX+%FFFFFFFB),B
	LD	BC,(IX+%FFFFFFF3)
	INC	BC
	LD	(IX+%FFFFFFF3),BC
; 2863			if (wc == 0) break;				/* Break on end of the LFN */
.LINE 2863

	LD	HL,(IX+%FFFFFFFA)
	CALL	__scmpzero
	JR	Z,L_359
; 2864			if (wc == ' ' || (wc == '.' && si != di)) {	/* Remove embedded spaces and dots */
.LINE 2864

	LD.LIS	BC,32
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_326
	LD.LIS	BC,46
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_336
	LD	BC,(IX+%FFFFFFFD)
	LD	HL,(IX+%FFFFFFF3)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_336
L_326:
; 2865				cf |= NS_LOSS | NS_LFN;
.LINE 2865

	LD	A,(IX+%FFFFFFFC)
	OR	A,%3
	LD	(IX+%FFFFFFFC),A
; 2866				continue;
.LINE 2866

	JR	L_356
; 2867			}
L_336:
.LINE 2867

; 2868	
; 2869			if (i >= ni || si == di) {		/* End of field? */
.LINE 2869

	LD	BC,(IX+%FFFFFFE6)
	LD	HL,(IX+%FFFFFFF7)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_335
	LD	BC,(IX+%FFFFFFFD)
	LD	HL,(IX+%FFFFFFF3)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_339
L_335:
; 2870				if (ni == 11) {				/* Name extension overflow? */
.LINE 2870

	LD	BC,11
	LD	HL,(IX+%FFFFFFE6)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_331
; 2871					cf |= NS_LOSS | NS_LFN;
.LINE 2871

	LD	A,(IX+%FFFFFFFC)
	OR	A,%3
	LD	(IX+%FFFFFFFC),A
; 2872					break;
.LINE 2872

	JR	L_359
; 2873				}
L_331:
.LINE 2873

; 2874				if (si != di) cf |= NS_LOSS | NS_LFN;	/* Name body overflow? */
.LINE 2874

	LD	BC,(IX+%FFFFFFFD)
	LD	HL,(IX+%FFFFFFF3)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_333
	LD	A,(IX+%FFFFFFFC)
	OR	A,%3
	LD	(IX+%FFFFFFFC),A
L_333:
; 2875				if (si > di) break;						/* No name extension? */
.LINE 2875

	LD	BC,(IX+%FFFFFFF3)
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	C,L_359
; 2876				si = di; i = 8; ni = 11; b <<= 2;		/* Enter name extension */
.LINE 2876

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFF3),BC
	LD	BC,8
	LD	(IX+%FFFFFFF7),BC
	LD	BC,11
	LD	(IX+%FFFFFFE6),BC
	LD	A,(IX+%FFFFFFF6)
	ADD	A,A
	ADD	A,A
	LD	(IX+%FFFFFFF6),A
; 2877				continue;
.LINE 2877

	JR	L_356
; 2878			}
L_339:
.LINE 2878

; 2879	
; 2880			if (wc >= 0x80) {	/* Is this an extended character? */
.LINE 2880

	LD.LIS	BC,128
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_353
; 2881				cf |= NS_LFN;	/* LFN entry needs to be created */
.LINE 2881

	LD	A,(IX+%FFFFFFFC)
	SET	%1,A
	LD	(IX+%FFFFFFFC),A
; 2882	#if FF_CODE_PAGE == 0
; 2883				if (ExCvt) {	/* In SBCS cfg */
; 2884					wc = ff_uni2oem(wc, CODEPAGE);			/* Unicode ==> ANSI/OEM code */
; 2885					if (wc & 0x80) wc = ExCvt[wc & 0x7F];	/* Convert extended character to upper (SBCS) */
; 2886				} else {		/* In DBCS cfg */
; 2887					wc = ff_uni2oem(ff_wtoupper(wc), CODEPAGE);	/* Unicode ==> Up-convert ==> ANSI/OEM code */
; 2888				}
; 2889	#elif FF_CODE_PAGE < 900	/* In SBCS cfg */
; 2890				wc = ff_uni2oem(wc, CODEPAGE);			/* Unicode ==> ANSI/OEM code */
.LINE 2890

	LD	BC,437
	PUSH	BC
	LD	BC,(IX+%FFFFFFFA)
	CALL	__stoiu
	LD	C,%0
	LD	B,%0
	PUSH	BC
	PUSH	HL
	CALL	_ff_uni2oem
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFA),L
	LD	(IX+%FFFFFFFB),H
; 2891				if (wc & 0x80) wc = ExCvt[wc & 0x7F];	/* Convert extended character to upper (SBCS) */
.LINE 2891

	LD	A,(IX+%FFFFFFFA)
	AND	A,%80
	LD	C,A
	LD	B,%0
	LD	HL,BC
	CALL	__scmpzero
	JR	Z,L_353
	LD	A,(IX+%FFFFFFFA)
	RES	%7,A
	LD	C,A
	CALL	__stoiu
	LD	BC,_ExCvt
	ADD	HL,BC
	LD	C,(HL)
	LD	B,%0
	LD	HL,BC
	LD	(IX+%FFFFFFFA),L
	LD	(IX+%FFFFFFFB),H
; 2892	#else						/* In DBCS cfg */
; 2893				wc = ff_uni2oem(ff_wtoupper(wc), CODEPAGE);	/* Unicode ==> Up-convert ==> ANSI/OEM code */
; 2894	#endif
; 2895			}
L_353:
.LINE 2895

; 2896	
; 2897			if (wc >= 0x100) {				/* Is this a DBC? */
.LINE 2897

	LD.LIS	BC,256
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_352
; 2898				if (i >= ni - 1) {			/* Field overflow? */
.LINE 2898

	LD	IY,(IX+%FFFFFFE6)
	LEA	BC,IY+%FFFFFFFF
	LD	HL,(IX+%FFFFFFF7)
	OR	A,A
	SBC	HL,BC
	JR	C,L_342
; 2899					cf |= NS_LOSS | NS_LFN;
.LINE 2899

	LD	A,(IX+%FFFFFFFC)
	OR	A,%3
	LD	(IX+%FFFFFFFC),A
; 2900					i = ni; continue;		/* Next field */
.LINE 2900

	LD	BC,(IX+%FFFFFFE6)
	LD	(IX+%FFFFFFF7),BC
	JR	L_356
; 2901				}
L_342:
.LINE 2901

; 2902				dp->fn[i++] = (BYTE)(wc >> 8);	/* Put 1st byte */
.LINE 2902

	LD	BC,(IX+%FFFFFFFA)
	CALL	__stoiu
	LD	A,%8
	CALL	__ishrs_b
	LD	A,L
	LD	BC,(IX+%FFFFFFF7)
	LD	IY,(IX+%6)
	LEA	HL,IY+%1E
	ADD	HL,BC
	LD	(HL),A
	LD	BC,(IX+%FFFFFFF7)
	INC	BC
	LD	(IX+%FFFFFFF7),BC
; 2903			} else {						/* SBC */
.LINE 2903

	JR	L_355
L_352:
; 2904				if (wc == 0 || strchr("+,;=[]", (int)wc)) {	/* Replace illegal characters for SFN */
.LINE 2904

	LD	HL,(IX+%FFFFFFFA)
	CALL	__scmpzero
	JR	Z,L_349
	LD	BC,(IX+%FFFFFFFA)
	CALL	__stoiu
	PUSH	HL
	LD	BC,L__178
	PUSH	BC
	CALL	_strchr
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	Z,L_350
L_349:
; 2905					wc = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
.LINE 2905

	LD	(IX+%FFFFFFFA),%5F
	LD	(IX+%FFFFFFFB),%0
	LD	A,(IX+%FFFFFFFC)
	OR	A,%3
	LD	(IX+%FFFFFFFC),A
; 2906				} else {
.LINE 2906

	JR	L_355
L_350:
; 2907					if (IsUpper(wc)) {		/* ASCII upper case? */
.LINE 2907

	LD.LIS	BC,65
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_348
	LD	BC,(IX+%FFFFFFFA)
	LD.LIS	HL,90
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_348
; 2908						b |= 2;
.LINE 2908

	LD	A,(IX+%FFFFFFF6)
	SET	%1,A
	LD	(IX+%FFFFFFF6),A
; 2909					}
L_348:
.LINE 2909

; 2910					if (IsLower(wc)) {		/* ASCII lower case? */
.LINE 2910

	LD.LIS	BC,97
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_355
	LD	BC,(IX+%FFFFFFFA)
	LD.LIS	HL,122
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_355
; 2911						b |= 1; wc -= 0x20;
.LINE 2911

	LD	A,(IX+%FFFFFFF6)
	SET	%0,A
	LD	(IX+%FFFFFFF6),A
	LD	IY,(IX+%FFFFFFFA)
	LEA	HL,IY+%FFFFFFE0
	LD	(IX+%FFFFFFFA),L
	LD	(IX+%FFFFFFFB),H
; 2912					}
; 2913				}
; 2914			}
L_355:
.LINE 2914

; 2915			dp->fn[i++] = (BYTE)wc;
.LINE 2915

	LD	A,(IX+%FFFFFFFA)
	LD	BC,(IX+%FFFFFFF7)
	LD	IY,(IX+%6)
	LEA	HL,IY+%1E
	ADD	HL,BC
	LD	(HL),A
	LD	BC,(IX+%FFFFFFF7)
	INC	BC
	LD	(IX+%FFFFFFF7),BC
; 2916		}
.LINE 2916

	JR	L_356
L_359:
; 2917	
; 2918		if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
.LINE 2918

	LD	IY,(IX+%6)
	LEA	BC,IY+%1E
	LD	(IX+%FFFFFFD7),BC
	LD	A,(IY+%1E)
	UEXT	HL
	LD	L,A
	LD	BC,229
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_361
	LD	IY,(IX+%6)
	LEA	BC,IY+%1E
	LD	(IX+%FFFFFFD7),BC
	LD	(IY+%1E),%5
L_361:
; 2919	
; 2920		if (ni == 8) b <<= 2;				/* Shift capital flags if no extension */
.LINE 2920

	LD	BC,8
	LD	HL,(IX+%FFFFFFE6)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_364
	LD	A,(IX+%FFFFFFF6)
	ADD	A,A
	ADD	A,A
	LD	(IX+%FFFFFFF6),A
L_364:
; 2921		if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* LFN entry needs to be created if composite capitals */
.LINE 2921

	LD	A,(IX+%FFFFFFF6)
	AND	A,%C
	CP	A,%C
	JR	Z,L_363
	LD	A,(IX+%FFFFFFF6)
	AND	A,%3
	CP	A,%3
	JR	NZ,L_369
L_363:
	LD	A,(IX+%FFFFFFFC)
	SET	%1,A
	LD	(IX+%FFFFFFFC),A
L_369:
; 2922		if (!(cf & NS_LFN)) {				/* When LFN is in 8.3 format without extended character, NT flags are created */
.LINE 2922

	LD	A,(IX+%FFFFFFFC)
	AND	A,%2
	JR	NZ,L_370
; 2923			if (b & 0x01) cf |= NS_EXT;		/* NT flag (Extension has small capital letters only) */
.LINE 2923

	LD	A,(IX+%FFFFFFF6)
	AND	A,%1
	JR	Z,L_367
	LD	A,(IX+%FFFFFFFC)
	SET	%4,A
	LD	(IX+%FFFFFFFC),A
L_367:
; 2924			if (b & 0x04) cf |= NS_BODY;	/* NT flag (Body has small capital letters only) */
.LINE 2924

	LD	A,(IX+%FFFFFFF6)
	AND	A,%4
	JR	Z,L_370
	LD	A,(IX+%FFFFFFFC)
	SET	%3,A
	LD	(IX+%FFFFFFFC),A
; 2925		}
L_370:
.LINE 2925

; 2926	
; 2927		dp->fn[NSFLAG] = cf;	/* SFN is created into dp->fn[] */
.LINE 2927

	LD	IY,(IX+%FFFFFFD7)
	LEA	HL,IY+%B
	LD	A,(IX+%FFFFFFFC)
	LD	(HL),A
; 2928	
; 2929		return FR_OK;
.LINE 2929

	OR	A,A
	SBC	HL,HL
; 2930	
; 2931	
; 2932	#else	/* FF_USE_LFN : Non-LFN configuration */
; 2933		BYTE c, d, *sfn;
; 2934		UINT ni, si, i;
; 2935		const char *p;
; 2936	
; 2937		/* Create file name in directory form */
; 2938		p = *path; sfn = dp->fn;
; 2939		memset(sfn, ' ', 11);
; 2940		si = i = 0; ni = 8;
; 2941	#if FF_FS_RPATH != 0
; 2942		if (p[si] == '.') { /* Is this a dot entry? */
; 2943			for (;;) {
; 2944				c = (BYTE)p[si++];
; 2945				if (c != '.' || si >= 3) break;
; 2946				sfn[i++] = c;
; 2947			}
; 2948			if (!IsSeparator(c) && c > ' ') return FR_INVALID_NAME;
; 2949			*path = p + si;					/* Return pointer to the next segment */
; 2950			sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of the path */
; 2951			return FR_OK;
; 2952		}
; 2953	#endif
; 2954		for (;;) {
; 2955			c = (BYTE)p[si++];				/* Get a byte */
; 2956			if (c <= ' ') break; 			/* Break if end of the path name */
; 2957			if (IsSeparator(c)) {			/* Break if a separator is found */
; 2958				while (IsSeparator(p[si])) si++;	/* Skip duplicated separator if exist */
; 2959				break;
; 2960			}
; 2961			if (c == '.' || i >= ni) {		/* End of body or field overflow? */
; 2962				if (ni == 11 || c != '.') return FR_INVALID_NAME;	/* Field overflow or invalid dot? */
; 2963				i = 8; ni = 11;				/* Enter file extension field */
; 2964				continue;
; 2965			}
; 2966	#if FF_CODE_PAGE == 0
; 2967			if (ExCvt && c >= 0x80) {		/* Is SBC extended character? */
; 2968				c = ExCvt[c & 0x7F];		/* To upper SBC extended character */
; 2969			}
; 2970	#elif FF_CODE_PAGE < 900
; 2971			if (c >= 0x80) {				/* Is SBC extended character? */
; 2972				c = ExCvt[c & 0x7F];		/* To upper SBC extended character */
; 2973			}
; 2974	#endif
; 2975			if (dbc_1st(c)) {				/* Check if it is a DBC 1st byte */
; 2976				d = (BYTE)p[si++];			/* Get 2nd byte */
; 2977				if (!dbc_2nd(d) || i >= ni - 1) return FR_INVALID_NAME;	/* Reject invalid DBC */
; 2978				sfn[i++] = c;
; 2979				sfn[i++] = d;
; 2980			} else {						/* SBC */
; 2981				if (strchr("*+,:;<=>[]|\"\?\x7F", (int)c)) return FR_INVALID_NAME;	/* Reject illegal chrs for SFN */
; 2982				if (IsLower(c)) c -= 0x20;	/* To upper */
; 2983				sfn[i++] = c;
; 2984			}
; 2985		}
; 2986		*path = &p[si];						/* Return pointer to the next segment */
; 2987		if (i == 0) return FR_INVALID_NAME;	/* Reject nul string */
; 2988	
; 2989		if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
; 2990		sfn[NSFLAG] = (c <= ' ' || p[si] <= ' ') ? NS_LAST : 0;	/* Set last segment flag if end of the path */
; 2991	
; 2992		return FR_OK;
; 2993	#endif /* FF_USE_LFN */
; 2994	}
L_371:
.LINE 2994

	LD	SP,IX
	POP	IX
	RET	


;**************************** _create_name ***************************
;Name                         Addr/Register   Size   Type
;_ExCvt                              STATIC    128   variable
;_ff_uni2oem                         IMPORT  -----   function
;_memset                             IMPORT  -----   function
;_strchr                             IMPORT  -----   function
;G_20                                 IX-41      3   variable
;G_18                                 IX-38      3   variable
;G_17                                 IX-35      3   variable
;G_16                                 IX-32      3   variable
;temp290                              IX-29      3   variable
;ni                                   IX-26      3   variable
;p                                    IX-23      3   variable
;uc                                   IX-20      4   variable
;lfn                                  IX-16      3   variable
;si                                   IX-13      3   variable
;b                                    IX-10      1   variable
;i                                     IX-9      3   variable
;wc                                    IX-6      2   variable
;cf                                    IX-4      1   variable
;di                                    IX-3      3   variable
;path                                  IX+9      3   parameter
;dp                                    IX+6      3   parameter


; Stack Frame Size: 56 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "create_name",2994,"_create_name"
	SEGMENT STRSECT
L__141:
	DB	"*:<>|\"?"
	DB	127,0
L__178:
	DB	"+,;=[]"
	DB	0
	SEGMENT CODE
; 2995	
; 2996	
; 2997	
; 2998	
; 2999	/*-----------------------------------------------------------------------*/
; 3000	/* Follow a file path                                                    */
; 3001	/*-----------------------------------------------------------------------*/
; 3002	
; 3003	static FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
; 3004		DIR* dp,					/* Directory object to return last directory and found object */
; 3005		const TCHAR* path			/* Full-path string to find a file or directory */
; 3006	)
; 3007	{
_follow_path:
.DEFINE "_follow_path"

.VALUE _follow_path

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "follow_path",3007,"_follow_path"

.LINE 3007

.DEFINE "dp"

.CLASS 65

.VALUE 6

.TAG "NONAME3"

.TYPE 40

.ENDEF

.DEFINE "path"

.CLASS 65

.VALUE 9

.TYPE 194

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "ns"

.CLASS 65

.VALUE -4

.TYPE 12

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -7

.TAG "NONAME0"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF3
	LD	SP,HL
; 3008		FRESULT res;
; 3009		BYTE ns;
; 3010		FATFS *fs = dp->obj.fs;
.LINE 3010

	LD	IY,(IX+%6)
	LD	BC,(IY+%0)
	LD	(IX+%FFFFFFF9),BC
; 3011	
; 3012	
; 3013	#if FF_FS_RPATH != 0
; 3014		if (!IsSeparator(*path) && (FF_STR_VOLUME_ID != 2 || !IsTerminator(*path))) {	/* Without heading separator */
.LINE 3014

	LD	HL,(IX+%9)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,47
	OR	A,A
	SBC	HL,BC
	JR	Z,L_376
	LD	HL,(IX+%9)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,92
	OR	A,A
	SBC	HL,BC
	JR	Z,L_376
; 3015			dp->obj.sclust = fs->cdir;			/* Start at the current directory */
.LINE 3015

	LD	IY,(IX+%FFFFFFF9)
	LD	BC,(IY+%E)
	LD	A,(IY+%11)
	LD	IY,(IX+%6)
	LD	(IY+%7),BC
	LD	(IY+%A),A
; 3016		} else
.LINE 3016

	JR	L_400
; 3017	#endif
; 3018		{										/* With heading separator */
; 3019			while (IsSeparator(*path)) path++;	/* Strip separators */
L_377:
.LINE 3019

	LD	BC,(IX+%9)
	LD	(IX+%FFFFFFF3),BC
	LD	BC,(IX+%9)
	INC	BC
	LD	(IX+%9),BC
L_376:
	LD	HL,(IX+%9)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,47
	OR	A,A
	SBC	HL,BC
	JR	Z,L_377
	LD	HL,(IX+%9)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,92
	OR	A,A
	SBC	HL,BC
	JR	Z,L_377
; 3020			dp->obj.sclust = 0;					/* Start from the root directory */
.LINE 3020

	LD	BC,0
	LD	IY,(IX+%6)
	LD	(IY+%7),BC
	LD	(IY+%A),%0
; 3021		}
L_400:
.LINE 3021

; 3022	#if FF_FS_EXFAT
; 3023		dp->obj.n_frag = 0;	/* Invalidate last fragment counter of the object */
; 3024	#if FF_FS_RPATH != 0
; 3025		if (fs->fs_type == FS_EXFAT && dp->obj.sclust) {	/* exFAT: Retrieve the sub-directory's status */
; 3026			DIR dj;
; 3027	
; 3028			dp->obj.c_scl = fs->cdc_scl;
; 3029			dp->obj.c_size = fs->cdc_size;
; 3030			dp->obj.c_ofs = fs->cdc_ofs;
; 3031			res = load_obj_xdir(&dj, &dp->obj);
; 3032			if (res != FR_OK) return res;
; 3033			dp->obj.objsize = ld_dword(fs->dirbuf + XDIR_FileSize);
; 3034			dp->obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
; 3035		}
; 3036	#endif
; 3037	#endif
; 3038	
; 3039		if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
.LINE 3039

	LD	HL,(IX+%9)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,32
	OR	A,A
	SBC	HL,BC
	JR	NC,L_396
; 3040			dp->fn[NSFLAG] = NS_NONAME;
.LINE 3040

	LD	IY,(IX+%6)
	LEA	HL,IY+%29
	LD	(HL),%80
; 3041			res = dir_sdi(dp, 0);
.LINE 3041

	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_dir_sdi
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 3042	
; 3043		} else {								/* Follow path */
.LINE 3043

	JR	L_401
; 3044			for (;;) {
L_396:
.LINE 3044

; 3045				res = create_name(dp, &path);	/* Get a segment name of the path */
.LINE 3045

	PEA	IX+%9
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_create_name
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 3046				if (res != FR_OK) break;
.LINE 3046

	CALL	__icmpzero
	JR	NZ,L_401
; 3047				res = dir_find(dp);				/* Find an object with the segment name */
.LINE 3047

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_dir_find
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 3048				ns = dp->fn[NSFLAG];
.LINE 3048

	LD	IY,(IX+%6)
	LEA	IY,IY+%29
	LD	(IX+%FFFFFFF6),IY
	LD	HL,(IX+%FFFFFFF6)
	LD	A,(HL)
	LD	(IX+%FFFFFFFC),A
; 3049				if (res != FR_OK) {				/* Failed to find the object */
.LINE 3049

	LD	HL,(IX+%FFFFFFFD)
	CALL	__icmpzero
	JR	Z,L_392
; 3050					if (res == FR_NO_FILE) {	/* Object is not found */
.LINE 3050

	LD	BC,4
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_401
; 3051						if (FF_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, stay there */
.LINE 3051

	LD	A,(IX+%FFFFFFFC)
	AND	A,%20
	JR	Z,L_387
; 3052							if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
.LINE 3052

	LD	A,(IX+%FFFFFFFC)
	AND	A,%4
	JR	Z,L_396
; 3053							dp->fn[NSFLAG] = NS_NONAME;
.LINE 3053

	LD	HL,(IX+%FFFFFFF6)
	LD	(HL),%80
; 3054							res = FR_OK;
.LINE 3054

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
; 3055						} else {							/* Could not find the object */
.LINE 3055

	JR	L_401
L_387:
; 3056							if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
.LINE 3056

	LD	A,(IX+%FFFFFFFC)
	AND	A,%4
	JR	NZ,L_401
	LD	BC,5
	LD	(IX+%FFFFFFFD),BC
; 3057						}
; 3058					}
.LINE 3058

; 3059					break;
.LINE 3059

	JR	L_401
; 3060				}
L_392:
.LINE 3060

; 3061				if (ns & NS_LAST) break;		/* Last segment matched. Function completed. */
.LINE 3061

	LD	A,(IX+%FFFFFFFC)
	AND	A,%4
	JR	NZ,L_401
; 3062				/* Get into the sub-directory */
; 3063				if (!(dp->obj.attr & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
.LINE 3063

	LD	IY,(IX+%6)
	LD	A,(IY+%5)
	AND	A,%10
	JR	NZ,L_395
; 3064					res = FR_NO_PATH; break;
.LINE 3064

	LD	BC,5
	LD	(IX+%FFFFFFFD),BC
	JR	L_401
; 3065				}
L_395:
.LINE 3065

; 3066	#if FF_FS_EXFAT
; 3067				if (fs->fs_type == FS_EXFAT) {	/* Save containing directory information for next dir */
; 3068					dp->obj.c_scl = dp->obj.sclust;
; 3069					dp->obj.c_size = ((DWORD)dp->obj.objsize & 0xFFFFFF00) | dp->obj.stat;
; 3070					dp->obj.c_ofs = dp->blk_ofs;
; 3071					init_alloc_info(fs, &dp->obj);	/* Open next directory */
; 3072				} else
; 3073	#endif
; 3074				{
; 3075					dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
.LINE 3075

	LD	IY,(IX+%6)
	LD	HL,(IY+%F)
	LD	E,(IY+%12)
	LD	BC,511
	XOR	A,A
	CALL	__land
	LD	BC,HL
	LD	IY,(IX+%FFFFFFF9)
	LEA	HL,IY+%2E
	ADD	HL,BC
	PUSH	HL
	LD	BC,(IX+%FFFFFFF9)
	PUSH	BC
	CALL	_ld_clust
	POP	BC
	POP	BC
	LD	IY,(IX+%6)
	LD	(IY+%7),HL
	LD	(IY+%A),E
; 3076				}
; 3077			}
.LINE 3077

	JR	L_396
; 3078		}
L_401:
.LINE 3078

; 3079	
; 3080		return res;
.LINE 3080

	LD	HL,(IX+%FFFFFFFD)
; 3081	}
.LINE 3081

	LD	SP,IX
	POP	IX
	RET	


;**************************** _follow_path ***************************
;Name                         Addr/Register   Size   Type
;G_22                                 IX-10      3   variable
;fs                                    IX-7      3   variable
;ns                                    IX-4      1   variable
;res                                   IX-3      3   variable
;path                                  IX+9      3   parameter
;dp                                    IX+6      3   parameter


; Stack Frame Size: 25 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "follow_path",3081,"_follow_path"
; 3082	
; 3083	
; 3084	
; 3085	
; 3086	/*-----------------------------------------------------------------------*/
; 3087	/* Get logical drive number from path name                               */
; 3088	/*-----------------------------------------------------------------------*/
; 3089	
; 3090	static int get_ldnumber (	/* Returns logical drive number (-1:invalid drive number or null pointer) */
; 3091		const TCHAR** path		/* Pointer to pointer to the path name */
; 3092	)
; 3093	{
_get_ldnumber:
.DEFINE "_get_ldnumber"

.VALUE _get_ldnumber

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "get_ldnumber",3093,"_get_ldnumber"

.LINE 3093

.DEFINE "path"

.CLASS 65

.VALUE 6

.TYPE 1570

.ENDEF

.DEFINE "tp"

.CLASS 65

.VALUE -3

.TYPE 194

.ENDEF

.DEFINE "tt"

.CLASS 65

.VALUE -6

.TYPE 194

.ENDEF

.DEFINE "tc"

.CLASS 65

.VALUE -7

.TYPE 2

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -10

.TYPE 4

.ENDEF

.DEFINE "vol"

.CLASS 65

.VALUE -13

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF0
	LD	SP,HL
; 3094		const TCHAR *tp, *tt;
; 3095		TCHAR tc;
; 3096		int i;
; 3097		int vol = -1;
.LINE 3097

	LD	BC,16777215
	LD	(IX+%FFFFFFF3),BC
; 3098	#if FF_STR_VOLUME_ID		/* Find string volume ID */
; 3099		const char *sp;
; 3100		char c;
; 3101	#endif
; 3102	
; 3103		tt = tp = *path;
.LINE 3103

	LD	HL,(IX+%6)
	LD	BC,(HL)
	LD	(IX+%FFFFFFFD),BC
	LD	(IX+%FFFFFFFA),BC
; 3104		if (!tp) return vol;	/* Invalid path name? */
.LINE 3104

	LD	HL,BC
	CALL	__icmpzero
	JR	NZ,L_406
	LD	HL,16777215
	JR	L_418
; 3105		do tc = *tt++; while (!IsTerminator(tc) && tc != ':');	/* Find a colon in the path */
L_406:
.LINE 3105

	LD	BC,(IX+%FFFFFFFA)
	LD	(IX+%FFFFFFF0),BC
	LD	HL,BC
	LD	A,(HL)
	LD	(IX+%FFFFFFF9),A
	LD	BC,(IX+%FFFFFFFA)
	INC	BC
	LD	(IX+%FFFFFFFA),BC
	LD	A,(IX+%FFFFFFF9)
	CP	A,%20
	JR	C,L_416
	LD	A,(IX+%FFFFFFF9)
	CP	A,%3A
	JR	NZ,L_406
L_416:
; 3106	
; 3107		if (tc == ':') {	/* DOS/Windows style volume ID? */
.LINE 3107

	LD	A,(IX+%FFFFFFF9)
	CP	A,%3A
	JR	NZ,L_417
; 3108			i = FF_VOLUMES;
.LINE 3108

	LD	BC,1
	LD	(IX+%FFFFFFF6),BC
; 3109			if (IsDigit(*tp) && tp + 2 == tt) {	/* Is there a numeric volume ID + colon? */
.LINE 3109

	LD	HL,(IX+%FFFFFFFD)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,48
	OR	A,A
	SBC	HL,BC
	JP	M,L_413
	LD	HL,(IX+%FFFFFFFD)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,HL
	LD	HL,57
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_413
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%2
	LD	BC,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_413
; 3110				i = (int)*tp - '0';	/* Get the LD number */
.LINE 3110

	LD	HL,(IX+%FFFFFFFD)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	IY,HL
	LEA	IY,IY+%FFFFFFD0
	LD	(IX+%FFFFFFF6),IY
; 3111			}
L_413:
.LINE 3111

; 3112	#if FF_STR_VOLUME_ID == 1	/* Arbitrary string is enabled */
; 3113			else {
; 3114				i = 0;
; 3115				do {
; 3116					sp = VolumeStr[i]; tp = *path;	/* This string volume ID and path name */
; 3117					do {	/* Compare the volume ID with path name */
; 3118						c = *sp++; tc = *tp++;
; 3119						if (IsLower(c)) c -= 0x20;
; 3120						if (IsLower(tc)) tc -= 0x20;
; 3121					} while (c && (TCHAR)c == tc);
; 3122				} while ((c || tp != tt) && ++i < FF_VOLUMES);	/* Repeat for each id until pattern match */
; 3123			}
; 3124	#endif
; 3125			if (i < FF_VOLUMES) {	/* If a volume ID is found, get the drive number and strip it */
.LINE 3125

	LD	BC,1
	LD	HL,(IX+%FFFFFFF6)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_414
; 3126				vol = i;		/* Drive number */
.LINE 3126

	LD	BC,(IX+%FFFFFFF6)
	LD	(IX+%FFFFFFF3),BC
; 3127				*path = tt;		/* Snip the drive prefix off */
.LINE 3127

	LD	HL,(IX+%6)
	LD	BC,(IX+%FFFFFFFA)
	LD	(HL),BC
; 3128			}
L_414:
.LINE 3128

; 3129			return vol;
.LINE 3129

	LD	HL,(IX+%FFFFFFF3)
	JR	L_418
; 3130		}
L_417:
.LINE 3130

; 3131	#if FF_STR_VOLUME_ID == 2		/* Unix style volume ID is enabled */
; 3132		if (*tp == '/') {			/* Is there a volume ID? */
; 3133			while (*(tp + 1) == '/') tp++;	/* Skip duplicated separator */
; 3134			i = 0;
; 3135			do {
; 3136				tt = tp; sp = VolumeStr[i]; /* Path name and this string volume ID */
; 3137				do {	/* Compare the volume ID with path name */
; 3138					c = *sp++; tc = *(++tt);
; 3139					if (IsLower(c)) c -= 0x20;
; 3140					if (IsLower(tc)) tc -= 0x20;
; 3141				} while (c && (TCHAR)c == tc);
; 3142			} while ((c || (tc != '/' && !IsTerminator(tc))) && ++i < FF_VOLUMES);	/* Repeat for each ID until pattern match */
; 3143			if (i < FF_VOLUMES) {	/* If a volume ID is found, get the drive number and strip it */
; 3144				vol = i;		/* Drive number */
; 3145				*path = tt;		/* Snip the drive prefix off */
; 3146			}
; 3147			return vol;
; 3148		}
; 3149	#endif
; 3150		/* No drive prefix is found */
; 3151	#if FF_FS_RPATH != 0
; 3152		vol = CurrVol;	/* Default drive is current drive */
.LINE 3152

	LD	A,(_CurrVol)
	UEXT	HL
	LD	L,A
	LD	(IX+%FFFFFFF3),HL
; 3153	#else
; 3154		vol = 0;		/* Default drive is 0 */
; 3155	#endif
; 3156		return vol;		/* Return the default drive */
.LINE 3156

	LD	A,(_CurrVol)
	UEXT	HL
	LD	L,A
; 3157	}
L_418:
.LINE 3157

	LD	SP,IX
	POP	IX
	RET	


;**************************** _get_ldnumber ***************************
;Name                         Addr/Register   Size   Type
;_CurrVol                            STATIC      1   variable
;vol                                  IX-13      3   variable
;i                                    IX-10      3   variable
;tc                                    IX-7      1   variable
;tt                                    IX-6      3   variable
;tp                                    IX-3      3   variable
;path                                  IX+6      3   parameter


; Stack Frame Size: 25 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "get_ldnumber",3157,"_get_ldnumber"
; 3158	
; 3159	
; 3160	
; 3161	
; 3162	/*-----------------------------------------------------------------------*/
; 3163	/* GPT support functions                                                 */
; 3164	/*-----------------------------------------------------------------------*/
; 3165	
; 3166	#if FF_LBA64
; 3167	
; 3168	/* Calculate CRC32 in byte-by-byte */
; 3169	
; 3170	static DWORD crc32 (	/* Returns next CRC value */
; 3171		DWORD crc,			/* Current CRC value */
; 3172		BYTE d				/* A byte to be processed */
; 3173	)
; 3174	{
; 3175		BYTE b;
; 3176	
; 3177	
; 3178		for (b = 1; b; b <<= 1) {
; 3179			crc ^= (d & b) ? 1 : 0;
; 3180			crc = (crc & 1) ? crc >> 1 ^ 0xEDB88320 : crc >> 1;
; 3181		}
; 3182		return crc;
; 3183	}
; 3184	
; 3185	
; 3186	/* Check validity of GPT header */
; 3187	
; 3188	static int test_gpt_header (	/* 0:Invalid, 1:Valid */
; 3189		const BYTE* gpth			/* Pointer to the GPT header */
; 3190	)
; 3191	{
; 3192		UINT i;
; 3193		DWORD bcc;
; 3194	
; 3195	
; 3196		if (memcmp(gpth + GPTH_Sign, "EFI PART" "\0\0\1\0" "\x5C\0\0", 16)) return 0;	/* Check sign, version (1.0) and length (92) */
; 3197		for (i = 0, bcc = 0xFFFFFFFF; i < 92; i++) {		/* Check header BCC */
; 3198			bcc = crc32(bcc, i - GPTH_Bcc < 4 ? 0 : gpth[i]);
; 3199		}
; 3200		if (~bcc != ld_dword(gpth + GPTH_Bcc)) return 0;
; 3201		if (ld_dword(gpth + GPTH_PteSize) != SZ_GPTE) return 0;	/* Table entry size (must be SZ_GPTE bytes) */
; 3202		if (ld_dword(gpth + GPTH_PtNum) > 128) return 0;	/* Table size (must be 128 entries or less) */
; 3203	
; 3204		return 1;
; 3205	}
; 3206	
; 3207	#if !FF_FS_READONLY && FF_USE_MKFS
; 3208	
; 3209	/* Generate random value */
; 3210	static DWORD make_rand (
; 3211		DWORD seed,		/* Seed value */
; 3212		BYTE* buff,		/* Output buffer */
; 3213		UINT n			/* Data length */
; 3214	)
; 3215	{
; 3216		UINT r;
; 3217	
; 3218	
; 3219		if (seed == 0) seed = 1;
; 3220		do {
; 3221			for (r = 0; r < 8; r++) seed = seed & 1 ? seed >> 1 ^ 0xA3000000 : seed >> 1;	/* Shift 8 bits the 32-bit LFSR */
; 3222			*buff++ = (BYTE)seed;
; 3223		} while (--n);
; 3224		return seed;
; 3225	}
; 3226	
; 3227	#endif
; 3228	#endif
; 3229	
; 3230	
; 3231	
; 3232	/*-----------------------------------------------------------------------*/
; 3233	/* Load a sector and check if it is an FAT VBR                           */
; 3234	/*-----------------------------------------------------------------------*/
; 3235	
; 3236	/* Check what the sector is */
; 3237	
; 3238	static UINT check_fs (	/* 0:FAT/FAT32 VBR, 1:exFAT VBR, 2:Not FAT and valid BS, 3:Not FAT and invalid BS, 4:Disk error */
; 3239		FATFS* fs,			/* Filesystem object */
; 3240		LBA_t sect			/* Sector to load and check if it is an FAT-VBR or not */
; 3241	)
; 3242	{
_check_fs:
.DEFINE "_check_fs"

.VALUE _check_fs

.CLASS 3

.TYPE 78

.ENDEF

.BEGFUNC "check_fs",3242,"_check_fs"

.LINE 3242

.DEFINE "fs"

.CLASS 65

.VALUE 6

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "sect"

.CLASS 65

.VALUE 9

.TYPE 15

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE -4

.TYPE 12

.ENDEF

.DEFINE "w"

.CLASS 65

.VALUE -9

.TYPE 13

.ENDEF

.DEFINE "sign"

.CLASS 65

.VALUE -11

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFEC
	LD	SP,HL
; 3243		WORD w, sign;
; 3244		BYTE b;
; 3245	
; 3246	
; 3247		fs->wflag = 0; fs->winsect = (LBA_t)0 - 1;		/* Invaidate window */
.LINE 3247

	LD	IY,(IX+%6)
	LD	(IY+%3),%0
	LD	BC,16777215
	LD	(IY+%2A),BC
	LD	(IY+%2D),%FF
; 3248		if (move_window(fs, sect) != FR_OK) return 4;	/* Load the boot sector */
.LINE 3248

	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%9)
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_move_window
	POP	BC
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	Z,L_420
	LD	HL,4
	JR	L_443
L_420:
; 3249		sign = ld_word(fs->win + BS_55AA);
.LINE 3249

	LD	IY,(IX+%6)
	LEA	BC,IY+%2E
	LD	(IX+%FFFFFFF9),BC
	LD	(IX+%FFFFFFEF),BC
	LD	BC,510
	LD	HL,(IX+%FFFFFFF9)
	ADD	HL,BC
	PUSH	HL
	CALL	_ld_word
	POP	BC
	LD	(IX+%FFFFFFF5),L
	LD	(IX+%FFFFFFF6),H
; 3250	#if FF_FS_EXFAT
; 3251		if (sign == 0xAA55 && !memcmp(fs->win + BS_JmpBoot, "\xEB\x76\x90" "EXFAT   ", 11)) return 1;	/* It is an exFAT VBR */
; 3252	#endif
; 3253		b = fs->win[BS_JmpBoot];
.LINE 3253

	LD	HL,(IX+%FFFFFFF9)
	LD	A,(HL)
	LD	(IX+%FFFFFFFC),A
; 3254		if (b == 0xEB || b == 0xE9 || b == 0xE8) {	/* Valid JumpBoot code? (short jump, near jump or near call) */
.LINE 3254

	CP	A,%EB
	JR	Z,L_437
	LD	A,(IX+%FFFFFFFC)
	CP	A,%E9
	JR	Z,L_437
	LD	A,(IX+%FFFFFFFC)
	CP	A,%E8
	JR	NZ,L_442
L_437:
; 3255			if (sign == 0xAA55 && !memcmp(fs->win + BS_FilSysType32, "FAT32   ", 8)) {
.LINE 3255

	LD.LIS	BC,43605
	LD	HL,(IX+%FFFFFFF5)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_425
	LD	BC,(IX+%FFFFFFF9)
	LD	(IX+%FFFFFFEF),BC
	LD	BC,8
	PUSH	BC
	LD	BC,L__220
	PUSH	BC
	LD	IY,(IX+%FFFFFFF9)
	LEA	BC,IY+%52
	PUSH	BC
	CALL	_memcmp
	POP	BC
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_425
; 3256				return 0;	/* It is an FAT32 VBR */
.LINE 3256

	OR	A,A
	SBC	HL,HL
	JR	L_443
; 3257			}
L_425:
.LINE 3257

; 3258			/* FAT volumes formatted with early MS-DOS lack BS_55AA and BS_FilSysType, so FAT VBR needs to be identified without them. */
; 3259			w = ld_word(fs->win + BPB_BytsPerSec);
.LINE 3259

	LD	BC,(IX+%FFFFFFEF)
	LD	(IX+%FFFFFFFD),BC
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%B
	PUSH	BC
	CALL	_ld_word
	POP	BC
	LD	(IX+%FFFFFFF7),L
	LD	(IX+%FFFFFFF8),H
; 3260			b = fs->win[BPB_SecPerClus];
.LINE 3260

	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%D
	LD	A,(HL)
	LD	(IX+%FFFFFFFC),A
; 3261			if ((w & (w - 1)) == 0 && w >= FF_MIN_SS && w <= FF_MAX_SS	/* Properness of sector size (512-4096 and 2^n) */
.LINE 3261

	LD	BC,(IX+%FFFFFFF7)
	CALL	__stoiu
	DEC	HL
	LD	BC,(IX+%FFFFFFF7)
	CALL	__sand
	CALL	__scmpzero
	JR	NZ,L_442
	LD.LIS	BC,512
	LD	HL,(IX+%FFFFFFF7)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_442
; 3262				&& b != 0 && (b & (b - 1)) == 0				/* Properness of cluster size (2^n) */
.LINE 3262

	LD	BC,(IX+%FFFFFFF7)
	LD.LIS	HL,512
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_442
	LD	A,(IX+%FFFFFFFC)
	OR	A,A
	JR	Z,L_442
; 3263				&& ld_word(fs->win + BPB_RsvdSecCnt) != 0	/* Properness of reserved sectors (MNBZ) */
.LINE 3263

	LD	A,(IX+%FFFFFFFC)
	UEXT	HL
	LD	L,A
	DEC	HL
	LD	A,L
	AND	A,(IX+%FFFFFFFC)
	JR	NZ,L_442
; 3264				&& (UINT)fs->win[BPB_NumFATs] - 1 <= 1		/* Properness of FATs (1 or 2) */
.LINE 3264

	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%E
	PUSH	BC
	CALL	_ld_word
	POP	BC
	CALL	__scmpzero
	JR	Z,L_442
; 3265				&& ld_word(fs->win + BPB_RootEntCnt) != 0	/* Properness of root dir entries (MNBZ) */
.LINE 3265

	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%10
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	DEC	BC
	LD	HL,1
	OR	A,A
	SBC	HL,BC
	JR	C,L_442
; 3266				&& (ld_word(fs->win + BPB_TotSec16) >= 128 || ld_dword(fs->win + BPB_TotSec32) >= 0x10000)	/* Properness of volume sectors (>=128) */
.LINE 3266

	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%11
	PUSH	BC
	CALL	_ld_word
	POP	BC
	CALL	__scmpzero
	JR	Z,L_442
	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFEC),BC
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%13
	PUSH	BC
	CALL	_ld_word
	POP	BC
	LD	BC,HL
	CALL	__stoiu
	LD	BC,128
	OR	A,A
	SBC	HL,BC
	JP	P,L_435
	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFEC),BC
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%20
	PUSH	BC
	CALL	_ld_dword
	POP	BC
	LD	BC,65536
	XOR	A,A
	CALL	__lcmpu
	JR	C,L_442
; 3267				&& ld_word(fs->win + BPB_FATSz16) != 0) {	/* Properness of FAT size (MNBZ) */
L_435:
.LINE 3267

	LD	IY,(IX+%FFFFFFEC)
	LEA	BC,IY+%16
	PUSH	BC
	CALL	_ld_word
	POP	BC
	CALL	__scmpzero
	JR	Z,L_442
; 3268					return 0;	/* It can be presumed an FAT VBR */
.LINE 3268

	OR	A,A
	SBC	HL,HL
	JR	L_443
; 3269			}
; 3270		}
L_442:
.LINE 3270

; 3271		return sign == 0xAA55 ? 2 : 3;	/* Not an FAT VBR (valid or invalid BS) */
.LINE 3271

	LD.LIS	BC,43605
	LD	HL,(IX+%FFFFFFF5)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_440
	LD	BC,2
	LD	(IX+%FFFFFFF2),BC
	JR	L_441
L_440:
	LD	BC,3
	LD	(IX+%FFFFFFF2),BC
L_441:
	LD	HL,(IX+%FFFFFFF2)
; 3272	}
L_443:
.LINE 3272

	LD	SP,IX
	POP	IX
	RET	


;**************************** _check_fs ***************************
;Name                         Addr/Register   Size   Type
;_memcmp                             IMPORT  -----   function
;G_31                                 IX-20      3   variable
;G_25                                 IX-17      3   variable
;temp438                              IX-14      3   variable
;sign                                 IX-11      2   variable
;w                                     IX-9      2   variable
;G_24                                  IX-7      3   variable
;b                                     IX-4      1   variable
;G_26                                  IX-3      3   variable
;sect                                  IX+9      4   parameter
;fs                                    IX+6      3   parameter


; Stack Frame Size: 35 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "check_fs",3272,"_check_fs"
	SEGMENT STRSECT
L__220:
	DB	"FAT32   "
	DB	0
	SEGMENT CODE
; 3273	
; 3274	
; 3275	/* Find an FAT volume */
; 3276	/* (It supports only generic partitioning rules, MBR, GPT and SFD) */
; 3277	
; 3278	static UINT find_volume (	/* Returns BS status found in the hosting drive */
; 3279		FATFS* fs,		/* Filesystem object */
; 3280		UINT part		/* Partition to fined = 0:auto, 1..:forced */
; 3281	)
; 3282	{
_find_volume:
.DEFINE "_find_volume"

.VALUE _find_volume

.CLASS 3

.TYPE 78

.ENDEF

.BEGFUNC "find_volume",3282,"_find_volume"

.LINE 3282

.DEFINE "fs"

.CLASS 65

.VALUE 6

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "part"

.CLASS 65

.VALUE 9

.TYPE 14

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -3

.TYPE 14

.ENDEF

.DEFINE "fmt"

.CLASS 65

.VALUE -6

.TYPE 14

.ENDEF

.DEFINE "mbr_pt"

.CLASS 65

.VALUE -31

.DIM 4

.TYPE 111

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFDB
	LD	SP,HL
; 3283		UINT fmt, i;
; 3284		DWORD mbr_pt[4];
; 3285	
; 3286	
; 3287		fmt = check_fs(fs, 0);				/* Load sector 0 and check if it is an FAT VBR as SFD format */
.LINE 3287

	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_check_fs
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFA),HL
; 3288		if (fmt != 2 && (fmt >= 3 || part == 0)) return fmt;	/* Returns if it is an FAT VBR as auto scan, not a BS or disk error */
.LINE 3288

	LD	BC,2
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_453
	LD	BC,3
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_446
	LD	HL,(IX+%9)
	CALL	__icmpzero
	JR	NZ,L_453
L_446:
	LD	HL,(IX+%FFFFFFFA)
	JR	L_468
; 3289	
; 3290		/* Sector 0 is not an FAT VBR or forced partition number wants a partition */
; 3291	
; 3292	#if FF_LBA64
; 3293		if (fs->win[MBR_Table + PTE_System] == 0xEE) {	/* GPT protective MBR? */
; 3294			DWORD n_ent, v_ent, ofs;
; 3295			QWORD pt_lba;
; 3296	
; 3297			if (move_window(fs, 1) != FR_OK) return 4;	/* Load GPT header sector (next to MBR) */
; 3298			if (!test_gpt_header(fs->win)) return 3;	/* Check if GPT header is valid */
; 3299			n_ent = ld_dword(fs->win + GPTH_PtNum);		/* Number of entries */
; 3300			pt_lba = ld_qword(fs->win + GPTH_PtOfs);	/* Table location */
; 3301			for (v_ent = i = 0; i < n_ent; i++) {		/* Find FAT partition */
; 3302				if (move_window(fs, pt_lba + i * SZ_GPTE / SS(fs)) != FR_OK) return 4;	/* PT sector */
; 3303				ofs = i * SZ_GPTE % SS(fs);												/* Offset in the sector */
; 3304				if (!memcmp(fs->win + ofs + GPTE_PtGuid, GUID_MS_Basic, 16)) {	/* MS basic data partition? */
; 3305					v_ent++;
; 3306					fmt = check_fs(fs, ld_qword(fs->win + ofs + GPTE_FstLba));	/* Load VBR and check status */
; 3307					if (part == 0 && fmt <= 1) return fmt;			/* Auto search (valid FAT volume found first) */
; 3308					if (part != 0 && v_ent == part) return fmt;		/* Forced partition order (regardless of it is valid or not) */
; 3309				}
; 3310			}
; 3311			return 3;	/* Not found */
; 3312		}
; 3313	#endif
; 3314		if (FF_MULTI_PARTITION && part > 4) return 3;	/* MBR has 4 partitions max */
L_453:
.LINE 3314

; 3315		for (i = 0; i < 4; i++) {		/* Load partition offset in the MBR */
.LINE 3315

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	JR	L_452
L_450:
; 3316			mbr_pt[i] = ld_dword(fs->win + MBR_Table + i * SZ_PTE + PTE_StLba);
.LINE 3316

	LD	BC,446
	LD	IY,(IX+%6)
	LEA	HL,IY+%2E
	ADD	HL,BC
	LD	BC,HL
	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	IY,HL
	LEA	BC,IY+%8
	PUSH	BC
	CALL	_ld_dword
	POP	BC
	LD	BC,HL
	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	(IX+%FFFFFFDE),BC	; spill
	LEA	BC,IX+%FFFFFFE1
	LD	(IX+%FFFFFFDB),BC	; spill
	LD	BC,(IX+%FFFFFFDE)	; unspill
	LD	(IX+%FFFFFFDE),BC	; spill
	LD	BC,(IX+%FFFFFFDB)	; unspill
	ADD	HL,BC
	LD	BC,(IX+%FFFFFFDE)	; unspill
	LD	IY,HL
	LD	(IY),BC
	LD	(IY+%3),E
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
; 3317		}
L_452:
.LINE 3317

	LD	BC,4
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	C,L_450
; 3318		i = part ? part - 1 : 0;		/* Table index to find first */
.LINE 3318

	LD	HL,(IX+%9)
	CALL	__icmpzero
	JR	Z,L_456
	LD	IY,(IX+%9)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%FFFFFFF7),IY
	JR	L_457
L_456:
	LD	BC,0
	LD	(IX+%FFFFFFF7),BC
L_457:
	LD	BC,(IX+%FFFFFFF7)
	LD	(IX+%FFFFFFFD),BC
; 3319		do {							/* Find an FAT volume */
L_465:
.LINE 3319

; 3320			fmt = mbr_pt[i] ? check_fs(fs, mbr_pt[i]) : 3;	/* Check if the partition is FAT */
.LINE 3320

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LEA	HL,IX+%FFFFFFE1
	ADD	HL,BC
	LD	(IX+%FFFFFFF1),HL
	LD	IY,(IX+%FFFFFFF1)
	LD	HL,(IY)
	LD	E,(IY+%3)
	CALL	__lcmpzero
	JR	Z,L_461
	LD	IY,(IX+%FFFFFFF1)
	LD	BC,(IY)
	LD	A,(IY+%3)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_check_fs
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFF4),HL
	JR	L_462
L_461:
	LD	BC,3
	LD	(IX+%FFFFFFF4),BC
L_462:
	LD	BC,(IX+%FFFFFFF4)
	LD	(IX+%FFFFFFFA),BC
; 3321		} while (part == 0 && fmt >= 2 && ++i < 4);
.LINE 3321

	LD	HL,(IX+%9)
	CALL	__icmpzero
	JR	NZ,L_467
	LD	BC,2
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	C,L_467
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	BC,4
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	C,L_465
L_467:
; 3322		return fmt;
.LINE 3322

	LD	HL,(IX+%FFFFFFFA)
; 3323	}
L_468:
.LINE 3323

	LD	SP,IX
	POP	IX
	RET	


;**************************** _find_volume ***************************
;Name                         Addr/Register   Size   Type
;mbr_pt                               IX-31     16   variable
;G_32                                 IX-15      3   variable
;temp459                              IX-12      3   variable
;temp454                               IX-9      3   variable
;fmt                                   IX-6      3   variable
;i                                     IX-3      3   variable
;part                                  IX+9      3   parameter
;fs                                    IX+6      3   parameter


; Stack Frame Size: 49 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "find_volume",3323,"_find_volume"
; 3324	
; 3325	
; 3326	
; 3327	
; 3328	/*-----------------------------------------------------------------------*/
; 3329	/* Determine logical drive number and mount the volume if needed         */
; 3330	/*-----------------------------------------------------------------------*/
; 3331	
; 3332	static FRESULT mount_volume (	/* FR_OK(0): successful, !=0: an error occurred */
; 3333		const TCHAR** path,			/* Pointer to pointer to the path name (drive number) */
; 3334		FATFS** rfs,				/* Pointer to pointer to the found filesystem object */
; 3335		BYTE mode					/* !=0: Check write protection for write access */
; 3336	)
; 3337	{
_mount_volume:
.DEFINE "_mount_volume"

.VALUE _mount_volume

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "mount_volume",3337,"_mount_volume"

.LINE 3337

.DEFINE "path"

.CLASS 65

.VALUE 6

.TYPE 1570

.ENDEF

.DEFINE "rfs"

.CLASS 65

.VALUE 9

.TAG "NONAME0"

.TYPE 296

.ENDEF

.DEFINE "mode"

.CLASS 65

.VALUE 12

.TYPE 12

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -3

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "fmt"

.CLASS 65

.VALUE -6

.TYPE 14

.ENDEF

.DEFINE "fasize"

.CLASS 65

.VALUE -10

.TYPE 15

.ENDEF

.DEFINE "stat"

.CLASS 65

.VALUE -12

.TYPE 12

.ENDEF

.DEFINE "nclst"

.CLASS 65

.VALUE -22

.TYPE 15

.ENDEF

.DEFINE "nrsv"

.CLASS 65

.VALUE -24

.TYPE 13

.ENDEF

.DEFINE "vol"

.CLASS 65

.VALUE -30

.TYPE 4

.ENDEF

.DEFINE "tsect"

.CLASS 65

.VALUE -34

.TYPE 15

.ENDEF

.DEFINE "sysect"

.CLASS 65

.VALUE -38

.TYPE 15

.ENDEF

.DEFINE "bsect"

.CLASS 65

.VALUE -45

.TYPE 15

.ENDEF

.DEFINE "szbfat"

.CLASS 65

.VALUE -56

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFB8
	LD	SP,HL
; 3338		int vol;
; 3339		DSTATUS stat;
; 3340		LBA_t bsect;
; 3341		DWORD tsect, sysect, fasize, nclst, szbfat;
; 3342		WORD nrsv;
; 3343		FATFS *fs;
; 3344		UINT fmt;
; 3345	
; 3346	
; 3347		/* Get logical drive number */
; 3348		*rfs = 0;
.LINE 3348

	LD	HL,(IX+%9)
	LD	BC,0
	LD	(HL),BC
; 3349		vol = get_ldnumber(path);
.LINE 3349

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_get_ldnumber
	POP	BC
	LD	(IX+%FFFFFFE2),HL
; 3350		if (vol < 0) return FR_INVALID_DRIVE;
.LINE 3350

	CALL	__icmpzero
	CALL	__setflag
	JP	P,L_470
	LD	HL,11
	JR	L_529
L_470:
; 3351	
; 3352		/* Check if the filesystem object is valid or not */
; 3353		fs = FatFs[vol];					/* Get pointer to the filesystem object */
.LINE 3353

	LD	HL,(IX+%FFFFFFE2)
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_FatFs
	ADD	HL,BC
	LD	BC,(HL)
	LD	(IX+%FFFFFFFD),BC
; 3354		if (!fs) return FR_NOT_ENABLED;		/* Is the filesystem object available? */
.LINE 3354

	LD	HL,BC
	CALL	__icmpzero
	JR	NZ,L_472
	LD	HL,12
	JR	L_529
L_472:
; 3355	#if FF_FS_REENTRANT
; 3356		if (!lock_fs(fs)) return FR_TIMEOUT;	/* Lock the volume */
; 3357	#endif
; 3358		*rfs = fs;							/* Return pointer to the filesystem object */
.LINE 3358

	LD	HL,(IX+%9)
	LD	BC,(IX+%FFFFFFFD)
	LD	(HL),BC
; 3359	
; 3360		mode &= (BYTE)~FA_READ;				/* Desired access mode, write access or not */
; 3361		if (fs->fs_type != 0) {				/* If the volume has been mounted */
.LINE 3361

	LD	IY,(IX+%FFFFFFFD)
	LD	A,(IY+%0)
	OR	A,A
	JR	Z,L_477
; 3362			stat = disk_status(fs->pdrv);
.LINE 3362

	LD	IY,(IX+%FFFFFFFD)
	LD	C,(IY+%1)
	LD	B,%0
	PUSH	BC
	CALL	_disk_status
	POP	BC
	LD	(IX+%FFFFFFF4),A
; 3363			if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
.LINE 3363

	AND	A,%1
	JR	NZ,L_477
; 3364				if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
; 3365					return FR_WRITE_PROTECTED;
; 3366				}
; 3367				return FR_OK;				/* The filesystem object is already valid */
.LINE 3367

	OR	A,A
	SBC	HL,HL
	JR	L_529
; 3368			}
; 3369		}
L_477:
.LINE 3369

; 3370	
; 3371		/* The filesystem object is not valid. */
; 3372		/* Following code attempts to mount the volume. (find an FAT volume, analyze the BPB and initialize the filesystem object) */
; 3373	
; 3374		fs->fs_type = 0;					/* Clear the filesystem object */
.LINE 3374

	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%0),%0
; 3375		fs->pdrv = LD2PD(vol);				/* Volume hosting physical drive */
.LINE 3375

	LD	A,(IX+%FFFFFFE2)
	LD	(IY+%1),A
; 3376		stat = disk_initialize(fs->pdrv);	/* Initialize the physical drive */
.LINE 3376

	LD	C,(IY+%1)
	LD	B,%0
	PUSH	BC
	CALL	_disk_initialize
	POP	BC
	LD	(IX+%FFFFFFF4),A
; 3377		if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
.LINE 3377

	AND	A,%1
	JR	Z,L_481
; 3378			return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
.LINE 3378

	LD	HL,3
	JR	L_529
; 3379		}
.LINE 3379

; 3380		if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) { /* Check disk write protection if needed */
; 3381			return FR_WRITE_PROTECTED;
; 3382		}
L_481:
.LINE 3382

; 3383	#if FF_MAX_SS != FF_MIN_SS				/* Get sector size (multiple sector size cfg only) */
; 3384		if (disk_ioctl(fs->pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK) return FR_DISK_ERR;
; 3385		if (SS(fs) > FF_MAX_SS || SS(fs) < FF_MIN_SS || (SS(fs) & (SS(fs) - 1))) return FR_DISK_ERR;
; 3386	#endif
; 3387	
; 3388		/* Find an FAT volume on the drive */
; 3389		fmt = find_volume(fs, LD2PT(vol));
.LINE 3389

	LD	BC,0
	PUSH	BC
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_find_volume
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFA),HL
; 3390		if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
.LINE 3390

	LD	BC,4
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_484
	LD	HL,1
	JR	L_529
L_484:
; 3391		if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
.LINE 3391

	LD	BC,2
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	C,L_485
	LD	HL,13
	JR	L_529
L_485:
; 3392		bsect = fs->winsect;					/* Volume offset */
.LINE 3392

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%2A)
	LD	A,(IY+%2D)
	LD	(IX+%FFFFFFD3),BC
	LD	(IX+%FFFFFFD6),A
; 3393	
; 3394		/* An FAT volume is found (bsect). Following code initializes the filesystem object */
; 3395	
; 3396	#if FF_FS_EXFAT
; 3397		if (fmt == 1) {
; 3398			QWORD maxlba;
; 3399			DWORD so, cv, bcl, i;
; 3400	
; 3401			for (i = BPB_ZeroedEx; i < BPB_ZeroedEx + 53 && fs->win[i] == 0; i++) ;	/* Check zero filler */
; 3402			if (i < BPB_ZeroedEx + 53) return FR_NO_FILESYSTEM;
; 3403	
; 3404			if (ld_word(fs->win + BPB_FSVerEx) != 0x100) return FR_NO_FILESYSTEM;	/* Check exFAT version (must be version 1.0) */
; 3405	
; 3406			if (1 << fs->win[BPB_BytsPerSecEx] != SS(fs)) {	/* (BPB_BytsPerSecEx must be equal to the physical sector size) */
; 3407				return FR_NO_FILESYSTEM;
; 3408			}
; 3409	
; 3410			maxlba = ld_qword(fs->win + BPB_TotSecEx) + bsect;	/* Last LBA of the volume + 1 */
; 3411			if (!FF_LBA64 && maxlba >= 0x100000000) return FR_NO_FILESYSTEM;	/* (It cannot be accessed in 32-bit LBA) */
; 3412	
; 3413			fs->fsize = ld_dword(fs->win + BPB_FatSzEx);	/* Number of sectors per FAT */
; 3414	
; 3415			fs->n_fats = fs->win[BPB_NumFATsEx];			/* Number of FATs */
; 3416			if (fs->n_fats != 1) return FR_NO_FILESYSTEM;	/* (Supports only 1 FAT) */
; 3417	
; 3418			fs->csize = 1 << fs->win[BPB_SecPerClusEx];		/* Cluster size */
; 3419			if (fs->csize == 0)	return FR_NO_FILESYSTEM;	/* (Must be 1..32768 sectors) */
; 3420	
; 3421			nclst = ld_dword(fs->win + BPB_NumClusEx);		/* Number of clusters */
; 3422			if (nclst > MAX_EXFAT) return FR_NO_FILESYSTEM;	/* (Too many clusters) */
; 3423			fs->n_fatent = nclst + 2;
; 3424	
; 3425			/* Boundaries and Limits */
; 3426			fs->volbase = bsect;
; 3427			fs->database = bsect + ld_dword(fs->win + BPB_DataOfsEx);
; 3428			fs->fatbase = bsect + ld_dword(fs->win + BPB_FatOfsEx);
; 3429			if (maxlba < (QWORD)fs->database + nclst * fs->csize) return FR_NO_FILESYSTEM;	/* (Volume size must not be smaller than the size requiered) */
; 3430			fs->dirbase = ld_dword(fs->win + BPB_RootClusEx);
; 3431	
; 3432			/* Get bitmap location and check if it is contiguous (implementation assumption) */
; 3433			so = i = 0;
; 3434			for (;;) {	/* Find the bitmap entry in the root directory (in only first cluster) */
; 3435				if (i == 0) {
; 3436					if (so >= fs->csize) return FR_NO_FILESYSTEM;	/* Not found? */
; 3437					if (move_window(fs, clst2sect(fs, (DWORD)fs->dirbase) + so) != FR_OK) return FR_DISK_ERR;
; 3438					so++;
; 3439				}
; 3440				if (fs->win[i] == ET_BITMAP) break;			/* Is it a bitmap entry? */
; 3441				i = (i + SZDIRE) % SS(fs);	/* Next entry */
; 3442			}
; 3443			bcl = ld_dword(fs->win + i + 20);				/* Bitmap cluster */
; 3444			if (bcl < 2 || bcl >= fs->n_fatent) return FR_NO_FILESYSTEM;	/* (Wrong cluster#) */
; 3445			fs->bitbase = fs->database + fs->csize * (bcl - 2);	/* Bitmap sector */
; 3446			for (;;) {	/* Check if bitmap is contiguous */
; 3447				if (move_window(fs, fs->fatbase + bcl / (SS(fs) / 4)) != FR_OK) return FR_DISK_ERR;
; 3448				cv = ld_dword(fs->win + bcl % (SS(fs) / 4) * 4);
; 3449				if (cv == 0xFFFFFFFF) break;				/* Last link? */
; 3450				if (cv != ++bcl) return FR_NO_FILESYSTEM;	/* Fragmented? */
; 3451			}
; 3452	
; 3453	#if !FF_FS_READONLY
; 3454			fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
; 3455	#endif
; 3456			fmt = FS_EXFAT;			/* FAT sub-type */
; 3457		} else
; 3458	#endif	/* FF_FS_EXFAT */
; 3459		{
; 3460			if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
.LINE 3460

	LEA	BC,IY+%2E
	LD	(IX+%FFFFFFEF),BC
	LD	IY,(IX+%FFFFFFEF)
	LEA	BC,IY+%B
	PUSH	BC
	CALL	_ld_word
	POP	BC
	LD	BC,HL
	CALL	__stoiu
	LD	BC,512
	OR	A,A
	SBC	HL,BC
	JR	Z,L_487
	LD	HL,13
	JR	L_529
L_487:
; 3461	
; 3462			fasize = ld_word(fs->win + BPB_FATSz16);		/* Number of sectors per FAT */
.LINE 3462

	LD	IY,(IX+%FFFFFFEF)
	LEA	BC,IY+%16
	PUSH	BC
	CALL	_ld_word
	POP	BC
	LD	BC,HL
	CALL	__stoiu
	XOR	A,A
	LD	(IX+%FFFFFFF6),HL
	LD	(IX+%FFFFFFF9),A
; 3463			if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
.LINE 3463

	LD	HL,(IX+%FFFFFFF6)
	LD	E,(IX+%FFFFFFF9)
	CALL	__lcmpzero
	JR	NZ,L_489
	LD	IY,(IX+%FFFFFFEF)
	LEA	BC,IY+%24
	PUSH	BC
	CALL	_ld_dword
	POP	BC
	LD	(IX+%FFFFFFF6),HL
	LD	(IX+%FFFFFFF9),E
L_489:
; 3464			fs->fsize = fasize;
.LINE 3464

	LD	BC,(IX+%FFFFFFF6)
	LD	A,(IX+%FFFFFFF9)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%16),BC
	LD	(IY+%19),A
; 3465	
; 3466			fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
.LINE 3466

	LD	A,(IY+%3E)
	LD	(IY+%2),A
; 3467			if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
.LINE 3467

	LD	A,(IY+%2)
	LD	(IX+%FFFFFFF5),A
	LD	(IX+%FFFFFFEE),A
	LD	A,(IX+%FFFFFFF5)
	CP	A,%1
	JR	Z,L_492
	LD	A,(IX+%FFFFFFF5)
	LD	(IX+%FFFFFFEE),A
	LD	A,(IX+%FFFFFFF5)
	CP	A,%2
	JR	Z,L_492
	LD	HL,13
	JR	L_529
L_492:
; 3468			fasize *= fs->n_fats;							/* Number of sectors for FAT area */
.LINE 3468

	UEXT	HL
	LD	L,(IX+%FFFFFFEE)
	LD	BC,HL
	LD	A,H
	LD	HL,(IX+%FFFFFFF6)
	LD	E,(IX+%FFFFFFF9)
	CALL	__lmulu
	LD	(IX+%FFFFFFF6),HL
	LD	(IX+%FFFFFFF9),E
; 3469	
; 3470			fs->csize = fs->win[BPB_SecPerClus];			/* Cluster size */
.LINE 3470

	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%3B
	LD	C,(HL)
	LD	(IY+%9),C
	LD	(IY+%A),%0
; 3471			if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
.LINE 3471

	LD	BC,(IY+%9)
	LD	(IX+%FFFFFFF2),C
	LD	(IX+%FFFFFFF3),B
	LD	HL,(IX+%FFFFFFF2)
	CALL	__scmpzero
	JR	Z,L_494
	LD	BC,(IX+%FFFFFFF2)
	CALL	__stoiu
	DEC	HL
	LD	BC,(IX+%FFFFFFF2)
	CALL	__sand
	CALL	__scmpzero
	JR	Z,L_495
L_494:
	LD	HL,13
	JR	L_529
L_495:
; 3472	
; 3473			fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
.LINE 3473

	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%3F
	PUSH	BC
	CALL	_ld_word
	POP	BC
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,HL
	LD	(IY+%7),C
	LD	(IY+%8),B
; 3474			if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
.LINE 3474

	LD	BC,(IY+%7)
	CALL	__stoiu
	LD	A,L
	AND	A,%F
	UEXT	HL
	LD	L,A
	CALL	__icmpzero
	JR	Z,L_497
	LD	HL,13
	JR	L_529
L_497:
; 3475	
; 3476			tsect = ld_word(fs->win + BPB_TotSec16);		/* Number of sectors on the volume */
.LINE 3476

	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%2E
	LD	(IX+%FFFFFFE5),BC
	LD	(IX+%FFFFFFD7),BC
	LD	IY,(IX+%FFFFFFE5)
	LEA	BC,IY+%13
	PUSH	BC
	CALL	_ld_word
	POP	BC
	LD	BC,HL
	CALL	__stoiu
	XOR	A,A
	LD	(IX+%FFFFFFDE),HL
	LD	(IX+%FFFFFFE1),A
; 3477			if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
.LINE 3477

	LD	HL,(IX+%FFFFFFDE)
	LD	E,(IX+%FFFFFFE1)
	CALL	__lcmpzero
	JR	NZ,L_499
	LD	BC,(IX+%FFFFFFE5)
	LD	(IX+%FFFFFFD7),BC
	LD	IY,(IX+%FFFFFFE5)
	LEA	BC,IY+%20
	PUSH	BC
	CALL	_ld_dword
	POP	BC
	LD	(IX+%FFFFFFDE),HL
	LD	(IX+%FFFFFFE1),E
L_499:
; 3478	
; 3479			nrsv = ld_word(fs->win + BPB_RsvdSecCnt);		/* Number of reserved sectors */
.LINE 3479

	LD	IY,(IX+%FFFFFFD7)
	LEA	BC,IY+%E
	PUSH	BC
	CALL	_ld_word
	POP	BC
	LD	(IX+%FFFFFFE8),L
	LD	(IX+%FFFFFFE9),H
; 3480			if (nrsv == 0) return FR_NO_FILESYSTEM;			/* (Must not be 0) */
.LINE 3480

	LD	HL,(IX+%FFFFFFE8)
	CALL	__scmpzero
	JR	NZ,L_501
	LD	HL,13
	JR	L_529
L_501:
; 3481	
; 3482			/* Determine the FAT sub type */
; 3483			sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
.LINE 3483

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%7)
	CALL	__stoiu
	LD	A,%4
	CALL	__ishru_b
	XOR	A,A
	LD	(IX+%FFFFFFBB),A
	LD	(IX+%FFFFFFB8),HL
	LD	BC,(IX+%FFFFFFE8)
	CALL	__stoiu
	LD	BC,HL
	XOR	A,A
	LD	HL,(IX+%FFFFFFF6)
	LD	E,(IX+%FFFFFFF9)
	CALL	__ladd
	LD	A,E
	LD	BC,HL
	LD	E,(IX+%FFFFFFBB)
	LD	HL,(IX+%FFFFFFB8)
	CALL	__ladd
	LD	(IX+%FFFFFFDA),HL
	LD	(IX+%FFFFFFDD),E
; 3484			if (tsect < sysect) return FR_NO_FILESYSTEM;	/* (Invalid volume size) */
.LINE 3484

	LD	HL,(IX+%FFFFFFDE)
	LD	E,(IX+%FFFFFFE1)
	LD	BC,(IX+%FFFFFFDA)
	LD	A,(IX+%FFFFFFDD)
	CALL	__lcmpu
	JR	NC,L_503
	LD	HL,13
	JR	L_529
L_503:
; 3485			nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
.LINE 3485

	LD	HL,(IX+%FFFFFFDE)
	LD	E,(IX+%FFFFFFE1)
	LD	BC,(IX+%FFFFFFDA)
	LD	A,(IX+%FFFFFFDD)
	CALL	__lsub
	LD	(IX+%FFFFFFBC),HL
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%9)
	CALL	__stoiu
	LD	BC,HL
	XOR	A,A
	LD	HL,(IX+%FFFFFFBC)
	CALL	__ldivu
	LD	(IX+%FFFFFFEA),HL
	LD	(IX+%FFFFFFED),E
; 3486			if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
.LINE 3486

	LD	HL,(IX+%FFFFFFEA)
	LD	E,(IX+%FFFFFFED)
	CALL	__lcmpzero
	JR	NZ,L_505
	LD	HL,13
	JR	L_529
L_505:
; 3487			fmt = 0;
.LINE 3487

	LD	BC,0
	LD	(IX+%FFFFFFFA),BC
; 3488			if (nclst <= MAX_FAT32) fmt = FS_FAT32;
.LINE 3488

	LD	HL,16777205
	LD	E,%F
	LD	BC,(IX+%FFFFFFEA)
	LD	A,(IX+%FFFFFFED)
	CALL	__lcmpu
	JR	C,L_508
	LD	BC,3
	LD	(IX+%FFFFFFFA),BC
L_508:
; 3489			if (nclst <= MAX_FAT16) fmt = FS_FAT16;
.LINE 3489

	LD	HL,65525
	LD	E,%0
	LD	BC,(IX+%FFFFFFEA)
	LD	A,(IX+%FFFFFFED)
	CALL	__lcmpu
	JR	C,L_510
	LD	BC,2
	LD	(IX+%FFFFFFFA),BC
L_510:
; 3490			if (nclst <= MAX_FAT12) fmt = FS_FAT12;
.LINE 3490

	LD	HL,4085
	LD	BC,(IX+%FFFFFFEA)
	LD	A,(IX+%FFFFFFED)
	CALL	__lcmpu
	JR	C,L_512
	LD	BC,1
	LD	(IX+%FFFFFFFA),BC
L_512:
; 3491			if (fmt == 0) return FR_NO_FILESYSTEM;
.LINE 3491

	LD	HL,(IX+%FFFFFFFA)
	CALL	__icmpzero
	JR	NZ,L_513
	LD	HL,13
	JR	L_529
L_513:
; 3492	
; 3493			/* Boundaries and Limits */
; 3494			fs->n_fatent = nclst + 2;						/* Number of FAT entries */
.LINE 3494

	LD	HL,(IX+%FFFFFFEA)
	LD	E,(IX+%FFFFFFED)
	LD	A,%2
	CALL	__ladd_b
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%12),HL
	LD	(IY+%15),E
; 3495			fs->volbase = bsect;							/* Volume start sector */
.LINE 3495

	LD	BC,(IX+%FFFFFFD3)
	LD	A,(IX+%FFFFFFD6)
	LD	(IY+%1A),BC
	LD	(IY+%1D),A
; 3496			fs->fatbase = bsect + nrsv; 					/* FAT start sector */
.LINE 3496

	LD	BC,(IX+%FFFFFFE8)
	CALL	__stoiu
	LD	BC,HL
	XOR	A,A
	LD	HL,(IX+%FFFFFFD3)
	LD	E,(IX+%FFFFFFD6)
	CALL	__ladd
	LD	(IY+%1E),HL
	LD	(IY+%21),E
; 3497			fs->database = bsect + sysect;					/* Data start sector */
.LINE 3497

	LD	HL,(IX+%FFFFFFDA)
	LD	E,(IX+%FFFFFFDD)
	LD	BC,(IX+%FFFFFFD3)
	LD	A,(IX+%FFFFFFD6)
	CALL	__ladd
	LD	(IY+%26),HL
	LD	(IY+%29),E
; 3498			if (fmt == FS_FAT32) {
.LINE 3498

	LD	BC,3
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_525
; 3499				if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
.LINE 3499

	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%2E
	LD	(IX+%FFFFFFD0),BC
	LD	IY,(IX+%FFFFFFD0)
	LEA	BC,IY+%2A
	PUSH	BC
	CALL	_ld_word
	POP	BC
	CALL	__scmpzero
	JR	Z,L_516
	LD	HL,13
	JR	L_529
L_516:
; 3500				if (fs->n_rootdir != 0) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be 0) */
.LINE 3500

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%7)
	CALL	__scmpzero
	JR	Z,L_517
	LD	HL,13
	JR	L_529
L_517:
; 3501				fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
.LINE 3501

	LD	IY,(IX+%FFFFFFD0)
	LEA	BC,IY+%2C
	PUSH	BC
	CALL	_ld_dword
	POP	BC
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%22),HL
	LD	(IY+%25),E
; 3502				szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
.LINE 3502

	LD	HL,(IY+%12)
	LD	E,(IY+%15)
	LD	BC,4
	XOR	A,A
	CALL	__lmulu
	LD	(IX+%FFFFFFC8),HL
	LD	(IX+%FFFFFFCB),E
; 3503			} else {
.LINE 3503

	JR	L_527
L_525:
; 3504				if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
.LINE 3504

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%7)
	CALL	__scmpzero
	JR	NZ,L_519
	LD	HL,13
	JR	L_529
L_519:
; 3505				fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
.LINE 3505

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%1E)
	LD	E,(IY+%21)
	LD	BC,(IX+%FFFFFFF6)
	LD	A,(IX+%FFFFFFF9)
	CALL	__ladd
	LD	(IY+%22),HL
	LD	(IY+%25),E
; 3506				szbfat = (fmt == FS_FAT16) ?				/* (Needed FAT size) */
.LINE 3506

	LD	BC,2
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_522
; 3507					fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
.LINE 3507

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%12)
	LD	E,(IY+%15)
	XOR	A,A
	CALL	__lmulu
	LD	(IX+%FFFFFFCC),HL
	LD	(IX+%FFFFFFCF),E
	JR	L_523
L_522:
	LD	IY,(IX+%FFFFFFFD)
	LD	DE,(IY+%12)
	LD	(IX+%FFFFFFC2),DE	; spill
	LD	E,(IY+%15)
	LD	(IX+%FFFFFFC5),DE	; spill
	LD	HL,(IX+%FFFFFFC2)
	LD	DE,(IX+%FFFFFFC5)	; unspill
	LD	BC,3
	XOR	A,A
	CALL	__lmulu
	LD	A,E
	LD	BC,HL
	LD	L,%1
	CALL	__lshru
	LD	(IX+%FFFFFFBF),BC
	LD	E,A
	LD	(IX+%FFFFFFC5),DE	; spill
	LD	DE,(IX+%FFFFFFC2)	; unspill
	LD	BC,DE
	LD	DE,(IX+%FFFFFFC5)	; unspill
	LD	A,C
	AND	A,%1
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	A,H
	LD	HL,(IX+%FFFFFFBF)
	CALL	__ladd
	LD	(IX+%FFFFFFCC),HL
	LD	(IX+%FFFFFFCF),E
L_523:
	LD	BC,(IX+%FFFFFFCC)
	LD	A,(IX+%FFFFFFCF)
	LD	(IX+%FFFFFFC8),BC
	LD	(IX+%FFFFFFCB),A
; 3508			}
L_527:
.LINE 3508

; 3509			if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
.LINE 3509

	LD	HL,(IX+%FFFFFFC8)
	LD	E,(IX+%FFFFFFCB)
	LD	BC,511
	XOR	A,A
	CALL	__ladd
	LD	A,E
	LD	BC,HL
	LD	L,%9
	CALL	__lshru
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%16)
	LD	E,(IY+%19)
	CALL	__lcmpu
	JR	NC,L_528
	LD	HL,13
	JR	L_529
; 3510	
; 3511	#if !FF_FS_READONLY
; 3512			/* Get FSInfo if available */
; 3513			fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
; 3514			fs->fsi_flag = 0x80;
; 3515	#if (FF_FS_NOFSINFO & 3) != 3
; 3516			if (fmt == FS_FAT32				/* Allow to update FSInfo only if BPB_FSInfo32 == 1 */
; 3517				&& ld_word(fs->win + BPB_FSInfo32) == 1
; 3518				&& move_window(fs, bsect + 1) == FR_OK)
; 3519			{
; 3520				fs->fsi_flag = 0;
; 3521				if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSInfo data if available */
; 3522					&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
; 3523					&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
; 3524				{
; 3525	#if (FF_FS_NOFSINFO & 1) == 0
; 3526					fs->free_clst = ld_dword(fs->win + FSI_Free_Count);
; 3527	#endif
; 3528	#if (FF_FS_NOFSINFO & 2) == 0
; 3529					fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
; 3530	#endif
; 3531				}
; 3532			}
; 3533	#endif	/* (FF_FS_NOFSINFO & 3) != 3 */
; 3534	#endif	/* !FF_FS_READONLY */
; 3535		}
L_528:
.LINE 3535

; 3536	
; 3537		fs->fs_type = (BYTE)fmt;/* FAT sub-type */
.LINE 3537

	LD	A,(IX+%FFFFFFFA)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%0),A
; 3538		fs->id = ++Fsid;		/* Volume mount ID */
.LINE 3538

	LD	BC,(_Fsid)
	INC	BC
	LD	HL,_Fsid
	LD	(HL),C
	INC	HL
	LD	(HL),B
	LD	BC,(_Fsid)
	LD	(IY+%5),C
	LD	(IY+%6),B
; 3539	#if FF_USE_LFN == 1
; 3540		fs->lfnbuf = LfnBuf;	/* Static LFN working buffer */
; 3541	#if FF_FS_EXFAT
; 3542		fs->dirbuf = DirBuf;	/* Static directory block scratchpad buuffer */
; 3543	#endif
; 3544	#endif
; 3545	#if FF_FS_RPATH != 0
; 3546		fs->cdir = 0;			/* Initialize current directory */
.LINE 3546

	LD	BC,0
	LD	(IY+%E),BC
	LD	(IY+%11),%0
; 3547	#endif
; 3548	#if FF_FS_LOCK != 0			/* Clear file lock semaphores */
; 3549		clear_lock(fs);
; 3550	#endif
; 3551		return FR_OK;
.LINE 3551

	OR	A,A
	SBC	HL,HL
; 3552	}
L_529:
.LINE 3552

	LD	SP,IX
	POP	IX
	RET	


;**************************** _mount_volume ***************************
;Name                         Addr/Register   Size   Type
;_Fsid                               STATIC      2   variable
;_disk_initialize                    IMPORT  -----   function
;_disk_status                        IMPORT  -----   function
;_FatFs                              STATIC      3   variable
;szbfat                               IX-56      4   variable
;temp520                              IX-52      4   variable
;G_40                                 IX-48      3   variable
;bsect                                IX-45      4   variable
;G_39                                 IX-41      3   variable
;sysect                               IX-38      4   variable
;tsect                                IX-34      4   variable
;vol                                  IX-30      3   variable
;G_38                                 IX-27      3   variable
;nrsv                                 IX-24      2   variable
;nclst                                IX-22      4   variable
;G_36                                 IX-18      1   variable
;G_33                                 IX-17      3   variable
;G_37                                 IX-14      2   variable
;stat                                 IX-12      1   variable
;G_35                                 IX-11      1   variable
;fasize                               IX-10      4   variable
;fmt                                   IX-6      3   variable
;fs                                    IX-3      3   variable
;mode                                 IX+12      1   parameter
;rfs                                   IX+9      3   parameter
;path                                  IX+6      3   parameter


; Stack Frame Size: 87 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "mount_volume",3552,"_mount_volume"
; 3553	
; 3554	
; 3555	
; 3556	
; 3557	/*-----------------------------------------------------------------------*/
; 3558	/* Check if the file/directory object is valid or not                    */
; 3559	/*-----------------------------------------------------------------------*/
; 3560	
; 3561	static FRESULT validate (	/* Returns FR_OK or FR_INVALID_OBJECT */
; 3562		FFOBJID* obj,			/* Pointer to the FFOBJID, the 1st member in the FIL/DIR object, to check validity */
; 3563		FATFS** rfs				/* Pointer to pointer to the owner filesystem object to return */
; 3564	)
; 3565	{
_validate:
.DEFINE "_validate"

.VALUE _validate

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "validate",3565,"_validate"

.LINE 3565

.DEFINE "obj"

.CLASS 65

.VALUE 6

.TAG "NONAME1"

.TYPE 40

.ENDEF

.DEFINE "rfs"

.CLASS 65

.VALUE 9

.TAG "NONAME0"

.TYPE 296

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -6

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	PUSH	BC
; 3566		FRESULT res = FR_INVALID_OBJECT;
.LINE 3566

	LD	BC,9
	LD	(IX+%FFFFFFFA),BC
; 3567	
; 3568	
; 3569		if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
.LINE 3569

	LD	HL,(IX+%6)
	CALL	__icmpzero
	JR	Z,L_539
	LD	IY,(IX+%6)
	LD	BC,(IY+%0)
	LD	(IX+%FFFFFFFD),BC
	LD	HL,BC
	CALL	__icmpzero
	JR	Z,L_539
	LD	IY,(IX+%FFFFFFFD)
	LD	A,(IY+%0)
	OR	A,A
	JR	Z,L_539
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%5)
	LD	IY,(IX+%6)
	LD	HL,(IY+%3)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_539
; 3570	#if FF_FS_REENTRANT
; 3571			if (lock_fs(obj->fs)) {	/* Obtain the filesystem object */
; 3572				if (!(disk_status(obj->fs->pdrv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
; 3573					res = FR_OK;
; 3574				} else {
; 3575					unlock_fs(obj->fs, FR_OK);
; 3576				}
; 3577			} else {
; 3578				res = FR_TIMEOUT;
; 3579			}
; 3580	#else
; 3581			if (!(disk_status(obj->fs->pdrv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
.LINE 3581

	LD	IY,(IX+%FFFFFFFD)
	LD	C,(IY+%1)
	LD	B,%0
	PUSH	BC
	CALL	_disk_status
	POP	BC
	AND	A,%1
	JR	NZ,L_539
; 3582				res = FR_OK;
.LINE 3582

	LD	BC,0
	LD	(IX+%FFFFFFFA),BC
; 3583			}
; 3584	#endif
; 3585		}
L_539:
.LINE 3585

; 3586		*rfs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
.LINE 3586

	LD	HL,(IX+%FFFFFFFA)
	CALL	__icmpzero
	JR	NZ,L_537
	LD	IY,(IX+%6)
	LD	BC,(IY+%0)
	LD	(IX+%FFFFFFF7),BC
	JR	L_538
L_537:
	LD	BC,0
	LD	(IX+%FFFFFFF7),BC
L_538:
	LD	HL,(IX+%9)
	LD	BC,(IX+%FFFFFFF7)
	LD	(HL),BC
; 3587		return res;
.LINE 3587

	LD	HL,(IX+%FFFFFFFA)
; 3588	}
.LINE 3588

	LD	SP,IX
	POP	IX
	RET	


;**************************** _validate ***************************
;Name                         Addr/Register   Size   Type
;_disk_status                        IMPORT  -----   function
;temp535                               IX-9      3   variable
;res                                   IX-6      3   variable
;G_41                                  IX-3      3   variable
;rfs                                   IX+9      3   parameter
;obj                                   IX+6      3   parameter


; Stack Frame Size: 21 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "validate",3588,"_validate"
; 3589	
; 3590	
; 3591	
; 3592	
; 3593	/*---------------------------------------------------------------------------
; 3594	
; 3595	   Public Functions (FatFs API)
; 3596	
; 3597	----------------------------------------------------------------------------*/
; 3598	
; 3599	
; 3600	
; 3601	/*-----------------------------------------------------------------------*/
; 3602	/* Mount/Unmount a Logical Drive                                         */
; 3603	/*-----------------------------------------------------------------------*/
; 3604	
; 3605	FRESULT f_mount (
; 3606		FATFS* fs,			/* Pointer to the filesystem object to be registered (NULL:unmount)*/
; 3607		const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
; 3608		BYTE opt			/* Mount option: 0=Do not mount (delayed mount), 1=Mount immediately */
; 3609	)
; 3610	{
_f_mount:
.DEFINE "_f_mount"

.VALUE _f_mount

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "f_mount",3610,"_f_mount"

.LINE 3610

.DEFINE "fs"

.CLASS 65

.VALUE 6

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "path"

.CLASS 65

.VALUE 9

.TYPE 194

.ENDEF

.DEFINE "opt"

.CLASS 65

.VALUE 12

.TYPE 12

.ENDEF

.DEFINE "cfs"

.CLASS 65

.VALUE -3

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "vol"

.CLASS 65

.VALUE -6

.TYPE 4

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -12

.TYPE 4

.ENDEF

.DEFINE "rp"

.CLASS 65

.VALUE -15

.TYPE 194

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF1
	LD	SP,HL
; 3611		FATFS *cfs;
; 3612		int vol;
; 3613		FRESULT res;
; 3614		const TCHAR *rp = path;
.LINE 3614

	LD	BC,(IX+%9)
	LD	(IX+%FFFFFFF1),BC
; 3615	
; 3616	
; 3617		/* Get logical drive number */
; 3618		vol = get_ldnumber(&rp);
.LINE 3618

	PEA	IX+%FFFFFFF1
	CALL	_get_ldnumber
	POP	BC
	LD	(IX+%FFFFFFFA),HL
; 3619		if (vol < 0) return FR_INVALID_DRIVE;
.LINE 3619

	CALL	__icmpzero
	JP	P,L_542
	LD	HL,11
	JR	L_549
L_542:
; 3620		cfs = FatFs[vol];					/* Pointer to fs object */
.LINE 3620

	LD	HL,(IX+%FFFFFFFA)
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_FatFs
	ADD	HL,BC
	LD	(IX+%FFFFFFF7),HL
	LD	BC,(HL)
	LD	(IX+%FFFFFFFD),BC
; 3621	
; 3622		if (cfs) {
.LINE 3622

	LD	HL,BC
	CALL	__icmpzero
	JR	Z,L_545
; 3623	#if FF_FS_LOCK != 0
; 3624			clear_lock(cfs);
; 3625	#endif
; 3626	#if FF_FS_REENTRANT						/* Discard sync object of the current volume */
; 3627			if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
; 3628	#endif
; 3629			cfs->fs_type = 0;				/* Clear old fs object */
.LINE 3629

	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%0),%0
; 3630		}
L_545:
.LINE 3630

; 3631	
; 3632		if (fs) {
.LINE 3632

	LD	HL,(IX+%6)
	CALL	__icmpzero
	JR	Z,L_546
; 3633			fs->fs_type = 0;				/* Clear new fs object */
.LINE 3633

	LD	IY,(IX+%6)
	LD	(IY+%0),%0
; 3634	#if FF_FS_REENTRANT						/* Create sync object for the new volume */
; 3635			if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
; 3636	#endif
; 3637		}
L_546:
.LINE 3637

; 3638		FatFs[vol] = fs;					/* Register new fs object */
.LINE 3638

	LD	HL,(IX+%FFFFFFF7)
	LD	BC,(IX+%6)
	LD	(HL),BC
; 3639	
; 3640		if (opt == 0) return FR_OK;			/* Do not mount now, it will be mounted later */
.LINE 3640

	LD	A,(IX+%C)
	OR	A,A
	JR	NZ,L_548
	OR	A,A
	SBC	HL,HL
	JR	L_549
L_548:
; 3641	
; 3642		res = mount_volume(&path, &fs, 0);	/* Force mounted the volume */
.LINE 3642

	LD	BC,0
	PUSH	BC
	PEA	IX+%6
	PEA	IX+%9
	CALL	_mount_volume
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFF4),HL
; 3643		LEAVE_FF(fs, res);
.LINE 3643

; 3644	}
L_549:
.LINE 3644

	LD	SP,IX
	POP	IX
	RET	


;**************************** _f_mount ***************************
;Name                         Addr/Register   Size   Type
;_FatFs                              STATIC      3   variable
;rp                                   IX-15      3   variable
;res                                  IX-12      3   variable
;G_44                                  IX-9      3   variable
;vol                                   IX-6      3   variable
;cfs                                   IX-3      3   variable
;opt                                  IX+12      1   parameter
;path                                  IX+9      3   parameter
;fs                                    IX+6      3   parameter


; Stack Frame Size: 30 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "f_mount",3644,"_f_mount"
; 3645	
; 3646	
; 3647	
; 3648	
; 3649	/*-----------------------------------------------------------------------*/
; 3650	/* Open or Create a File                                                 */
; 3651	/*-----------------------------------------------------------------------*/
; 3652	
; 3653	FRESULT f_open (
; 3654		FIL* fp,			/* Pointer to the blank file object */
; 3655		const TCHAR* path,	/* Pointer to the file name */
; 3656		BYTE mode			/* Access mode and open mode flags */
; 3657	)
; 3658	{
_f_open:
.DEFINE "_f_open"

.VALUE _f_open

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "f_open",3658,"_f_open"

.LINE 3658

.DEFINE "fp"

.CLASS 65

.VALUE 6

.TAG "NONAME2"

.TYPE 40

.ENDEF

.DEFINE "path"

.CLASS 65

.VALUE 9

.TYPE 194

.ENDEF

.DEFINE "mode"

.CLASS 65

.VALUE 12

.TYPE 12

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -6

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "dj"

.CLASS 65

.VALUE -52

.TAG "NONAME3"

.TYPE 8

.ENDEF

.DEFINE "lbuf"

.CLASS 65

.VALUE -564

.DIM 256

.TYPE 109

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LD	HL,-573
	ADD	HL,SP
	LD	SP,HL
; 3659		FRESULT res;
; 3660		DIR dj;
; 3661		FATFS *fs;
; 3662	#if !FF_FS_READONLY
; 3663		DWORD cl, bcs, clst, tm;
; 3664		LBA_t sc;
; 3665		FSIZE_t ofs;
; 3666	#endif
; 3667		DEF_NAMBUF
; 3668	
; 3669	
; 3670		if (!fp) return FR_INVALID_OBJECT;
.LINE 3670

	LD	HL,(IX+%6)
	CALL	__icmpzero
	JR	NZ,L_551
	LD	HL,9
	JR	L_563
L_551:
; 3671	
; 3672		/* Get logical drive number */
; 3673		mode &= FF_FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND;
.LINE 3673

	LD	A,(IX+%C)
	AND	A,%1
	LD	(IX+%C),A
; 3674		res = mount_volume(&path, &fs, mode);
.LINE 3674

	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	PEA	IX+%FFFFFFFA
	PEA	IX+%9
	CALL	_mount_volume
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 3675		if (res == FR_OK) {
.LINE 3675

	CALL	__icmpzero
	JR	NZ,L_561
; 3676			dj.obj.fs = fs;
.LINE 3676

	LD	BC,(IX+%FFFFFFFA)
	LD	(IX+%FFFFFFCC),BC
; 3677			INIT_NAMBUF(fs);
.LINE 3677

	LD	HL,IX
	LD	BC,-564
	ADD	HL,BC
	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%B),HL
; 3678			res = follow_path(&dj, path);	/* Follow the file path */
.LINE 3678

	LD	BC,(IX+%9)
	PUSH	BC
	PEA	IX+%FFFFFFCC
	CALL	_follow_path
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 3679	#if !FF_FS_READONLY	/* Read/Write configuration */
; 3680			if (res == FR_OK) {
; 3681				if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
; 3682					res = FR_INVALID_NAME;
; 3683				}
; 3684	#if FF_FS_LOCK != 0
; 3685				else {
; 3686					res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);		/* Check if the file can be used */
; 3687				}
; 3688	#endif
; 3689			}
; 3690			/* Create or Open a file */
; 3691			if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
; 3692				if (res != FR_OK) {					/* No file, create new */
; 3693					if (res == FR_NO_FILE) {		/* There is no file to open, create a new entry */
; 3694	#if FF_FS_LOCK != 0
; 3695						res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
; 3696	#else
; 3697						res = dir_register(&dj);
; 3698	#endif
; 3699					}
; 3700					mode |= FA_CREATE_ALWAYS;		/* File is created */
; 3701				}
; 3702				else {								/* Any object with the same name is already existing */
; 3703					if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
; 3704						res = FR_DENIED;
; 3705					} else {
; 3706						if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
; 3707					}
; 3708				}
; 3709				if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate the file if overwrite mode */
; 3710	#if FF_FS_EXFAT
; 3711					if (fs->fs_type == FS_EXFAT) {
; 3712						/* Get current allocation info */
; 3713						fp->obj.fs = fs;
; 3714						init_alloc_info(fs, &fp->obj);
; 3715						/* Set directory entry block initial state */
; 3716						memset(fs->dirbuf + 2, 0, 30);	/* Clear 85 entry except for NumSec */
; 3717						memset(fs->dirbuf + 38, 0, 26);	/* Clear C0 entry except for NumName and NameHash */
; 3718						fs->dirbuf[XDIR_Attr] = AM_ARC;
; 3719						st_dword(fs->dirbuf + XDIR_CrtTime, GET_FATTIME());
; 3720						fs->dirbuf[XDIR_GenFlags] = 1;
; 3721						res = store_xdir(&dj);
; 3722						if (res == FR_OK && fp->obj.sclust != 0) {	/* Remove the cluster chain if exist */
; 3723							res = remove_chain(&fp->obj, fp->obj.sclust, 0);
; 3724							fs->last_clst = fp->obj.sclust - 1;		/* Reuse the cluster hole */
; 3725						}
; 3726					} else
; 3727	#endif
; 3728					{
; 3729						/* Set directory entry initial state */
; 3730						tm = GET_FATTIME();					/* Set created time */
; 3731						st_dword(dj.dir + DIR_CrtTime, tm);
; 3732						st_dword(dj.dir + DIR_ModTime, tm);
; 3733						cl = ld_clust(fs, dj.dir);			/* Get current cluster chain */
; 3734						dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
; 3735						st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
; 3736						st_dword(dj.dir + DIR_FileSize, 0);
; 3737						fs->wflag = 1;
; 3738						if (cl != 0) {						/* Remove the cluster chain if exist */
; 3739							sc = fs->winsect;
; 3740							res = remove_chain(&dj.obj, cl, 0);
; 3741							if (res == FR_OK) {
; 3742								res = move_window(fs, sc);
; 3743								fs->last_clst = cl - 1;		/* Reuse the cluster hole */
; 3744							}
; 3745						}
; 3746					}
; 3747				}
; 3748			}
; 3749			else {	/* Open an existing file */
; 3750				if (res == FR_OK) {					/* Is the object exsiting? */
; 3751					if (dj.obj.attr & AM_DIR) {		/* File open against a directory */
; 3752						res = FR_NO_FILE;
; 3753					} else {
; 3754						if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* Write mode open against R/O file */
; 3755							res = FR_DENIED;
; 3756						}
; 3757					}
; 3758				}
; 3759			}
; 3760			if (res == FR_OK) {
; 3761				if (mode & FA_CREATE_ALWAYS) mode |= FA_MODIFIED;	/* Set file change flag if created or overwritten */
; 3762				fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
; 3763				fp->dir_ptr = dj.dir;
; 3764	#if FF_FS_LOCK != 0
; 3765				fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);	/* Lock the file for this session */
; 3766				if (fp->obj.lockid == 0) res = FR_INT_ERR;
; 3767	#endif
; 3768			}
; 3769	#else		/* R/O configuration */
; 3770			if (res == FR_OK) {
.LINE 3770

	CALL	__icmpzero
	JR	NZ,L_557
; 3771				if (dj.fn[NSFLAG] & NS_NONAME) {	/* Is it origin directory itself? */
.LINE 3771

	LEA	IY,IX+%FFFFFFEA
	LD	A,(IY+%B)
	AND	A,%80
	JR	Z,L_554
; 3772					res = FR_INVALID_NAME;
.LINE 3772

	LD	BC,6
	LD	(IX+%FFFFFFFD),BC
; 3773				} else {
.LINE 3773

	JR	L_557
L_554:
; 3774					if (dj.obj.attr & AM_DIR) {		/* Is it a directory? */
.LINE 3774

	LD	A,(IX+%FFFFFFD1)
	AND	A,%10
	JR	Z,L_557
; 3775						res = FR_NO_FILE;
.LINE 3775

	LD	BC,4
	LD	(IX+%FFFFFFFD),BC
; 3776					}
; 3777				}
; 3778			}
L_557:
.LINE 3778

; 3779	#endif
; 3780	
; 3781			if (res == FR_OK) {
.LINE 3781

	LD	HL,(IX+%FFFFFFFD)
	CALL	__icmpzero
	JR	NZ,L_558
; 3782	#if FF_FS_EXFAT
; 3783				if (fs->fs_type == FS_EXFAT) {
; 3784					fp->obj.c_scl = dj.obj.sclust;							/* Get containing directory info */
; 3785					fp->obj.c_size = ((DWORD)dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;
; 3786					fp->obj.c_ofs = dj.blk_ofs;
; 3787					init_alloc_info(fs, &fp->obj);
; 3788				} else
; 3789	#endif
; 3790				{
; 3791					fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
.LINE 3791

	LD	IY,(IX+%6)
	LEA	HL,IY+%0
	LD	BC,-567
	CALL	__istix
	LD	BC,(IX+%FFFFFFE7)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	CALL	_ld_clust
	POP	BC
	POP	BC
	LD	IY,(IX+%6)
	LD	(IY+%7),HL
	LD	(IY+%A),E
; 3792					fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
.LINE 3792

	LD	IY,(IX+%FFFFFFE7)
	LEA	BC,IY+%1C
	PUSH	BC
	CALL	_ld_dword
	POP	BC
	LD	BC,-573	; spill
	CALL	__istix
	LD	BC,-567
	CALL	__ildix
	LD	IY,HL
	LD	BC,-573	; unspill
	CALL	__ildix
	LD	(IY+%B),HL
	LD	(IY+%E),E
; 3793				}
; 3794	#if FF_USE_FASTSEEK
; 3795				fp->cltbl = 0;		/* Disable fast seek mode */
; 3796	#endif
; 3797				fp->obj.fs = fs;	/* Validate the file object */
.LINE 3797

	LD	BC,-567
	CALL	__ildix
	LD	BC,(IX+%FFFFFFFA)
	LD	IY,HL
	LD	(IY+%0),BC
; 3798				fp->obj.id = fs->id;
.LINE 3798

	LD	BC,-567
	CALL	__ildix
	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%5)
	LD	IY,HL
	LD	(IY+%3),C
	LD	(IY+%4),B
; 3799				fp->flag = mode;	/* Set file access mode */
.LINE 3799

	LD	A,(IX+%C)
	LD	IY,(IX+%6)
	LD	(IY+%F),A
; 3800				fp->err = 0;		/* Clear error flag */
.LINE 3800

	LD	(IY+%10),%0
; 3801				fp->sect = 0;		/* Invalidate current data sector */
.LINE 3801

	LD	BC,0
	LD	(IY+%19),BC
	LD	(IY+%1C),%0
; 3802				fp->fptr = 0;		/* Set file pointer top of the file */
.LINE 3802

	LD	(IY+%11),BC
	LD	(IY+%14),%0
; 3803	#if !FF_FS_READONLY
; 3804	#if !FF_FS_TINY
; 3805				memset(fp->buf, 0, sizeof fp->buf);	/* Clear sector buffer */
; 3806	#endif
; 3807				if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
; 3808					fp->fptr = fp->obj.objsize;			/* Offset to seek */
; 3809					bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
; 3810					clst = fp->obj.sclust;				/* Follow the cluster chain */
; 3811					for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
; 3812						clst = get_fat(&fp->obj, clst);
; 3813						if (clst <= 1) res = FR_INT_ERR;
; 3814						if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
; 3815					}
; 3816					fp->clust = clst;
; 3817					if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
; 3818						sc = clst2sect(fs, clst);
; 3819						if (sc == 0) {
; 3820							res = FR_INT_ERR;
; 3821						} else {
; 3822							fp->sect = sc + (DWORD)(ofs / SS(fs));
; 3823	#if !FF_FS_TINY
; 3824							if (disk_read(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
; 3825	#endif
; 3826						}
; 3827					}
; 3828	#if FF_FS_LOCK != 0
; 3829					if (res != FR_OK) dec_lock(fp->obj.lockid); /* Decrement file open counter if seek failed */
; 3830	#endif
; 3831				}
; 3832	#endif
; 3833			}
L_558:
.LINE 3833

; 3834	
; 3835			FREE_NAMBUF();
; 3836		}
L_561:
.LINE 3836

; 3837	
; 3838		if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
.LINE 3838

	LD	HL,(IX+%FFFFFFFD)
	CALL	__icmpzero
	JR	Z,L_562
	LD	BC,0
	LD	IY,(IX+%6)
	LD	(IY+%0),BC
L_562:
; 3839	
; 3840		LEAVE_FF(fs, res);
.LINE 3840

	LD	HL,(IX+%FFFFFFFD)
; 3841	}
L_563:
.LINE 3841

	LD	SP,IX
	POP	IX
	RET	


;**************************** _f_open ***************************
;Name                         Addr/Register   Size   Type
;lbuf                                IX-564    512   variable
;dj                                   IX-52     46   variable
;fs                                    IX-6      3   variable
;res                                   IX-3      3   variable
;mode                                 IX+12      1   parameter
;path                                  IX+9      3   parameter
;fp                                    IX+6      3   parameter


; Stack Frame Size: 588 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "f_open",3841,"_f_open"
; 3842	
; 3843	
; 3844	
; 3845	
; 3846	/*-----------------------------------------------------------------------*/
; 3847	/* Read File                                                             */
; 3848	/*-----------------------------------------------------------------------*/
; 3849	
; 3850	FRESULT f_read (
; 3851		FIL* fp, 	/* Open file to be read */
; 3852		void* buff,	/* Data buffer to store the read data */
; 3853		UINT btr,	/* Number of bytes to read */
; 3854		UINT* br	/* Number of bytes read */
; 3855	)
; 3856	{
_f_read:
.DEFINE "_f_read"

.VALUE _f_read

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "f_read",3856,"_f_read"

.LINE 3856

.DEFINE "fp"

.CLASS 65

.VALUE 6

.TAG "NONAME2"

.TYPE 40

.ENDEF

.DEFINE "buff"

.CLASS 65

.VALUE 9

.TYPE 33

.ENDEF

.DEFINE "btr"

.CLASS 65

.VALUE 12

.TYPE 14

.ENDEF

.DEFINE "br"

.CLASS 65

.VALUE 15

.TYPE 46

.ENDEF

.DEFINE "rcnt"

.CLASS 65

.VALUE -3

.TYPE 14

.ENDEF

.DEFINE "sect"

.CLASS 65

.VALUE -7

.TYPE 15

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -10

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "cc"

.CLASS 65

.VALUE -13

.TYPE 14

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -16

.TYPE 4

.ENDEF

.DEFINE "csect"

.CLASS 65

.VALUE -19

.TYPE 14

.ENDEF

.DEFINE "rbuff"

.CLASS 65

.VALUE -22

.TYPE 44

.ENDEF

.DEFINE "clst"

.CLASS 65

.VALUE -26

.TYPE 15

.ENDEF

.DEFINE "remain"

.CLASS 65

.VALUE -34

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFD6
	LD	SP,HL
; 3857		FRESULT res;
; 3858		FATFS *fs;
; 3859		DWORD clst;
; 3860		LBA_t sect;
; 3861		FSIZE_t remain;
; 3862		UINT rcnt, cc, csect;
; 3863		BYTE *rbuff = (BYTE*)buff;
.LINE 3863

	LD	BC,(IX+%9)
	LD	(IX+%FFFFFFEA),BC
; 3864	
; 3865	
; 3866		*br = 0;	/* Clear read byte counter */
.LINE 3866

	LD	HL,(IX+%F)
	LD	BC,0
	LD	(HL),BC
; 3867		res = validate(&fp->obj, &fs);				/* Check validity of the file object */
.LINE 3867

	PEA	IX+%FFFFFFF6
	LD	IY,(IX+%6)
	PEA	IY+%0
	CALL	_validate
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFF0),HL
; 3868		if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
.LINE 3868

	CALL	__icmpzero
	JR	NZ,L_565
	LD	IY,(IX+%6)
	LD	A,(IY+%10)
	UEXT	HL
	LD	L,A
	LD	(IX+%FFFFFFF0),HL
	CALL	__icmpzero
	JR	Z,L_567
L_565:
	LD	HL,(IX+%FFFFFFF0)
	JR	L_600
L_567:
; 3869		if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
.LINE 3869

	LD	IY,(IX+%6)
	LD	A,(IY+%F)
	AND	A,%1
	JR	NZ,L_568
	LD	HL,7
	JR	L_600
L_568:
; 3870		remain = fp->obj.objsize - fp->fptr;
.LINE 3870

	LD	IY,(IX+%6)
	LD	HL,(IY+%B)
	LD	E,(IY+%E)
	LD	BC,(IY+%11)
	LD	A,(IY+%14)
	CALL	__lsub
	LD	(IX+%FFFFFFDE),HL
	LD	(IX+%FFFFFFE1),E
; 3871		if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
.LINE 3871

	LD	BC,(IX+%C)
	XOR	A,A
	LD	HL,(IX+%FFFFFFDE)
	LD	E,(IX+%FFFFFFE1)
	CALL	__lcmpu
	JR	NC,L_597
	LD	BC,(IX+%FFFFFFDE)
	LD	(IX+%C),BC
; 3872	
; 3873		for ( ; btr > 0; btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {	/* Repeat until btr bytes read */
.LINE 3873

	JR	L_597
L_595:
; 3874			if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
.LINE 3874

	LD	IY,(IX+%6)
	LD	BC,(IY+%11)
	LD	A,(IY+%14)
	LD	(IX+%FFFFFFE2),BC
	LD	(IX+%FFFFFFE5),A
	LD	HL,BC
	LD	E,(IX+%FFFFFFE5)
	LD	BC,511
	XOR	A,A
	CALL	__land
	CALL	__lcmpzero
	JR	NZ,L_592
; 3875				csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
.LINE 3875

	LD	IY,(IX+%FFFFFFF6)
	LD	BC,(IY+%9)
	CALL	__stoiu
	DEC	HL
	LD	BC,HL
	CALL	__itol
	LD	(IX+%FFFFFFD7),BC
	LD	E,A
	LD	BC,(IX+%FFFFFFE2)
	LD	A,(IX+%FFFFFFE5)
	LD	L,%9
	CALL	__lshru
	LD	HL,(IX+%FFFFFFD7)
	CALL	__land
	LD	(IX+%FFFFFFED),HL
; 3876				if (csect == 0) {					/* On the cluster boundary? */
.LINE 3876

	CALL	__icmpzero
	JR	NZ,L_578
; 3877					if (fp->fptr == 0) {			/* On the top of the file? */
.LINE 3877

	LD	HL,(IX+%FFFFFFE2)
	LD	E,(IX+%FFFFFFE5)
	CALL	__lcmpzero
	JR	NZ,L_571
; 3878						clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
.LINE 3878

	LD	IY,(IX+%6)
	LD	BC,(IY+%7)
	LD	A,(IY+%A)
	LD	(IX+%FFFFFFE6),BC
	LD	(IX+%FFFFFFE9),A
; 3879					} else {						/* Middle or end of the file */
.LINE 3879

	JR	L_573
L_571:
; 3880	#if FF_USE_FASTSEEK
; 3881						if (fp->cltbl) {
; 3882							clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
; 3883						} else
; 3884	#endif
; 3885						{
; 3886							clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
.LINE 3886

	LD	IY,(IX+%6)
	LD	BC,(IY+%15)
	LD	A,(IY+%18)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	PEA	IY+%0
	CALL	_get_fat
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFE6),HL
	LD	(IX+%FFFFFFE9),E
; 3887						}
; 3888					}
L_573:
.LINE 3888

; 3889					if (clst < 2) ABORT(fs, FR_INT_ERR);
.LINE 3889

	LD	HL,(IX+%FFFFFFE6)
	LD	E,(IX+%FFFFFFE9)
	LD	BC,2
	XOR	A,A
	CALL	__lcmpu
	JR	NC,L_574
	LD	IY,(IX+%6)
	LD	(IY+%10),%2
	LD	HL,2
	JR	L_600
L_574:
; 3890					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
.LINE 3890

	LD	HL,(IX+%FFFFFFE6)
	LD	E,(IX+%FFFFFFE9)
	LD	BC,16777215
	LD	A,%FF
	CALL	__lcmpu
	JR	NZ,L_576
	LD	IY,(IX+%6)
	LD	(IY+%10),%1
	LD	HL,1
	JR	L_600
L_576:
; 3891					fp->clust = clst;				/* Update current cluster */
.LINE 3891

	LD	BC,(IX+%FFFFFFE6)
	LD	A,(IX+%FFFFFFE9)
	LD	IY,(IX+%6)
	LD	(IY+%15),BC
	LD	(IY+%18),A
; 3892				}
L_578:
.LINE 3892

; 3893				sect = clst2sect(fs, fp->clust);	/* Get current sector */
.LINE 3893

	LD	IY,(IX+%6)
	LD	BC,(IY+%15)
	LD	A,(IY+%18)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	LD	BC,(IX+%FFFFFFF6)
	PUSH	BC
	CALL	_clst2sect
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFF9),HL
	LD	(IX+%FFFFFFFC),E
; 3894				if (sect == 0) ABORT(fs, FR_INT_ERR);
.LINE 3894

	LD	HL,(IX+%FFFFFFF9)
	LD	E,(IX+%FFFFFFFC)
	CALL	__lcmpzero
	JR	NZ,L_580
	LD	IY,(IX+%6)
	LD	(IY+%10),%2
	LD	HL,2
	JR	L_600
L_580:
; 3895				sect += csect;
.LINE 3895

	LD	BC,(IX+%FFFFFFED)
	XOR	A,A
	LD	HL,(IX+%FFFFFFF9)
	LD	E,(IX+%FFFFFFFC)
	CALL	__ladd
	LD	(IX+%FFFFFFF9),HL
	LD	(IX+%FFFFFFFC),E
; 3896				cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
.LINE 3896

	LD	HL,(IX+%C)
	LD	A,%9
	CALL	__ishru_b
	LD	(IX+%FFFFFFF3),HL
; 3897				if (cc > 0) {						/* Read maximum contiguous sectors directly */
.LINE 3897

	LD	BC,HL
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	NC,L_589
; 3898					if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
.LINE 3898

	LD	IY,(IX+%FFFFFFF6)
	LD	BC,(IY+%9)
	CALL	__stoiu
	LD	BC,HL
	LD	DE,(IX+%FFFFFFF3)
	LD	HL,(IX+%FFFFFFED)
	ADD	HL,DE
	LD	DE,HL
	LD	HL,BC
	OR	A,A
	SBC	HL,DE
	JR	NC,L_583
; 3899						cc = fs->csize - csect;
.LINE 3899

	LD	IY,(IX+%FFFFFFF6)
	LD	BC,(IY+%9)
	CALL	__stoiu
	LD	BC,(IX+%FFFFFFED)
	OR	A,A
	SBC	HL,BC
	LD	(IX+%FFFFFFF3),HL
; 3900					}
L_583:
.LINE 3900

; 3901					if (disk_read(fs->pdrv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
.LINE 3901

	LD	BC,(IX+%FFFFFFF3)
	PUSH	BC
	LD	C,(IX+%FFFFFFFC)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFF9)
	PUSH	BC
	LD	BC,(IX+%FFFFFFEA)
	PUSH	BC
	LD	IY,(IX+%FFFFFFF6)
	LD	C,(IY+%1)
	LD	B,%0
	PUSH	BC
	CALL	_disk_read
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	Z,L_584
	LD	IY,(IX+%6)
	LD	(IY+%10),%1
	LD	HL,1
	JR	L_600
L_584:
; 3902	#if !FF_FS_READONLY && FF_FS_MINIMIZE <= 2		/* Replace one of the read sectors with cached data if it contains a dirty sector */
; 3903	#if FF_FS_TINY
; 3904					if (fs->wflag && fs->winsect - sect < cc) {
; 3905						memcpy(rbuff + ((fs->winsect - sect) * SS(fs)), fs->win, SS(fs));
; 3906					}
; 3907	#else
; 3908					if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
; 3909						memcpy(rbuff + ((fp->sect - sect) * SS(fs)), fp->buf, SS(fs));
; 3910					}
; 3911	#endif
; 3912	#endif
; 3913					rcnt = SS(fs) * cc;				/* Number of bytes transferred */
.LINE 3913

	LD	HL,(IX+%FFFFFFF3)
	LD	A,%9
	CALL	__ishl_b
	LD	(IX+%FFFFFFFD),HL
; 3914					continue;
.LINE 3914

	JR	L_596
; 3915				}
L_589:
.LINE 3915

; 3916	#if !FF_FS_TINY
; 3917				if (fp->sect != sect) {			/* Load data sector if not in cache */
.LINE 3917

	LD	IY,(IX+%6)
	LD	HL,(IY+%19)
	LD	E,(IY+%1C)
	LD	BC,(IX+%FFFFFFF9)
	LD	A,(IX+%FFFFFFFC)
	CALL	__lcmpu
	JR	Z,L_590
; 3918	#if !FF_FS_READONLY
; 3919					if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
; 3920						if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
; 3921						fp->flag &= (BYTE)~FA_DIRTY;
; 3922					}
; 3923	#endif
; 3924					if (disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK)	ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
.LINE 3924

	LD	BC,1
	PUSH	BC
	LD	C,(IX+%FFFFFFFC)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFF9)
	PUSH	BC
	LD	IY,(IX+%6)
	PEA	IY+%1D
	LD	IY,(IX+%FFFFFFF6)
	LD	C,(IY+%1)
	LD	B,%0
	PUSH	BC
	LD	(IX+%FFFFFFD6),A
	CALL	_disk_read
	LD	A,(IX+%FFFFFFD6)
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	Z,L_590
	LD	IY,(IX+%6)
	LD	(IY+%10),%1
	LD	HL,1
	JR	L_600
; 3925				}
L_590:
.LINE 3925

; 3926	#endif
; 3927				fp->sect = sect;
.LINE 3927

	LD	BC,(IX+%FFFFFFF9)
	LD	D,(IX+%FFFFFFFC)
	LD	IY,(IX+%6)
	LD	(IY+%19),BC
	LD	(IY+%1C),D
; 3928			}
L_592:
.LINE 3928

; 3929			rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes remains in the sector */
.LINE 3929

	LD	IY,(IX+%6)
	LD	BC,(IY+%11)
	LD	D,(IY+%14)
	LD	(IX+%FFFFFFDA),BC
	LD	(IX+%FFFFFFDD),D
	LD	HL,BC
	LD	BC,511
	CALL	__iand
	LD	BC,HL
	LD	HL,512
	OR	A,A
	SBC	HL,BC
	LD	(IX+%FFFFFFFD),HL
; 3930			if (rcnt > btr) rcnt = btr;					/* Clip it by btr if needed */
.LINE 3930

	LD	BC,HL
	LD	HL,(IX+%C)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_594
	LD	BC,(IX+%C)
	LD	(IX+%FFFFFFFD),BC
L_594:
; 3931	#if FF_FS_TINY
; 3932			if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
; 3933			memcpy(rbuff, fs->win + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
; 3934	#else
; 3935			memcpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
.LINE 3935

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	LD	HL,(IX+%FFFFFFDA)
	LD	E,(IX+%FFFFFFDD)
	LD	BC,511
	XOR	A,A
	CALL	__land
	LD	BC,HL
	LD	IY,(IX+%6)
	LEA	HL,IY+%1D
	ADD	HL,BC
	PUSH	HL
	LD	BC,(IX+%FFFFFFEA)
	PUSH	BC
	LD	(IX+%FFFFFFD6),A
	CALL	_memcpy
	LD	A,(IX+%FFFFFFD6)
	POP	BC
	POP	BC
	POP	BC
; 3936	#endif
; 3937		}
L_596:
.LINE 3937

	LD	BC,(IX+%FFFFFFFD)
	LD	HL,(IX+%C)
	OR	A,A
	SBC	HL,BC
	LD	(IX+%C),HL
	LD	HL,(IX+%F)
	LD	IY,(IX+%F)
	LD	BC,(IX+%FFFFFFFD)
	LD	HL,(HL)
	ADD	HL,BC
	LD	(IY),HL
	LD	BC,(IX+%FFFFFFFD)
	LD	HL,(IX+%FFFFFFEA)
	ADD	HL,BC
	LD	(IX+%FFFFFFEA),HL
	LD	BC,(IX+%FFFFFFFD)
	XOR	A,A
	LD	IY,(IX+%6)
	LD	HL,(IY+%11)
	LD	E,(IY+%14)
	CALL	__ladd
	LD	(IY+%11),HL
	LD	(IY+%14),E
L_597:
	LD	BC,(IX+%C)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	C,L_595
; 3938	
; 3939		LEAVE_FF(fs, FR_OK);
.LINE 3939

	OR	A,A
	SBC	HL,HL
; 3940	}
L_600:
.LINE 3940

	LD	SP,IX
	POP	IX
	RET	


;**************************** _f_read ***************************
;Name                         Addr/Register   Size   Type
;_memcpy                             IMPORT  -----   function
;_disk_read                          IMPORT  -----   function
;G_47                                 IX-38      4   variable
;remain                               IX-34      4   variable
;G_45                                 IX-30      4   variable
;clst                                 IX-26      4   variable
;rbuff                                IX-22      3   variable
;csect                                IX-19      3   variable
;res                                  IX-16      3   variable
;cc                                   IX-13      3   variable
;fs                                   IX-10      3   variable
;sect                                  IX-7      4   variable
;rcnt                                  IX-3      3   variable
;br                                   IX+15      3   parameter
;btr                                  IX+12      3   parameter
;buff                                  IX+9      3   parameter
;fp                                    IX+6      3   parameter


; Stack Frame Size: 60 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "f_read",3940,"_f_read"
; 3941	
; 3942	
; 3943	
; 3944	
; 3945	#if !FF_FS_READONLY
; 3946	/*-----------------------------------------------------------------------*/
; 3947	/* Write File                                                            */
; 3948	/*-----------------------------------------------------------------------*/
; 3949	
; 3950	FRESULT f_write (
; 3951		FIL* fp,			/* Open file to be written */
; 3952		const void* buff,	/* Data to be written */
; 3953		UINT btw,			/* Number of bytes to write */
; 3954		UINT* bw			/* Number of bytes written */
; 3955	)
; 3956	{
; 3957		FRESULT res;
; 3958		FATFS *fs;
; 3959		DWORD clst;
; 3960		LBA_t sect;
; 3961		UINT wcnt, cc, csect;
; 3962		const BYTE *wbuff = (const BYTE*)buff;
; 3963	
; 3964	
; 3965		*bw = 0;	/* Clear write byte counter */
; 3966		res = validate(&fp->obj, &fs);			/* Check validity of the file object */
; 3967		if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
; 3968		if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
; 3969	
; 3970		/* Check fptr wrap-around (file size cannot reach 4 GiB at FAT volume) */
; 3971		if ((!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
; 3972			btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
; 3973		}
; 3974	
; 3975		for ( ; btw > 0; btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize) {	/* Repeat until all data written */
; 3976			if (fp->fptr % SS(fs) == 0) {		/* On the sector boundary? */
; 3977				csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);	/* Sector offset in the cluster */
; 3978				if (csect == 0) {				/* On the cluster boundary? */
; 3979					if (fp->fptr == 0) {		/* On the top of the file? */
; 3980						clst = fp->obj.sclust;	/* Follow from the origin */
; 3981						if (clst == 0) {		/* If no cluster is allocated, */
; 3982							clst = create_chain(&fp->obj, 0);	/* create a new cluster chain */
; 3983						}
; 3984					} else {					/* On the middle or end of the file */
; 3985	#if FF_USE_FASTSEEK
; 3986						if (fp->cltbl) {
; 3987							clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
; 3988						} else
; 3989	#endif
; 3990						{
; 3991							clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
; 3992						}
; 3993					}
; 3994					if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
; 3995					if (clst == 1) ABORT(fs, FR_INT_ERR);
; 3996					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
; 3997					fp->clust = clst;			/* Update current cluster */
; 3998					if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
; 3999				}
; 4000	#if FF_FS_TINY
; 4001				if (fs->winsect == fp->sect && sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Write-back sector cache */
; 4002	#else
; 4003				if (fp->flag & FA_DIRTY) {		/* Write-back sector cache */
; 4004					if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
; 4005					fp->flag &= (BYTE)~FA_DIRTY;
; 4006				}
; 4007	#endif
; 4008				sect = clst2sect(fs, fp->clust);	/* Get current sector */
; 4009				if (sect == 0) ABORT(fs, FR_INT_ERR);
; 4010				sect += csect;
; 4011				cc = btw / SS(fs);				/* When remaining bytes >= sector size, */
; 4012				if (cc > 0) {					/* Write maximum contiguous sectors directly */
; 4013					if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
; 4014						cc = fs->csize - csect;
; 4015					}
; 4016					if (disk_write(fs->pdrv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
; 4017	#if FF_FS_MINIMIZE <= 2
; 4018	#if FF_FS_TINY
; 4019					if (fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
; 4020						memcpy(fs->win, wbuff + ((fs->winsect - sect) * SS(fs)), SS(fs));
; 4021						fs->wflag = 0;
; 4022					}
; 4023	#else
; 4024					if (fp->sect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
; 4025						memcpy(fp->buf, wbuff + ((fp->sect - sect) * SS(fs)), SS(fs));
; 4026						fp->flag &= (BYTE)~FA_DIRTY;
; 4027					}
; 4028	#endif
; 4029	#endif
; 4030					wcnt = SS(fs) * cc;		/* Number of bytes transferred */
; 4031					continue;
; 4032				}
; 4033	#if FF_FS_TINY
; 4034				if (fp->fptr >= fp->obj.objsize) {	/* Avoid silly cache filling on the growing edge */
; 4035					if (sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);
; 4036					fs->winsect = sect;
; 4037				}
; 4038	#else
; 4039				if (fp->sect != sect && 		/* Fill sector cache with file data */
; 4040					fp->fptr < fp->obj.objsize &&
; 4041					disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK) {
; 4042						ABORT(fs, FR_DISK_ERR);
; 4043				}
; 4044	#endif
; 4045				fp->sect = sect;
; 4046			}
; 4047			wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes remains in the sector */
; 4048			if (wcnt > btw) wcnt = btw;					/* Clip it by btw if needed */
; 4049	#if FF_FS_TINY
; 4050			if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
; 4051			memcpy(fs->win + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
; 4052			fs->wflag = 1;
; 4053	#else
; 4054			memcpy(fp->buf + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
; 4055			fp->flag |= FA_DIRTY;
; 4056	#endif
; 4057		}
; 4058	
; 4059		fp->flag |= FA_MODIFIED;				/* Set file change flag */
; 4060	
; 4061		LEAVE_FF(fs, FR_OK);
; 4062	}
; 4063	
; 4064	
; 4065	
; 4066	
; 4067	/*-----------------------------------------------------------------------*/
; 4068	/* Synchronize the File                                                  */
; 4069	/*-----------------------------------------------------------------------*/
; 4070	
; 4071	FRESULT f_sync (
; 4072		FIL* fp		/* Open file to be synced */
; 4073	)
; 4074	{
; 4075		FRESULT res;
; 4076		FATFS *fs;
; 4077		DWORD tm;
; 4078		BYTE *dir;
; 4079	
; 4080	
; 4081		res = validate(&fp->obj, &fs);	/* Check validity of the file object */
; 4082		if (res == FR_OK) {
; 4083			if (fp->flag & FA_MODIFIED) {	/* Is there any change to the file? */
; 4084	#if !FF_FS_TINY
; 4085				if (fp->flag & FA_DIRTY) {	/* Write-back cached data if needed */
; 4086					if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
; 4087					fp->flag &= (BYTE)~FA_DIRTY;
; 4088				}
; 4089	#endif
; 4090				/* Update the directory entry */
; 4091				tm = GET_FATTIME();				/* Modified time */
; 4092	#if FF_FS_EXFAT
; 4093				if (fs->fs_type == FS_EXFAT) {
; 4094					res = fill_first_frag(&fp->obj);	/* Fill first fragment on the FAT if needed */
; 4095					if (res == FR_OK) {
; 4096						res = fill_last_frag(&fp->obj, fp->clust, 0xFFFFFFFF);	/* Fill last fragment on the FAT if needed */
; 4097					}
; 4098					if (res == FR_OK) {
; 4099						DIR dj;
; 4100						DEF_NAMBUF
; 4101	
; 4102						INIT_NAMBUF(fs);
; 4103						res = load_obj_xdir(&dj, &fp->obj);	/* Load directory entry block */
; 4104						if (res == FR_OK) {
; 4105							fs->dirbuf[XDIR_Attr] |= AM_ARC;				/* Set archive attribute to indicate that the file has been changed */
; 4106							fs->dirbuf[XDIR_GenFlags] = fp->obj.stat | 1;	/* Update file allocation information */
; 4107							st_dword(fs->dirbuf + XDIR_FstClus, fp->obj.sclust);		/* Update start cluster */
; 4108							st_qword(fs->dirbuf + XDIR_FileSize, fp->obj.objsize);		/* Update file size */
; 4109							st_qword(fs->dirbuf + XDIR_ValidFileSize, fp->obj.objsize);	/* (FatFs does not support Valid File Size feature) */
; 4110							st_dword(fs->dirbuf + XDIR_ModTime, tm);		/* Update modified time */
; 4111							fs->dirbuf[XDIR_ModTime10] = 0;
; 4112							st_dword(fs->dirbuf + XDIR_AccTime, 0);
; 4113							res = store_xdir(&dj);	/* Restore it to the directory */
; 4114							if (res == FR_OK) {
; 4115								res = sync_fs(fs);
; 4116								fp->flag &= (BYTE)~FA_MODIFIED;
; 4117							}
; 4118						}
; 4119						FREE_NAMBUF();
; 4120					}
; 4121				} else
; 4122	#endif
; 4123				{
; 4124					res = move_window(fs, fp->dir_sect);
; 4125					if (res == FR_OK) {
; 4126						dir = fp->dir_ptr;
; 4127						dir[DIR_Attr] |= AM_ARC;						/* Set archive attribute to indicate that the file has been changed */
; 4128						st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation information  */
; 4129						st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
; 4130						st_dword(dir + DIR_ModTime, tm);				/* Update modified time */
; 4131						st_word(dir + DIR_LstAccDate, 0);
; 4132						fs->wflag = 1;
; 4133						res = sync_fs(fs);					/* Restore it to the directory */
; 4134						fp->flag &= (BYTE)~FA_MODIFIED;
; 4135					}
; 4136				}
; 4137			}
; 4138		}
; 4139	
; 4140		LEAVE_FF(fs, res);
; 4141	}
; 4142	
; 4143	#endif /* !FF_FS_READONLY */
; 4144	
; 4145	
; 4146	
; 4147	
; 4148	/*-----------------------------------------------------------------------*/
; 4149	/* Close File                                                            */
; 4150	/*-----------------------------------------------------------------------*/
; 4151	
; 4152	FRESULT f_close (
; 4153		FIL* fp		/* Open file to be closed */
; 4154	)
; 4155	{
_f_close:
.DEFINE "_f_close"

.VALUE _f_close

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "f_close",4155,"_f_close"

.LINE 4155

.DEFINE "fp"

.CLASS 65

.VALUE 6

.TAG "NONAME2"

.TYPE 40

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -6

.TAG "NONAME0"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
; 4156		FRESULT res;
; 4157		FATFS *fs;
; 4158	
; 4159	#if !FF_FS_READONLY
; 4160		res = f_sync(fp);					/* Flush cached data */
; 4161		if (res == FR_OK)
; 4162	#endif
; 4163		{
; 4164			res = validate(&fp->obj, &fs);	/* Lock volume */
.LINE 4164

	PEA	IX+%FFFFFFFA
	LD	IY,(IX+%6)
	PEA	IY+%0
	CALL	_validate
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4165			if (res == FR_OK) {
.LINE 4165

	CALL	__icmpzero
	JR	NZ,L_602
; 4166	#if FF_FS_LOCK != 0
; 4167				res = dec_lock(fp->obj.lockid);		/* Decrement file open counter */
; 4168				if (res == FR_OK) fp->obj.fs = 0;	/* Invalidate file object */
; 4169	#else
; 4170				fp->obj.fs = 0;	/* Invalidate file object */
.LINE 4170

	LD	BC,0
	LD	IY,(IX+%6)
	LD	(IY+%0),BC
; 4171	#endif
; 4172	#if FF_FS_REENTRANT
; 4173				unlock_fs(fs, FR_OK);		/* Unlock volume */
; 4174	#endif
; 4175			}
; 4176		}
L_602:
.LINE 4176

; 4177		return res;
.LINE 4177

	LD	HL,(IX+%FFFFFFFD)
; 4178	}
.LINE 4178

	LD	SP,IX
	POP	IX
	RET	


;**************************** _f_close ***************************
;Name                         Addr/Register   Size   Type
;fs                                    IX-6      3   variable
;res                                   IX-3      3   variable
;fp                                    IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "f_close",4178,"_f_close"
; 4179	
; 4180	
; 4181	
; 4182	
; 4183	#if FF_FS_RPATH >= 1
; 4184	/*-----------------------------------------------------------------------*/
; 4185	/* Change Current Directory or Current Drive, Get Current Directory      */
; 4186	/*-----------------------------------------------------------------------*/
; 4187	
; 4188	FRESULT f_chdrive (
; 4189		const TCHAR* path		/* Drive number to set */
; 4190	)
; 4191	{
_f_chdrive:
.DEFINE "_f_chdrive"

.VALUE _f_chdrive

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "f_chdrive",4191,"_f_chdrive"

.LINE 4191

.DEFINE "path"

.CLASS 65

.VALUE 6

.TYPE 194

.ENDEF

.DEFINE "vol"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
; 4192		int vol;
; 4193	
; 4194	
; 4195		/* Get logical drive number */
; 4196		vol = get_ldnumber(&path);
.LINE 4196

	PEA	IX+%6
	CALL	_get_ldnumber
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4197		if (vol < 0) return FR_INVALID_DRIVE;
.LINE 4197

	CALL	__icmpzero
	JP	P,L_605
	LD	HL,11
	JR	L_606
L_605:
; 4198		CurrVol = (BYTE)vol;	/* Set it as current volume */
.LINE 4198

	LD	A,(IX+%FFFFFFFD)
	LD	(_CurrVol),A
; 4199	
; 4200		return FR_OK;
.LINE 4200

	OR	A,A
	SBC	HL,HL
; 4201	}
L_606:
.LINE 4201

	LD	SP,IX
	POP	IX
	RET	


;**************************** _f_chdrive ***************************
;Name                         Addr/Register   Size   Type
;_CurrVol                            STATIC      1   variable
;vol                                   IX-3      3   variable
;path                                  IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "f_chdrive",4201,"_f_chdrive"
; 4202	
; 4203	
; 4204	
; 4205	FRESULT f_chdir (
; 4206		const TCHAR* path	/* Pointer to the directory path */
; 4207	)
; 4208	{
_f_chdir:
.DEFINE "_f_chdir"

.VALUE _f_chdir

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "f_chdir",4208,"_f_chdir"

.LINE 4208

.DEFINE "path"

.CLASS 65

.VALUE 6

.TYPE 194

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -6

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "dj"

.CLASS 65

.VALUE -52

.TAG "NONAME3"

.TYPE 8

.ENDEF

.DEFINE "lbuf"

.CLASS 65

.VALUE -564

.DIM 256

.TYPE 109

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LD	HL,-564
	ADD	HL,SP
	LD	SP,HL
; 4209	#if FF_STR_VOLUME_ID == 2
; 4210		UINT i;
; 4211	#endif
; 4212		FRESULT res;
; 4213		DIR dj;
; 4214		FATFS *fs;
; 4215		DEF_NAMBUF
; 4216	
; 4217	
; 4218		/* Get logical drive */
; 4219		res = mount_volume(&path, &fs, 0);
.LINE 4219

	LD	BC,0
	PUSH	BC
	PEA	IX+%FFFFFFFA
	PEA	IX+%6
	CALL	_mount_volume
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4220		if (res == FR_OK) {
.LINE 4220

	CALL	__icmpzero
	JR	NZ,L_615
; 4221			dj.obj.fs = fs;
.LINE 4221

	LD	BC,(IX+%FFFFFFFA)
	LD	(IX+%FFFFFFCC),BC
; 4222			INIT_NAMBUF(fs);
.LINE 4222

	LD	HL,IX
	LD	BC,-564
	ADD	HL,BC
	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%B),HL
; 4223			res = follow_path(&dj, path);		/* Follow the path */
.LINE 4223

	LD	BC,(IX+%6)
	PUSH	BC
	PEA	IX+%FFFFFFCC
	CALL	_follow_path
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4224			if (res == FR_OK) {					/* Follow completed */
.LINE 4224

	CALL	__icmpzero
	JR	NZ,L_612
; 4225				if (dj.fn[NSFLAG] & NS_NONAME) {	/* Is it the start directory itself? */
.LINE 4225

	LEA	IY,IX+%FFFFFFEA
	LD	A,(IY+%B)
	AND	A,%80
	JR	Z,L_610
; 4226					fs->cdir = dj.obj.sclust;
.LINE 4226

	LD	BC,(IX+%FFFFFFD3)
	LD	A,(IX+%FFFFFFD6)
	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%E),BC
	LD	(IY+%11),A
; 4227	#if FF_FS_EXFAT
; 4228					if (fs->fs_type == FS_EXFAT) {
; 4229						fs->cdc_scl = dj.obj.c_scl;
; 4230						fs->cdc_size = dj.obj.c_size;
; 4231						fs->cdc_ofs = dj.obj.c_ofs;
; 4232					}
; 4233	#endif
; 4234				} else {
.LINE 4234

	JR	L_612
L_610:
; 4235					if (dj.obj.attr & AM_DIR) {	/* It is a sub-directory */
.LINE 4235

	LD	A,(IX+%FFFFFFD1)
	AND	A,%10
	JR	Z,L_608
; 4236	#if FF_FS_EXFAT
; 4237						if (fs->fs_type == FS_EXFAT) {
; 4238							fs->cdir = ld_dword(fs->dirbuf + XDIR_FstClus);		/* Sub-directory cluster */
; 4239							fs->cdc_scl = dj.obj.sclust;						/* Save containing directory information */
; 4240							fs->cdc_size = ((DWORD)dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;
; 4241							fs->cdc_ofs = dj.blk_ofs;
; 4242						} else
; 4243	#endif
; 4244						{
; 4245							fs->cdir = ld_clust(fs, dj.dir);					/* Sub-directory cluster */
.LINE 4245

	LD	BC,(IX+%FFFFFFE7)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	CALL	_ld_clust
	POP	BC
	POP	BC
	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%E),HL
	LD	(IY+%11),E
; 4246						}
; 4247					} else {
.LINE 4247

	JR	L_612
L_608:
; 4248						res = FR_NO_PATH;		/* Reached but a file */
.LINE 4248

	LD	BC,5
	LD	(IX+%FFFFFFFD),BC
; 4249					}
; 4250				}
; 4251			}
L_612:
.LINE 4251

; 4252			FREE_NAMBUF();
; 4253			if (res == FR_NO_FILE) res = FR_NO_PATH;
.LINE 4253

	LD	BC,4
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_615
	LD	BC,5
	LD	(IX+%FFFFFFFD),BC
; 4254	#if FF_STR_VOLUME_ID == 2	/* Also current drive is changed if in Unix style volume ID */
; 4255			if (res == FR_OK) {
; 4256				for (i = FF_VOLUMES - 1; i && fs != FatFs[i]; i--) ;	/* Set current drive */
; 4257				CurrVol = (BYTE)i;
; 4258			}
; 4259	#endif
; 4260		}
L_615:
.LINE 4260

; 4261	
; 4262		LEAVE_FF(fs, res);
.LINE 4262

	LD	HL,(IX+%FFFFFFFD)
; 4263	}
.LINE 4263

	LD	SP,IX
	POP	IX
	RET	


;**************************** _f_chdir ***************************
;Name                         Addr/Register   Size   Type
;lbuf                                IX-564    512   variable
;dj                                   IX-52     46   variable
;fs                                    IX-6      3   variable
;res                                   IX-3      3   variable
;path                                  IX+6      3   parameter


; Stack Frame Size: 573 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "f_chdir",4263,"_f_chdir"
; 4264	
; 4265	
; 4266	#if FF_FS_RPATH >= 2
; 4267	FRESULT f_getcwd (
; 4268		TCHAR* buff,	/* Pointer to the directory path */
; 4269		UINT len		/* Size of buff in unit of TCHAR */
; 4270	)
; 4271	{
_f_getcwd:
.DEFINE "_f_getcwd"

.VALUE _f_getcwd

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "f_getcwd",4271,"_f_getcwd"

.LINE 4271

.DEFINE "buff"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "len"

.CLASS 65

.VALUE 9

.TYPE 14

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -6

.TYPE 14

.ENDEF

.DEFINE "n"

.CLASS 65

.VALUE -9

.TYPE 14

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -12

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "tp"

.CLASS 65

.VALUE -15

.TYPE 34

.ENDEF

.DEFINE "ccl"

.CLASS 65

.VALUE -19

.TYPE 15

.ENDEF

.DEFINE "dj"

.CLASS 65

.VALUE -65

.TAG "NONAME3"

.TYPE 8

.ENDEF

.DEFINE "fno"

.CLASS 65

.VALUE -343

.TAG "NONAME4"

.TYPE 8

.ENDEF

.DEFINE "lbuf"

.CLASS 65

.VALUE -855

.DIM 256

.TYPE 109

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LD	HL,-861
	ADD	HL,SP
	LD	SP,HL
; 4272		FRESULT res;
; 4273		DIR dj;
; 4274		FATFS *fs;
; 4275		UINT i, n;
; 4276		DWORD ccl;
; 4277		TCHAR *tp = buff;
.LINE 4277

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFF1),BC
; 4278	#if FF_VOLUMES >= 2
; 4279		UINT vl;
; 4280	#if FF_STR_VOLUME_ID
; 4281		const char *vp;
; 4282	#endif
; 4283	#endif
; 4284		FILINFO fno;
; 4285		DEF_NAMBUF
; 4286	
; 4287	
; 4288		/* Get logical drive */
; 4289		buff[0] = 0;	/* Set null string to get current volume */
.LINE 4289

	LD	HL,(IX+%6)
	LD	(HL),%0
; 4290		res = mount_volume((const TCHAR**)&buff, &fs, 0);	/* Get current volume */
.LINE 4290

	LD	BC,0
	PUSH	BC
	PEA	IX+%FFFFFFF4
	PEA	IX+%6
	CALL	_mount_volume
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4291		if (res == FR_OK) {
.LINE 4291

	CALL	__icmpzero
	JR	NZ,L_658
; 4292			dj.obj.fs = fs;
.LINE 4292

	LEA	HL,IX+%FFFFFFBF
	LD	BC,-858
	CALL	__istix
	LD	BC,(IX+%FFFFFFF4)
	LD	(IX+%FFFFFFBF),BC
; 4293			INIT_NAMBUF(fs);
.LINE 4293

	LD	HL,IX
	LD	BC,-855
	ADD	HL,BC
	LD	IY,(IX+%FFFFFFF4)
	LD	(IY+%B),HL
; 4294	
; 4295			/* Follow parent directories and create the path */
; 4296			i = len;			/* Bottom of buffer (directory stack base) */
.LINE 4296

	LD	BC,(IX+%9)
	LD	(IX+%FFFFFFFA),BC
; 4297			if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {	/* (Cannot do getcwd on exFAT and returns root path) */
; 4298				dj.obj.sclust = fs->cdir;				/* Start to follow upper directory from current directory */
.LINE 4298

	LD	BC,-858
	CALL	__ildix
	LD	BC,(IY+%E)
	LD	A,(IY+%11)
	LD	IY,HL
	LD	(IY+%7),BC
	LD	(IY+%A),A
; 4299				while ((ccl = dj.obj.sclust) != 0) {	/* Repeat while current directory is a sub-directory */
.LINE 4299

	JR	L_644
L_645:
; 4300					res = dir_sdi(&dj, 1 * SZDIRE);	/* Get parent directory */
.LINE 4300

	LD	BC,0
	PUSH	BC
	LD	BC,32
	PUSH	BC
	PEA	IX+%FFFFFFBF
	CALL	_dir_sdi
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4301					if (res != FR_OK) break;
.LINE 4301

	CALL	__icmpzero
	JR	NZ,L_655
; 4302					res = move_window(fs, dj.sect);
.LINE 4302

	LD	C,(IX+%FFFFFFD9)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFD6)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF4)
	PUSH	BC
	CALL	_move_window
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4303					if (res != FR_OK) break;
.LINE 4303

	CALL	__icmpzero
	JR	NZ,L_655
; 4304					dj.obj.sclust = ld_clust(fs, dj.dir);	/* Goto parent directory */
.LINE 4304

	LD	BC,(IX+%FFFFFFDA)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF4)
	PUSH	BC
	CALL	_ld_clust
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFC6),HL
	LD	(IX+%FFFFFFC9),E
; 4305					res = dir_sdi(&dj, 0);
.LINE 4305

	LD	BC,0
	PUSH	BC
	PUSH	BC
	PEA	IX+%FFFFFFBF
	CALL	_dir_sdi
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4306					if (res != FR_OK) break;
.LINE 4306

	CALL	__icmpzero
	JR	NZ,L_655
; 4307					do {							/* Find the entry links to the child directory */
L_626:
.LINE 4307

; 4308						res = DIR_READ_FILE(&dj);
.LINE 4308

	LD	BC,0
	PUSH	BC
	PEA	IX+%FFFFFFBF
	CALL	_dir_read
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4309						if (res != FR_OK) break;
.LINE 4309

	CALL	__icmpzero
	JR	NZ,L_630
; 4310						if (ccl == ld_clust(fs, dj.dir)) break;	/* Found the entry */
.LINE 4310

	LD	BC,(IX+%FFFFFFDA)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF4)
	PUSH	BC
	CALL	_ld_clust
	POP	BC
	POP	BC
	LD	BC,(IX+%FFFFFFED)
	LD	A,(IX+%FFFFFFF0)
	CALL	__lcmpu
	JR	Z,L_630
; 4311						res = dir_next(&dj, 0);
.LINE 4311

	LD	BC,0
	PUSH	BC
	PEA	IX+%FFFFFFBF
	CALL	_dir_next
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4312					} while (res == FR_OK);
.LINE 4312

	CALL	__icmpzero
	JR	Z,L_626
L_630:
; 4313					if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
.LINE 4313

	LD	BC,4
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_632
	LD	BC,2
	LD	(IX+%FFFFFFFD),BC
L_632:
; 4314					if (res != FR_OK) break;
.LINE 4314

	LD	HL,(IX+%FFFFFFFD)
	CALL	__icmpzero
	JR	NZ,L_655
; 4315					get_fileinfo(&dj, &fno);		/* Get the directory name and push it to the buffer */
.LINE 4315

	LD	HL,IX
	LD	BC,-343
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	PEA	IX+%FFFFFFBF
	CALL	_get_fileinfo
	POP	BC
	POP	BC
; 4316					for (n = 0; fno.fname[n]; n++) ;	/* Name length */
.LINE 4316

	LD	BC,0
	LD	(IX+%FFFFFFF7),BC
	JR	L_637
L_635:
	LD	BC,(IX+%FFFFFFF7)
	INC	BC
	LD	(IX+%FFFFFFF7),BC
L_637:
	LD	BC,(IX+%FFFFFFF7)
	LD	HL,IX
	LD	DE,-321
	ADD	HL,DE
	ADD	HL,BC
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_635
; 4317					if (i < n + 1) {	/* Insufficient space to store the path name? */
.LINE 4317

	LD	BC,(IX+%FFFFFFF7)
	INC	BC
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_640
; 4318						res = FR_NOT_ENOUGH_CORE; break;
.LINE 4318

	LD	BC,17
	LD	(IX+%FFFFFFFD),BC
	JR	L_655
; 4319					}
.LINE 4319

; 4320					while (n) buff[--i] = fno.fname[--n];	/* Stack the name */
.LINE 4320

L_641:
	LD	IY,(IX+%FFFFFFF7)
	LEA	BC,IY+%FFFFFFFF
	LD	(IX+%FFFFFFF7),BC
	LD	IY,(IX+%FFFFFFFA)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%FFFFFFFA),IY
	LD	BC,(IX+%FFFFFFF7)
	LD	HL,IX
	LD	DE,-321
	ADD	HL,DE
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IX+%FFFFFFFA)
	LD	HL,(IX+%6)
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
L_640:
	LD	HL,(IX+%FFFFFFF7)
	CALL	__icmpzero
	JR	NZ,L_641
; 4321					buff[--i] = '/';
.LINE 4321

	LD	IY,(IX+%FFFFFFFA)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%FFFFFFFA),IY
	LD	BC,IY
	LD	HL,(IX+%6)
	ADD	HL,BC
	LD	(HL),%2F
; 4322				}
L_644:
.LINE 4322

	LD	BC,(IX+%FFFFFFC6)
	LD	A,(IX+%FFFFFFC9)
	LD	(IX+%FFFFFFED),BC
	LD	(IX+%FFFFFFF0),A
	LD	HL,BC
	LD	E,(IX+%FFFFFFF0)
	CALL	__lcmpzero
	JR	NZ,L_645
; 4323			}
L_655:
.LINE 4323

; 4324			if (res == FR_OK) {
.LINE 4324

	LD	HL,(IX+%FFFFFFFD)
	CALL	__icmpzero
	JR	NZ,L_656
; 4325				if (i == len) buff[--i] = '/';	/* Is it the root-directory? */
.LINE 4325

	LD	BC,(IX+%9)
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_653
	LD	IY,(IX+%FFFFFFFA)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%FFFFFFFA),IY
	LD	BC,IY
	LD	HL,(IX+%6)
	ADD	HL,BC
	LD	(HL),%2F
L_653:
; 4326	#if FF_VOLUMES >= 2			/* Put drive prefix */
; 4327				vl = 0;
; 4328	#if FF_STR_VOLUME_ID >= 1	/* String volume ID */
; 4329				for (n = 0, vp = (const char*)VolumeStr[CurrVol]; vp[n]; n++) ;
; 4330				if (i >= n + 2) {
; 4331					if (FF_STR_VOLUME_ID == 2) *tp++ = (TCHAR)'/';
; 4332					for (vl = 0; vl < n; *tp++ = (TCHAR)vp[vl], vl++) ;
; 4333					if (FF_STR_VOLUME_ID == 1) *tp++ = (TCHAR)':';
; 4334					vl++;
; 4335				}
; 4336	#else						/* Numeric volume ID */
; 4337				if (i >= 3) {
; 4338					*tp++ = (TCHAR)'0' + CurrVol;
; 4339					*tp++ = (TCHAR)':';
; 4340					vl = 2;
; 4341				}
; 4342	#endif
; 4343				if (vl == 0) res = FR_NOT_ENOUGH_CORE;
; 4344	#endif
; 4345				/* Add current directory path */
; 4346				if (res == FR_OK) {
.LINE 4346

	LD	HL,(IX+%FFFFFFFD)
	CALL	__icmpzero
	JR	NZ,L_656
; 4347					do *tp++ = buff[i++]; while (i < len);	/* Copy stacked path string */
L_650:
.LINE 4347

	LD	HL,(IX+%FFFFFFF1)
	LD	BC,-861
	CALL	__istix
	LD	BC,(IX+%FFFFFFFA)
	LD	HL,(IX+%6)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,-861
	CALL	__ildix
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+%FFFFFFFA)
	INC	BC
	LD	(IX+%FFFFFFFA),BC
	LD	BC,(IX+%FFFFFFF1)
	INC	BC
	LD	(IX+%FFFFFFF1),BC
	LD	BC,(IX+%9)
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	C,L_650
; 4348				}
; 4349			}
L_656:
.LINE 4349

; 4350			FREE_NAMBUF();
; 4351		}
L_658:
.LINE 4351

; 4352	
; 4353		*tp = 0;
.LINE 4353

	LD	HL,(IX+%FFFFFFF1)
	LD	(HL),%0
; 4354		LEAVE_FF(fs, res);
.LINE 4354

	LD	HL,(IX+%FFFFFFFD)
; 4355	}
.LINE 4355

	LD	SP,IX
	POP	IX
	RET	


;**************************** _f_getcwd ***************************
;Name                         Addr/Register   Size   Type
;lbuf                                IX-855    512   variable
;fno                                 IX-343    278   variable
;dj                                   IX-65     46   variable
;ccl                                  IX-19      4   variable
;tp                                   IX-15      3   variable
;fs                                   IX-12      3   variable
;n                                     IX-9      3   variable
;i                                     IX-6      3   variable
;res                                   IX-3      3   variable
;len                                   IX+9      3   parameter
;buff                                  IX+6      3   parameter


; Stack Frame Size: 873 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "f_getcwd",4355,"_f_getcwd"
; 4356	
; 4357	#endif /* FF_FS_RPATH >= 2 */
; 4358	#endif /* FF_FS_RPATH >= 1 */
; 4359	
; 4360	
; 4361	
; 4362	#if FF_FS_MINIMIZE <= 2
; 4363	/*-----------------------------------------------------------------------*/
; 4364	/* Seek File Read/Write Pointer                                          */
; 4365	/*-----------------------------------------------------------------------*/
; 4366	
; 4367	FRESULT f_lseek (
; 4368		FIL* fp,		/* Pointer to the file object */
; 4369		FSIZE_t ofs		/* File pointer from top of file */
; 4370	)
; 4371	{
; 4372		FRESULT res;
; 4373		FATFS *fs;
; 4374		DWORD clst, bcs;
; 4375		LBA_t nsect;
; 4376		FSIZE_t ifptr;
; 4377	#if FF_USE_FASTSEEK
; 4378		DWORD cl, pcl, ncl, tcl, tlen, ulen;
; 4379		DWORD *tbl;
; 4380		LBA_t dsc;
; 4381	#endif
; 4382	
; 4383		res = validate(&fp->obj, &fs);		/* Check validity of the file object */
; 4384		if (res == FR_OK) res = (FRESULT)fp->err;
; 4385	#if FF_FS_EXFAT && !FF_FS_READONLY
; 4386		if (res == FR_OK && fs->fs_type == FS_EXFAT) {
; 4387			res = fill_last_frag(&fp->obj, fp->clust, 0xFFFFFFFF);	/* Fill last fragment on the FAT if needed */
; 4388		}
; 4389	#endif
; 4390		if (res != FR_OK) LEAVE_FF(fs, res);
; 4391	
; 4392	#if FF_USE_FASTSEEK
; 4393		if (fp->cltbl) {	/* Fast seek */
; 4394			if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
; 4395				tbl = fp->cltbl;
; 4396				tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
; 4397				cl = fp->obj.sclust;		/* Origin of the chain */
; 4398				if (cl != 0) {
; 4399					do {
; 4400						/* Get a fragment */
; 4401						tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
; 4402						do {
; 4403							pcl = cl; ncl++;
; 4404							cl = get_fat(&fp->obj, cl);
; 4405							if (cl <= 1) ABORT(fs, FR_INT_ERR);
; 4406							if (cl == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
; 4407						} while (cl == pcl + 1);
; 4408						if (ulen <= tlen) {		/* Store the length and top of the fragment */
; 4409							*tbl++ = ncl; *tbl++ = tcl;
; 4410						}
; 4411					} while (cl < fs->n_fatent);	/* Repeat until end of chain */
; 4412				}
; 4413				*fp->cltbl = ulen;	/* Number of items used */
; 4414				if (ulen <= tlen) {
; 4415					*tbl = 0;		/* Terminate table */
; 4416				} else {
; 4417					res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
; 4418				}
; 4419			} else {						/* Fast seek */
; 4420				if (ofs > fp->obj.objsize) ofs = fp->obj.objsize;	/* Clip offset at the file size */
; 4421				fp->fptr = ofs;				/* Set file pointer */
; 4422				if (ofs > 0) {
; 4423					fp->clust = clmt_clust(fp, ofs - 1);
; 4424					dsc = clst2sect(fs, fp->clust);
; 4425					if (dsc == 0) ABORT(fs, FR_INT_ERR);
; 4426					dsc += (DWORD)((ofs - 1) / SS(fs)) & (fs->csize - 1);
; 4427					if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
; 4428	#if !FF_FS_TINY
; 4429	#if !FF_FS_READONLY
; 4430						if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
; 4431							if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
; 4432							fp->flag &= (BYTE)~FA_DIRTY;
; 4433						}
; 4434	#endif
; 4435						if (disk_read(fs->pdrv, fp->buf, dsc, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Load current sector */
; 4436	#endif
; 4437						fp->sect = dsc;
; 4438					}
; 4439				}
; 4440			}
; 4441		} else
; 4442	#endif
; 4443	
; 4444		/* Normal Seek */
; 4445		{
; 4446	#if FF_FS_EXFAT
; 4447			if (fs->fs_type != FS_EXFAT && ofs >= 0x100000000) ofs = 0xFFFFFFFF;	/* Clip at 4 GiB - 1 if at FATxx */
; 4448	#endif
; 4449			if (ofs > fp->obj.objsize && (FF_FS_READONLY || !(fp->flag & FA_WRITE))) {	/* In read-only mode, clip offset with the file size */
; 4450				ofs = fp->obj.objsize;
; 4451			}
; 4452			ifptr = fp->fptr;
; 4453			fp->fptr = nsect = 0;
; 4454			if (ofs > 0) {
; 4455				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size (byte) */
; 4456				if (ifptr > 0 &&
; 4457					(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
; 4458					fp->fptr = (ifptr - 1) & ~(FSIZE_t)(bcs - 1);	/* start from the current cluster */
; 4459					ofs -= fp->fptr;
; 4460					clst = fp->clust;
; 4461				} else {									/* When seek to back cluster, */
; 4462					clst = fp->obj.sclust;					/* start from the first cluster */
; 4463	#if !FF_FS_READONLY
; 4464					if (clst == 0) {						/* If no cluster chain, create a new chain */
; 4465						clst = create_chain(&fp->obj, 0);
; 4466						if (clst == 1) ABORT(fs, FR_INT_ERR);
; 4467						if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
; 4468						fp->obj.sclust = clst;
; 4469					}
; 4470	#endif
; 4471					fp->clust = clst;
; 4472				}
; 4473				if (clst != 0) {
; 4474					while (ofs > bcs) {						/* Cluster following loop */
; 4475						ofs -= bcs; fp->fptr += bcs;
; 4476	#if !FF_FS_READONLY
; 4477						if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
; 4478							if (FF_FS_EXFAT && fp->fptr > fp->obj.objsize) {	/* No FAT chain object needs correct objsize to generate FAT value */
; 4479								fp->obj.objsize = fp->fptr;
; 4480								fp->flag |= FA_MODIFIED;
; 4481							}
; 4482							clst = create_chain(&fp->obj, clst);	/* Follow chain with forceed stretch */
; 4483							if (clst == 0) {				/* Clip file size in case of disk full */
; 4484								ofs = 0; break;
; 4485							}
; 4486						} else
; 4487	#endif
; 4488						{
; 4489							clst = get_fat(&fp->obj, clst);	/* Follow cluster chain if not in write mode */
; 4490						}
; 4491						if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
; 4492						if (clst <= 1 || clst >= fs->n_fatent) ABORT(fs, FR_INT_ERR);
; 4493						fp->clust = clst;
; 4494					}
; 4495					fp->fptr += ofs;
; 4496					if (ofs % SS(fs)) {
; 4497						nsect = clst2sect(fs, clst);	/* Current sector */
; 4498						if (nsect == 0) ABORT(fs, FR_INT_ERR);
; 4499						nsect += (DWORD)(ofs / SS(fs));
; 4500					}
; 4501				}
; 4502			}
; 4503			if (!FF_FS_READONLY && fp->fptr > fp->obj.objsize) {	/* Set file change flag if the file size is extended */
; 4504				fp->obj.objsize = fp->fptr;
; 4505				fp->flag |= FA_MODIFIED;
; 4506			}
; 4507			if (fp->fptr % SS(fs) && nsect != fp->sect) {	/* Fill sector cache if needed */
; 4508	#if !FF_FS_TINY
; 4509	#if !FF_FS_READONLY
; 4510				if (fp->flag & FA_DIRTY) {			/* Write-back dirty sector cache */
; 4511					if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
; 4512					fp->flag &= (BYTE)~FA_DIRTY;
; 4513				}
; 4514	#endif
; 4515				if (disk_read(fs->pdrv, fp->buf, nsect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
; 4516	#endif
; 4517				fp->sect = nsect;
; 4518			}
; 4519		}
; 4520	
; 4521		LEAVE_FF(fs, res);
; 4522	}
; 4523	
; 4524	
; 4525	
; 4526	#if FF_FS_MINIMIZE <= 1
; 4527	/*-----------------------------------------------------------------------*/
; 4528	/* Create a Directory Object                                             */
; 4529	/*-----------------------------------------------------------------------*/
; 4530	
; 4531	FRESULT f_opendir (
; 4532		DIR* dp,			/* Pointer to directory object to create */
; 4533		const TCHAR* path	/* Pointer to the directory path */
; 4534	)
; 4535	{
; 4536		FRESULT res;
; 4537		FATFS *fs;
; 4538		DEF_NAMBUF
; 4539	
; 4540	
; 4541		if (!dp) return FR_INVALID_OBJECT;
; 4542	
; 4543		/* Get logical drive */
; 4544		res = mount_volume(&path, &fs, 0);
; 4545		if (res == FR_OK) {
; 4546			dp->obj.fs = fs;
; 4547			INIT_NAMBUF(fs);
; 4548			res = follow_path(dp, path);			/* Follow the path to the directory */
; 4549			if (res == FR_OK) {						/* Follow completed */
; 4550				if (!(dp->fn[NSFLAG] & NS_NONAME)) {	/* It is not the origin directory itself */
; 4551					if (dp->obj.attr & AM_DIR) {		/* This object is a sub-directory */
; 4552	#if FF_FS_EXFAT
; 4553						if (fs->fs_type == FS_EXFAT) {
; 4554							dp->obj.c_scl = dp->obj.sclust;							/* Get containing directory inforamation */
; 4555							dp->obj.c_size = ((DWORD)dp->obj.objsize & 0xFFFFFF00) | dp->obj.stat;
; 4556							dp->obj.c_ofs = dp->blk_ofs;
; 4557							init_alloc_info(fs, &dp->obj);	/* Get object allocation info */
; 4558						} else
; 4559	#endif
; 4560						{
; 4561							dp->obj.sclust = ld_clust(fs, dp->dir);	/* Get object allocation info */
; 4562						}
; 4563					} else {						/* This object is a file */
; 4564						res = FR_NO_PATH;
; 4565					}
; 4566				}
; 4567				if (res == FR_OK) {
; 4568					dp->obj.id = fs->id;
; 4569					res = dir_sdi(dp, 0);			/* Rewind directory */
; 4570	#if FF_FS_LOCK != 0
; 4571					if (res == FR_OK) {
; 4572						if (dp->obj.sclust != 0) {
; 4573							dp->obj.lockid = inc_lock(dp, 0);	/* Lock the sub directory */
; 4574							if (!dp->obj.lockid) res = FR_TOO_MANY_OPEN_FILES;
; 4575						} else {
; 4576							dp->obj.lockid = 0;	/* Root directory need not to be locked */
; 4577						}
; 4578					}
; 4579	#endif
; 4580				}
; 4581			}
; 4582			FREE_NAMBUF();
; 4583			if (res == FR_NO_FILE) res = FR_NO_PATH;
; 4584		}
; 4585		if (res != FR_OK) dp->obj.fs = 0;		/* Invalidate the directory object if function faild */
; 4586	
; 4587		LEAVE_FF(fs, res);
; 4588	}
; 4589	
; 4590	
; 4591	
; 4592	
; 4593	/*-----------------------------------------------------------------------*/
; 4594	/* Close Directory                                                       */
; 4595	/*-----------------------------------------------------------------------*/
; 4596	
; 4597	FRESULT f_closedir (
; 4598		DIR *dp		/* Pointer to the directory object to be closed */
; 4599	)
; 4600	{
; 4601		FRESULT res;
; 4602		FATFS *fs;
; 4603	
; 4604	
; 4605		res = validate(&dp->obj, &fs);	/* Check validity of the file object */
; 4606		if (res == FR_OK) {
; 4607	#if FF_FS_LOCK != 0
; 4608			if (dp->obj.lockid) res = dec_lock(dp->obj.lockid);	/* Decrement sub-directory open counter */
; 4609			if (res == FR_OK) dp->obj.fs = 0;	/* Invalidate directory object */
; 4610	#else
; 4611			dp->obj.fs = 0;	/* Invalidate directory object */
; 4612	#endif
; 4613	#if FF_FS_REENTRANT
; 4614			unlock_fs(fs, FR_OK);		/* Unlock volume */
; 4615	#endif
; 4616		}
; 4617		return res;
; 4618	}
; 4619	
; 4620	
; 4621	
; 4622	
; 4623	/*-----------------------------------------------------------------------*/
; 4624	/* Read Directory Entries in Sequence                                    */
; 4625	/*-----------------------------------------------------------------------*/
; 4626	
; 4627	FRESULT f_readdir (
; 4628		DIR* dp,			/* Pointer to the open directory object */
; 4629		FILINFO* fno		/* Pointer to file information to return */
; 4630	)
; 4631	{
; 4632		FRESULT res;
; 4633		FATFS *fs;
; 4634		DEF_NAMBUF
; 4635	
; 4636	
; 4637		res = validate(&dp->obj, &fs);	/* Check validity of the directory object */
; 4638		if (res == FR_OK) {
; 4639			if (!fno) {
; 4640				res = dir_sdi(dp, 0);			/* Rewind the directory object */
; 4641			} else {
; 4642				INIT_NAMBUF(fs);
; 4643				res = DIR_READ_FILE(dp);		/* Read an item */
; 4644				if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory */
; 4645				if (res == FR_OK) {				/* A valid entry is found */
; 4646					get_fileinfo(dp, fno);		/* Get the object information */
; 4647					res = dir_next(dp, 0);		/* Increment index for next */
; 4648					if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory now */
; 4649				}
; 4650				FREE_NAMBUF();
; 4651			}
; 4652		}
; 4653		LEAVE_FF(fs, res);
; 4654	}
; 4655	
; 4656	
; 4657	
; 4658	#if FF_USE_FIND
; 4659	/*-----------------------------------------------------------------------*/
; 4660	/* Find Next File                                                        */
; 4661	/*-----------------------------------------------------------------------*/
; 4662	
; 4663	FRESULT f_findnext (
; 4664		DIR* dp,		/* Pointer to the open directory object */
; 4665		FILINFO* fno	/* Pointer to the file information structure */
; 4666	)
; 4667	{
; 4668		FRESULT res;
; 4669	
; 4670	
; 4671		for (;;) {
; 4672			res = f_readdir(dp, fno);		/* Get a directory item */
; 4673			if (res != FR_OK || !fno || !fno->fname[0]) break;	/* Terminate if any error or end of directory */
; 4674			if (pattern_match(dp->pat, fno->fname, 0, FIND_RECURS)) break;		/* Test for the file name */
; 4675	#if FF_USE_LFN && FF_USE_FIND == 2
; 4676			if (pattern_match(dp->pat, fno->altname, 0, FIND_RECURS)) break;	/* Test for alternative name if exist */
; 4677	#endif
; 4678		}
; 4679		return res;
; 4680	}
; 4681	
; 4682	
; 4683	
; 4684	/*-----------------------------------------------------------------------*/
; 4685	/* Find First File                                                       */
; 4686	/*-----------------------------------------------------------------------*/
; 4687	
; 4688	FRESULT f_findfirst (
; 4689		DIR* dp,				/* Pointer to the blank directory object */
; 4690		FILINFO* fno,			/* Pointer to the file information structure */
; 4691		const TCHAR* path,		/* Pointer to the directory to open */
; 4692		const TCHAR* pattern	/* Pointer to the matching pattern */
; 4693	)
; 4694	{
; 4695		FRESULT res;
; 4696	
; 4697	
; 4698		dp->pat = pattern;		/* Save pointer to pattern string */
; 4699		res = f_opendir(dp, path);		/* Open the target directory */
; 4700		if (res == FR_OK) {
; 4701			res = f_findnext(dp, fno);	/* Find the first item */
; 4702		}
; 4703		return res;
; 4704	}
; 4705	
; 4706	#endif	/* FF_USE_FIND */
; 4707	
; 4708	
; 4709	
; 4710	#if FF_FS_MINIMIZE == 0
; 4711	/*-----------------------------------------------------------------------*/
; 4712	/* Get File Status                                                       */
; 4713	/*-----------------------------------------------------------------------*/
; 4714	
; 4715	FRESULT f_stat (
; 4716		const TCHAR* path,	/* Pointer to the file path */
; 4717		FILINFO* fno		/* Pointer to file information to return */
; 4718	)
; 4719	{
; 4720		FRESULT res;
; 4721		DIR dj;
; 4722		DEF_NAMBUF
; 4723	
; 4724	
; 4725		/* Get logical drive */
; 4726		res = mount_volume(&path, &dj.obj.fs, 0);
; 4727		if (res == FR_OK) {
; 4728			INIT_NAMBUF(dj.obj.fs);
; 4729			res = follow_path(&dj, path);	/* Follow the file path */
; 4730			if (res == FR_OK) {				/* Follow completed */
; 4731				if (dj.fn[NSFLAG] & NS_NONAME) {	/* It is origin directory */
; 4732					res = FR_INVALID_NAME;
; 4733				} else {							/* Found an object */
; 4734					if (fno) get_fileinfo(&dj, fno);
; 4735				}
; 4736			}
; 4737			FREE_NAMBUF();
; 4738		}
; 4739	
; 4740		LEAVE_FF(dj.obj.fs, res);
; 4741	}
; 4742	
; 4743	
; 4744	
; 4745	#if !FF_FS_READONLY
; 4746	/*-----------------------------------------------------------------------*/
; 4747	/* Get Number of Free Clusters                                           */
; 4748	/*-----------------------------------------------------------------------*/
; 4749	
; 4750	FRESULT f_getfree (
; 4751		const TCHAR* path,	/* Logical drive number */
; 4752		DWORD* nclst,		/* Pointer to a variable to return number of free clusters */
; 4753		FATFS** fatfs		/* Pointer to return pointer to corresponding filesystem object */
; 4754	)
; 4755	{
; 4756		FRESULT res;
; 4757		FATFS *fs;
; 4758		DWORD nfree, clst, stat;
; 4759		LBA_t sect;
; 4760		UINT i;
; 4761		FFOBJID obj;
; 4762	
; 4763	
; 4764		/* Get logical drive */
; 4765		res = mount_volume(&path, &fs, 0);
; 4766		if (res == FR_OK) {
; 4767			*fatfs = fs;				/* Return ptr to the fs object */
; 4768			/* If free_clst is valid, return it without full FAT scan */
; 4769			if (fs->free_clst <= fs->n_fatent - 2) {
; 4770				*nclst = fs->free_clst;
; 4771			} else {
; 4772				/* Scan FAT to obtain number of free clusters */
; 4773				nfree = 0;
; 4774				if (fs->fs_type == FS_FAT12) {	/* FAT12: Scan bit field FAT entries */
; 4775					clst = 2; obj.fs = fs;
; 4776					do {
; 4777						stat = get_fat(&obj, clst);
; 4778						if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
; 4779						if (stat == 1) { res = FR_INT_ERR; break; }
; 4780						if (stat == 0) nfree++;
; 4781					} while (++clst < fs->n_fatent);
; 4782				} else {
; 4783	#if FF_FS_EXFAT
; 4784					if (fs->fs_type == FS_EXFAT) {	/* exFAT: Scan allocation bitmap */
; 4785						BYTE bm;
; 4786						UINT b;
; 4787	
; 4788						clst = fs->n_fatent - 2;	/* Number of clusters */
; 4789						sect = fs->bitbase;			/* Bitmap sector */
; 4790						i = 0;						/* Offset in the sector */
; 4791						do {	/* Counts numbuer of bits with zero in the bitmap */
; 4792							if (i == 0) {
; 4793								res = move_window(fs, sect++);
; 4794								if (res != FR_OK) break;
; 4795							}
; 4796							for (b = 8, bm = fs->win[i]; b && clst; b--, clst--) {
; 4797								if (!(bm & 1)) nfree++;
; 4798								bm >>= 1;
; 4799							}
; 4800							i = (i + 1) % SS(fs);
; 4801						} while (clst);
; 4802					} else
; 4803	#endif
; 4804					{	/* FAT16/32: Scan WORD/DWORD FAT entries */
; 4805						clst = fs->n_fatent;	/* Number of entries */
; 4806						sect = fs->fatbase;		/* Top of the FAT */
; 4807						i = 0;					/* Offset in the sector */
; 4808						do {	/* Counts numbuer of entries with zero in the FAT */
; 4809							if (i == 0) {
; 4810								res = move_window(fs, sect++);
; 4811								if (res != FR_OK) break;
; 4812							}
; 4813							if (fs->fs_type == FS_FAT16) {
; 4814								if (ld_word(fs->win + i) == 0) nfree++;
; 4815								i += 2;
; 4816							} else {
; 4817								if ((ld_dword(fs->win + i) & 0x0FFFFFFF) == 0) nfree++;
; 4818								i += 4;
; 4819							}
; 4820							i %= SS(fs);
; 4821						} while (--clst);
; 4822					}
; 4823				}
; 4824				if (res == FR_OK) {		/* Update parameters if succeeded */
; 4825					*nclst = nfree;			/* Return the free clusters */
; 4826					fs->free_clst = nfree;	/* Now free_clst is valid */
; 4827					fs->fsi_flag |= 1;		/* FAT32: FSInfo is to be updated */
; 4828				}
; 4829			}
; 4830		}
; 4831	
; 4832		LEAVE_FF(fs, res);
; 4833	}
; 4834	
; 4835	
; 4836	
; 4837	
; 4838	/*-----------------------------------------------------------------------*/
; 4839	/* Truncate File                                                         */
; 4840	/*-----------------------------------------------------------------------*/
; 4841	
; 4842	FRESULT f_truncate (
; 4843		FIL* fp		/* Pointer to the file object */
; 4844	)
; 4845	{
; 4846		FRESULT res;
; 4847		FATFS *fs;
; 4848		DWORD ncl;
; 4849	
; 4850	
; 4851		res = validate(&fp->obj, &fs);	/* Check validity of the file object */
; 4852		if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);
; 4853		if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
; 4854	
; 4855		if (fp->fptr < fp->obj.objsize) {	/* Process when fptr is not on the eof */
; 4856			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
; 4857				res = remove_chain(&fp->obj, fp->obj.sclust, 0);
; 4858				fp->obj.sclust = 0;
; 4859			} else {				/* When truncate a part of the file, remove remaining clusters */
; 4860				ncl = get_fat(&fp->obj, fp->clust);
; 4861				res = FR_OK;
; 4862				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
; 4863				if (ncl == 1) res = FR_INT_ERR;
; 4864				if (res == FR_OK && ncl < fs->n_fatent) {
; 4865					res = remove_chain(&fp->obj, ncl, fp->clust);
; 4866				}
; 4867			}
; 4868			fp->obj.objsize = fp->fptr;	/* Set file size to current read/write point */
; 4869			fp->flag |= FA_MODIFIED;
; 4870	#if !FF_FS_TINY
; 4871			if (res == FR_OK && (fp->flag & FA_DIRTY)) {
; 4872				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) {
; 4873					res = FR_DISK_ERR;
; 4874				} else {
; 4875					fp->flag &= (BYTE)~FA_DIRTY;
; 4876				}
; 4877			}
; 4878	#endif
; 4879			if (res != FR_OK) ABORT(fs, res);
; 4880		}
; 4881	
; 4882		LEAVE_FF(fs, res);
; 4883	}
; 4884	
; 4885	
; 4886	
; 4887	
; 4888	/*-----------------------------------------------------------------------*/
; 4889	/* Delete a File/Directory                                               */
; 4890	/*-----------------------------------------------------------------------*/
; 4891	
; 4892	FRESULT f_unlink (
; 4893		const TCHAR* path		/* Pointer to the file or directory path */
; 4894	)
; 4895	{
; 4896		FRESULT res;
; 4897		DIR dj, sdj;
; 4898		DWORD dclst = 0;
; 4899		FATFS *fs;
; 4900	#if FF_FS_EXFAT
; 4901		FFOBJID obj;
; 4902	#endif
; 4903		DEF_NAMBUF
; 4904	
; 4905	
; 4906		/* Get logical drive */
; 4907		res = mount_volume(&path, &fs, FA_WRITE);
; 4908		if (res == FR_OK) {
; 4909			dj.obj.fs = fs;
; 4910			INIT_NAMBUF(fs);
; 4911			res = follow_path(&dj, path);		/* Follow the file path */
; 4912			if (FF_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT)) {
; 4913				res = FR_INVALID_NAME;			/* Cannot remove dot entry */
; 4914			}
; 4915	#if FF_FS_LOCK != 0
; 4916			if (res == FR_OK) res = chk_lock(&dj, 2);	/* Check if it is an open object */
; 4917	#endif
; 4918			if (res == FR_OK) {					/* The object is accessible */
; 4919				if (dj.fn[NSFLAG] & NS_NONAME) {
; 4920					res = FR_INVALID_NAME;		/* Cannot remove the origin directory */
; 4921				} else {
; 4922					if (dj.obj.attr & AM_RDO) {
; 4923						res = FR_DENIED;		/* Cannot remove R/O object */
; 4924					}
; 4925				}
; 4926				if (res == FR_OK) {
; 4927	#if FF_FS_EXFAT
; 4928					obj.fs = fs;
; 4929					if (fs->fs_type == FS_EXFAT) {
; 4930						init_alloc_info(fs, &obj);
; 4931						dclst = obj.sclust;
; 4932					} else
; 4933	#endif
; 4934					{
; 4935						dclst = ld_clust(fs, dj.dir);
; 4936					}
; 4937					if (dj.obj.attr & AM_DIR) {			/* Is it a sub-directory? */
; 4938	#if FF_FS_RPATH != 0
; 4939						if (dclst == fs->cdir) {	 	/* Is it the current directory? */
; 4940							res = FR_DENIED;
; 4941						} else
; 4942	#endif
; 4943						{
; 4944							sdj.obj.fs = fs;			/* Open the sub-directory */
; 4945							sdj.obj.sclust = dclst;
; 4946	#if FF_FS_EXFAT
; 4947							if (fs->fs_type == FS_EXFAT) {
; 4948								sdj.obj.objsize = obj.objsize;
; 4949								sdj.obj.stat = obj.stat;
; 4950							}
; 4951	#endif
; 4952							res = dir_sdi(&sdj, 0);
; 4953							if (res == FR_OK) {
; 4954								res = DIR_READ_FILE(&sdj);			/* Test if the directory is empty */
; 4955								if (res == FR_OK) res = FR_DENIED;	/* Not empty? */
; 4956								if (res == FR_NO_FILE) res = FR_OK;	/* Empty? */
; 4957							}
; 4958						}
; 4959					}
; 4960				}
; 4961				if (res == FR_OK) {
; 4962					res = dir_remove(&dj);			/* Remove the directory entry */
; 4963					if (res == FR_OK && dclst != 0) {	/* Remove the cluster chain if exist */
; 4964	#if FF_FS_EXFAT
; 4965						res = remove_chain(&obj, dclst, 0);
; 4966	#else
; 4967						res = remove_chain(&dj.obj, dclst, 0);
; 4968	#endif
; 4969					}
; 4970					if (res == FR_OK) res = sync_fs(fs);
; 4971				}
; 4972			}
; 4973			FREE_NAMBUF();
; 4974		}
; 4975	
; 4976		LEAVE_FF(fs, res);
; 4977	}
; 4978	
; 4979	
; 4980	
; 4981	
; 4982	/*-----------------------------------------------------------------------*/
; 4983	/* Create a Directory                                                    */
; 4984	/*-----------------------------------------------------------------------*/
; 4985	
; 4986	FRESULT f_mkdir (
; 4987		const TCHAR* path		/* Pointer to the directory path */
; 4988	)
; 4989	{
; 4990		FRESULT res;
; 4991		DIR dj;
; 4992		FFOBJID sobj;
; 4993		FATFS *fs;
; 4994		DWORD dcl, pcl, tm;
; 4995		DEF_NAMBUF
; 4996	
; 4997	
; 4998		res = mount_volume(&path, &fs, FA_WRITE);	/* Get logical drive */
; 4999		if (res == FR_OK) {
; 5000			dj.obj.fs = fs;
; 5001			INIT_NAMBUF(fs);
; 5002			res = follow_path(&dj, path);			/* Follow the file path */
; 5003			if (res == FR_OK) res = FR_EXIST;		/* Name collision? */
; 5004			if (FF_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT)) {	/* Invalid name? */
; 5005				res = FR_INVALID_NAME;
; 5006			}
; 5007			if (res == FR_NO_FILE) {				/* It is clear to create a new directory */
; 5008				sobj.fs = fs;						/* New object id to create a new chain */
; 5009				dcl = create_chain(&sobj, 0);		/* Allocate a cluster for the new directory */
; 5010				res = FR_OK;
; 5011				if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster? */
; 5012				if (dcl == 1) res = FR_INT_ERR;		/* Any insanity? */
; 5013				if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;	/* Disk error? */
; 5014				tm = GET_FATTIME();
; 5015				if (res == FR_OK) {
; 5016					res = dir_clear(fs, dcl);		/* Clean up the new table */
; 5017					if (res == FR_OK) {
; 5018						if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {	/* Create dot entries (FAT only) */
; 5019							memset(fs->win + DIR_Name, ' ', 11);	/* Create "." entry */
; 5020							fs->win[DIR_Name] = '.';
; 5021							fs->win[DIR_Attr] = AM_DIR;
; 5022							st_dword(fs->win + DIR_ModTime, tm);
; 5023							st_clust(fs, fs->win, dcl);
; 5024							memcpy(fs->win + SZDIRE, fs->win, SZDIRE);	/* Create ".." entry */
; 5025							fs->win[SZDIRE + 1] = '.'; pcl = dj.obj.sclust;
; 5026							st_clust(fs, fs->win + SZDIRE, pcl);
; 5027							fs->wflag = 1;
; 5028						}
; 5029						res = dir_register(&dj);	/* Register the object to the parent directoy */
; 5030					}
; 5031				}
; 5032				if (res == FR_OK) {
; 5033	#if FF_FS_EXFAT
; 5034					if (fs->fs_type == FS_EXFAT) {	/* Initialize directory entry block */
; 5035						st_dword(fs->dirbuf + XDIR_ModTime, tm);	/* Created time */
; 5036						st_dword(fs->dirbuf + XDIR_FstClus, dcl);	/* Table start cluster */
; 5037						st_dword(fs->dirbuf + XDIR_FileSize, (DWORD)fs->csize * SS(fs));	/* Directory size needs to be valid */
; 5038						st_dword(fs->dirbuf + XDIR_ValidFileSize, (DWORD)fs->csize * SS(fs));
; 5039						fs->dirbuf[XDIR_GenFlags] = 3;				/* Initialize the object flag */
; 5040						fs->dirbuf[XDIR_Attr] = AM_DIR;				/* Attribute */
; 5041						res = store_xdir(&dj);
; 5042					} else
; 5043	#endif
; 5044					{
; 5045						st_dword(dj.dir + DIR_ModTime, tm);	/* Created time */
; 5046						st_clust(fs, dj.dir, dcl);			/* Table start cluster */
; 5047						dj.dir[DIR_Attr] = AM_DIR;			/* Attribute */
; 5048						fs->wflag = 1;
; 5049					}
; 5050					if (res == FR_OK) {
; 5051						res = sync_fs(fs);
; 5052					}
; 5053				} else {
; 5054					remove_chain(&sobj, dcl, 0);		/* Could not register, remove the allocated cluster */
; 5055				}
; 5056			}
; 5057			FREE_NAMBUF();
; 5058		}
; 5059	
; 5060		LEAVE_FF(fs, res);
; 5061	}
; 5062	
; 5063	
; 5064	
; 5065	
; 5066	/*-----------------------------------------------------------------------*/
; 5067	/* Rename a File/Directory                                               */
; 5068	/*-----------------------------------------------------------------------*/
; 5069	
; 5070	FRESULT f_rename (
; 5071		const TCHAR* path_old,	/* Pointer to the object name to be renamed */
; 5072		const TCHAR* path_new	/* Pointer to the new name */
; 5073	)
; 5074	{
; 5075		FRESULT res;
; 5076		DIR djo, djn;
; 5077		FATFS *fs;
; 5078		BYTE buf[FF_FS_EXFAT ? SZDIRE * 2 : SZDIRE], *dir;
; 5079		LBA_t sect;
; 5080		DEF_NAMBUF
; 5081	
; 5082	
; 5083		get_ldnumber(&path_new);						/* Snip the drive number of new name off */
; 5084		res = mount_volume(&path_old, &fs, FA_WRITE);	/* Get logical drive of the old object */
; 5085		if (res == FR_OK) {
; 5086			djo.obj.fs = fs;
; 5087			INIT_NAMBUF(fs);
; 5088			res = follow_path(&djo, path_old);			/* Check old object */
; 5089			if (res == FR_OK && (djo.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check validity of name */
; 5090	#if FF_FS_LOCK != 0
; 5091			if (res == FR_OK) {
; 5092				res = chk_lock(&djo, 2);
; 5093			}
; 5094	#endif
; 5095			if (res == FR_OK) {					/* Object to be renamed is found */
; 5096	#if FF_FS_EXFAT
; 5097				if (fs->fs_type == FS_EXFAT) {	/* At exFAT volume */
; 5098					BYTE nf, nn;
; 5099					WORD nh;
; 5100	
; 5101					memcpy(buf, fs->dirbuf, SZDIRE * 2);	/* Save 85+C0 entry of old object */
; 5102					memcpy(&djn, &djo, sizeof djo);
; 5103					res = follow_path(&djn, path_new);		/* Make sure if new object name is not in use */
; 5104					if (res == FR_OK) {						/* Is new name already in use by any other object? */
; 5105						res = (djn.obj.sclust == djo.obj.sclust && djn.dptr == djo.dptr) ? FR_NO_FILE : FR_EXIST;
; 5106					}
; 5107					if (res == FR_NO_FILE) { 				/* It is a valid path and no name collision */
; 5108						res = dir_register(&djn);			/* Register the new entry */
; 5109						if (res == FR_OK) {
; 5110							nf = fs->dirbuf[XDIR_NumSec]; nn = fs->dirbuf[XDIR_NumName];
; 5111							nh = ld_word(fs->dirbuf + XDIR_NameHash);
; 5112							memcpy(fs->dirbuf, buf, SZDIRE * 2);	/* Restore 85+C0 entry */
; 5113							fs->dirbuf[XDIR_NumSec] = nf; fs->dirbuf[XDIR_NumName] = nn;
; 5114							st_word(fs->dirbuf + XDIR_NameHash, nh);
; 5115							if (!(fs->dirbuf[XDIR_Attr] & AM_DIR)) fs->dirbuf[XDIR_Attr] |= AM_ARC;	/* Set archive attribute if it is a file */
; 5116	/* Start of critical section where an interruption can cause a cross-link */
; 5117							res = store_xdir(&djn);
; 5118						}
; 5119					}
; 5120				} else
; 5121	#endif
; 5122				{	/* At FAT/FAT32 volume */
; 5123					memcpy(buf, djo.dir, SZDIRE);			/* Save directory entry of the object */
; 5124					memcpy(&djn, &djo, sizeof (DIR));		/* Duplicate the directory object */
; 5125					res = follow_path(&djn, path_new);		/* Make sure if new object name is not in use */
; 5126					if (res == FR_OK) {						/* Is new name already in use by any other object? */
; 5127						res = (djn.obj.sclust == djo.obj.sclust && djn.dptr == djo.dptr) ? FR_NO_FILE : FR_EXIST;
; 5128					}
; 5129					if (res == FR_NO_FILE) { 				/* It is a valid path and no name collision */
; 5130						res = dir_register(&djn);			/* Register the new entry */
; 5131						if (res == FR_OK) {
; 5132							dir = djn.dir;					/* Copy directory entry of the object except name */
; 5133							memcpy(dir + 13, buf + 13, SZDIRE - 13);
; 5134							dir[DIR_Attr] = buf[DIR_Attr];
; 5135							if (!(dir[DIR_Attr] & AM_DIR)) dir[DIR_Attr] |= AM_ARC;	/* Set archive attribute if it is a file */
; 5136							fs->wflag = 1;
; 5137							if ((dir[DIR_Attr] & AM_DIR) && djo.obj.sclust != djn.obj.sclust) {	/* Update .. entry in the sub-directory if needed */
; 5138								sect = clst2sect(fs, ld_clust(fs, dir));
; 5139								if (sect == 0) {
; 5140									res = FR_INT_ERR;
; 5141								} else {
; 5142	/* Start of critical section where an interruption can cause a cross-link */
; 5143									res = move_window(fs, sect);
; 5144									dir = fs->win + SZDIRE * 1;	/* Ptr to .. entry */
; 5145									if (res == FR_OK && dir[1] == '.') {
; 5146										st_clust(fs, dir, djn.obj.sclust);
; 5147										fs->wflag = 1;
; 5148									}
; 5149								}
; 5150							}
; 5151						}
; 5152					}
; 5153				}
; 5154				if (res == FR_OK) {
; 5155					res = dir_remove(&djo);		/* Remove old entry */
; 5156					if (res == FR_OK) {
; 5157						res = sync_fs(fs);
; 5158					}
; 5159				}
; 5160	/* End of the critical section */
; 5161			}
; 5162			FREE_NAMBUF();
; 5163		}
; 5164	
; 5165		LEAVE_FF(fs, res);
; 5166	}
; 5167	
; 5168	#endif /* !FF_FS_READONLY */
; 5169	#endif /* FF_FS_MINIMIZE == 0 */
; 5170	#endif /* FF_FS_MINIMIZE <= 1 */
; 5171	#endif /* FF_FS_MINIMIZE <= 2 */
; 5172	
; 5173	
; 5174	
; 5175	#if FF_USE_CHMOD && !FF_FS_READONLY
; 5176	/*-----------------------------------------------------------------------*/
; 5177	/* Change Attribute                                                      */
; 5178	/*-----------------------------------------------------------------------*/
; 5179	
; 5180	FRESULT f_chmod (
; 5181		const TCHAR* path,	/* Pointer to the file path */
; 5182		BYTE attr,			/* Attribute bits */
; 5183		BYTE mask			/* Attribute mask to change */
; 5184	)
; 5185	{
; 5186		FRESULT res;
; 5187		DIR dj;
; 5188		FATFS *fs;
; 5189		DEF_NAMBUF
; 5190	
; 5191	
; 5192		res = mount_volume(&path, &fs, FA_WRITE);	/* Get logical drive */
; 5193		if (res == FR_OK) {
; 5194			dj.obj.fs = fs;
; 5195			INIT_NAMBUF(fs);
; 5196			res = follow_path(&dj, path);	/* Follow the file path */
; 5197			if (res == FR_OK && (dj.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check object validity */
; 5198			if (res == FR_OK) {
; 5199				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
; 5200	#if FF_FS_EXFAT
; 5201				if (fs->fs_type == FS_EXFAT) {
; 5202					fs->dirbuf[XDIR_Attr] = (attr & mask) | (fs->dirbuf[XDIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
; 5203					res = store_xdir(&dj);
; 5204				} else
; 5205	#endif
; 5206				{
; 5207					dj.dir[DIR_Attr] = (attr & mask) | (dj.dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
; 5208					fs->wflag = 1;
; 5209				}
; 5210				if (res == FR_OK) {
; 5211					res = sync_fs(fs);
; 5212				}
; 5213			}
; 5214			FREE_NAMBUF();
; 5215		}
; 5216	
; 5217		LEAVE_FF(fs, res);
; 5218	}
; 5219	
; 5220	
; 5221	
; 5222	
; 5223	/*-----------------------------------------------------------------------*/
; 5224	/* Change Timestamp                                                      */
; 5225	/*-----------------------------------------------------------------------*/
; 5226	
; 5227	FRESULT f_utime (
; 5228		const TCHAR* path,	/* Pointer to the file/directory name */
; 5229		const FILINFO* fno	/* Pointer to the timestamp to be set */
; 5230	)
; 5231	{
; 5232		FRESULT res;
; 5233		DIR dj;
; 5234		FATFS *fs;
; 5235		DEF_NAMBUF
; 5236	
; 5237	
; 5238		res = mount_volume(&path, &fs, FA_WRITE);	/* Get logical drive */
; 5239		if (res == FR_OK) {
; 5240			dj.obj.fs = fs;
; 5241			INIT_NAMBUF(fs);
; 5242			res = follow_path(&dj, path);	/* Follow the file path */
; 5243			if (res == FR_OK && (dj.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check object validity */
; 5244			if (res == FR_OK) {
; 5245	#if FF_FS_EXFAT
; 5246				if (fs->fs_type == FS_EXFAT) {
; 5247					st_dword(fs->dirbuf + XDIR_ModTime, (DWORD)fno->fdate << 16 | fno->ftime);
; 5248					res = store_xdir(&dj);
; 5249				} else
; 5250	#endif
; 5251				{
; 5252					st_dword(dj.dir + DIR_ModTime, (DWORD)fno->fdate << 16 | fno->ftime);
; 5253					fs->wflag = 1;
; 5254				}
; 5255				if (res == FR_OK) {
; 5256					res = sync_fs(fs);
; 5257				}
; 5258			}
; 5259			FREE_NAMBUF();
; 5260		}
; 5261	
; 5262		LEAVE_FF(fs, res);
; 5263	}
; 5264	
; 5265	#endif	/* FF_USE_CHMOD && !FF_FS_READONLY */
; 5266	
; 5267	
; 5268	
; 5269	#if FF_USE_LABEL
; 5270	/*-----------------------------------------------------------------------*/
; 5271	/* Get Volume Label                                                      */
; 5272	/*-----------------------------------------------------------------------*/
; 5273	
; 5274	FRESULT f_getlabel (
; 5275		const TCHAR* path,	/* Logical drive number */
; 5276		TCHAR* label,		/* Buffer to store the volume label */
; 5277		DWORD* vsn			/* Variable to store the volume serial number */
; 5278	)
; 5279	{
_f_getlabel:
.DEFINE "_f_getlabel"

.VALUE _f_getlabel

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "f_getlabel",5279,"_f_getlabel"

.LINE 5279

.DEFINE "path"

.CLASS 65

.VALUE 6

.TYPE 194

.ENDEF

.DEFINE "label"

.CLASS 65

.VALUE 9

.TYPE 34

.ENDEF

.DEFINE "vsn"

.CLASS 65

.VALUE 12

.TYPE 47

.ENDEF

.DEFINE "di"

.CLASS 65

.VALUE -3

.TYPE 14

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -6

.TYPE 4

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -9

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "si"

.CLASS 65

.VALUE -12

.TYPE 14

.ENDEF

.DEFINE "wc"

.CLASS 65

.VALUE -14

.TYPE 13

.ENDEF

.DEFINE "dj"

.CLASS 65

.VALUE -60

.TAG "NONAME3"

.TYPE 8

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFC1
	LD	SP,HL
; 5280		FRESULT res;
; 5281		DIR dj;
; 5282		FATFS *fs;
; 5283		UINT si, di;
; 5284		WCHAR wc;
; 5285	
; 5286		/* Get logical drive */
; 5287		res = mount_volume(&path, &fs, 0);
.LINE 5287

	LD	BC,0
	PUSH	BC
	PEA	IX+%FFFFFFF7
	PEA	IX+%6
	CALL	_mount_volume
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFA),HL
; 5288	
; 5289		/* Get volume label */
; 5290		if (res == FR_OK && label) {
.LINE 5290

	CALL	__icmpzero
	JR	NZ,L_681
	LD	HL,(IX+%9)
	CALL	__icmpzero
	JR	Z,L_681
; 5291			dj.obj.fs = fs; dj.obj.sclust = 0;	/* Open root directory */
.LINE 5291

	LEA	BC,IX+%FFFFFFC4
	LD	(IX+%FFFFFFC1),BC
	LD	BC,(IX+%FFFFFFF7)
	LD	(IX+%FFFFFFC4),BC
	LD	BC,0
	LD	IY,(IX+%FFFFFFC1)
	LD	(IY+%7),BC
	LD	(IY+%A),%0
; 5292			res = dir_sdi(&dj, 0);
.LINE 5292

	PUSH	BC
	PUSH	BC
	PEA	IX+%FFFFFFC4
	CALL	_dir_sdi
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFA),HL
; 5293			if (res == FR_OK) {
.LINE 5293

	CALL	__icmpzero
	JR	NZ,L_672
; 5294			 	res = DIR_READ_LABEL(&dj);		/* Find a volume label entry */
.LINE 5294

	LD	BC,1
	PUSH	BC
	PEA	IX+%FFFFFFC4
	CALL	_dir_read
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFA),HL
; 5295			 	if (res == FR_OK) {
.LINE 5295

	CALL	__icmpzero
	JR	NZ,L_672
; 5296	#if FF_FS_EXFAT
; 5297					if (fs->fs_type == FS_EXFAT) {
; 5298						WCHAR hs;
; 5299						UINT nw;
; 5300	
; 5301						for (si = di = hs = 0; si < dj.dir[XDIR_NumLabel]; si++) {	/* Extract volume label from 83 entry */
; 5302							wc = ld_word(dj.dir + XDIR_Label + si * 2);
; 5303							if (hs == 0 && IsSurrogate(wc)) {	/* Is the code a surrogate? */
; 5304								hs = wc; continue;
; 5305							}
; 5306							nw = put_utf((DWORD)hs << 16 | wc, &label[di], 4);	/* Store it in API encoding */
; 5307							if (nw == 0) { di = 0; break; }		/* Encode error? */
; 5308							di += nw;
; 5309							hs = 0;
; 5310						}
; 5311						if (hs != 0) di = 0;	/* Broken surrogate pair? */
; 5312						label[di] = 0;
; 5313					} else
; 5314	#endif
; 5315					{
; 5316						si = di = 0;		/* Extract volume label from AM_VOL entry */
.LINE 5316

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	LD	(IX+%FFFFFFF4),BC
; 5317						while (si < 11) {
.LINE 5317

	JR	L_663
L_664:
; 5318							wc = dj.dir[si++];
.LINE 5318

	LD	BC,(IX+%FFFFFFF4)
	LD	HL,(IX+%FFFFFFDF)
	ADD	HL,BC
	LD	C,(HL)
	LD	B,%0
	LD	HL,BC
	LD	(IX+%FFFFFFF2),L
	LD	(IX+%FFFFFFF3),H
	LD	BC,(IX+%FFFFFFF4)
	INC	BC
	LD	(IX+%FFFFFFF4),BC
; 5319	#if FF_USE_LFN && FF_LFN_UNICODE >= 1 	/* Unicode output */
; 5320							if (dbc_1st((BYTE)wc) && si < 11) wc = wc << 8 | dj.dir[si++];	/* Is it a DBC? */
; 5321							wc = ff_oem2uni(wc, CODEPAGE);		/* Convert it into Unicode */
; 5322							if (wc == 0) { di = 0; break; }		/* Invalid char in current code page? */
; 5323							di += put_utf(wc, &label[di], 4);	/* Store it in Unicode */
; 5324	#else									/* ANSI/OEM output */
; 5325							label[di++] = (TCHAR)wc;
.LINE 5325

	LD	A,(IX+%FFFFFFF2)
	LD	BC,(IX+%FFFFFFFD)
	LD	HL,(IX+%9)
	ADD	HL,BC
	LD	(HL),A
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
; 5326	#endif
; 5327						}
L_663:
.LINE 5327

	LD	BC,11
	LD	HL,(IX+%FFFFFFF4)
	OR	A,A
	SBC	HL,BC
	JR	C,L_664
; 5328						do {				/* Truncate trailing spaces */
L_666:
.LINE 5328

; 5329							label[di] = 0;
.LINE 5329

	LD	BC,(IX+%FFFFFFFD)
	LD	HL,(IX+%9)
	ADD	HL,BC
	LD	(HL),%0
; 5330							if (di == 0) break;
.LINE 5330

	LD	HL,(IX+%FFFFFFFD)
	CALL	__icmpzero
	JR	Z,L_672
; 5331						} while (label[--di] == ' ');
.LINE 5331

	LD	IY,(IX+%FFFFFFFD)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%FFFFFFFD),IY
	LD	BC,IY
	LD	HL,(IX+%9)
	ADD	HL,BC
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,32
	OR	A,A
	SBC	HL,BC
	JR	Z,L_666
; 5332					}
; 5333				}
; 5334			}
L_672:
.LINE 5334

; 5335			if (res == FR_NO_FILE) {	/* No label entry and return nul string */
.LINE 5335

	LD	BC,4
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_681
; 5336				label[0] = 0;
.LINE 5336

	LD	HL,(IX+%9)
	LD	(HL),%0
; 5337				res = FR_OK;
.LINE 5337

	LD	BC,0
	LD	(IX+%FFFFFFFA),BC
; 5338			}
; 5339		}
L_681:
.LINE 5339

; 5340	
; 5341		/* Get volume serial number */
; 5342		if (res == FR_OK && vsn) {
.LINE 5342

	LD	HL,(IX+%FFFFFFFA)
	CALL	__icmpzero
	JR	NZ,L_682
	LD	HL,(IX+%C)
	CALL	__icmpzero
	JR	Z,L_682
; 5343			res = move_window(fs, fs->volbase);
.LINE 5343

	LD	IY,(IX+%FFFFFFF7)
	LD	BC,(IY+%1A)
	LD	A,(IY+%1D)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	LD	BC,(IX+%FFFFFFF7)
	PUSH	BC
	CALL	_move_window
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFA),HL
; 5344			if (res == FR_OK) {
.LINE 5344

	CALL	__icmpzero
	JR	NZ,L_682
; 5345				switch (fs->fs_type) {
.LINE 5345

	LD	IY,(IX+%FFFFFFF7)
	LD	A,(IY+%0)
	UEXT	HL
	LD	L,A
	CALL	__case8D
	JP	(HL)
L__351:
	DW	2
	DB	3
	DW24	L_676	

	DB	4
	DW24	L_675	

	DW24	L_677	

; 5346				case FS_EXFAT:
L_675:
.LINE 5346

; 5347					di = BPB_VolIDEx;
.LINE 5347

	LD	BC,100
	LD	(IX+%FFFFFFFD),BC
; 5348					break;
.LINE 5348

	JR	L_678
; 5349	
; 5350				case FS_FAT32:
L_676:
.LINE 5350

; 5351					di = BS_VolID32;
.LINE 5351

	LD	BC,67
	LD	(IX+%FFFFFFFD),BC
; 5352					break;
.LINE 5352

	JR	L_678
; 5353	
; 5354				default:
L_677:
.LINE 5354

; 5355					di = BS_VolID;
.LINE 5355

	LD	BC,39
	LD	(IX+%FFFFFFFD),BC
; 5356				}
L_678:
.LINE 5356

; 5357				*vsn = ld_dword(fs->win + di);
.LINE 5357

	LD	BC,(IX+%FFFFFFFD)
	LD	IY,(IX+%FFFFFFF7)
	LEA	HL,IY+%2E
	ADD	HL,BC
	PUSH	HL
	CALL	_ld_dword
	POP	BC
	LD	IY,(IX+%C)
	LD	(IY),HL
	LD	(IY+%3),E
; 5358			}
; 5359		}
L_682:
.LINE 5359

; 5360	
; 5361		LEAVE_FF(fs, res);
.LINE 5361

	LD	HL,(IX+%FFFFFFFA)
; 5362	}
.LINE 5362

	LD	SP,IX
	POP	IX
	RET	


;**************************** _f_getlabel ***************************
;Name                         Addr/Register   Size   Type
;dj                                   IX-60     46   variable
;wc                                   IX-14      2   variable
;si                                   IX-12      3   variable
;fs                                    IX-9      3   variable
;res                                   IX-6      3   variable
;di                                    IX-3      3   variable
;vsn                                  IX+12      3   parameter
;label                                 IX+9      3   parameter
;path                                  IX+6      3   parameter


; Stack Frame Size: 78 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "f_getlabel",5362,"_f_getlabel"
; 5363	
; 5364	
; 5365	
; 5366	#if !FF_FS_READONLY
; 5367	/*-----------------------------------------------------------------------*/
; 5368	/* Set Volume Label                                                      */
; 5369	/*-----------------------------------------------------------------------*/
; 5370	
; 5371	FRESULT f_setlabel (
; 5372		const TCHAR* label	/* Volume label to set with heading logical drive number */
; 5373	)
; 5374	{
; 5375		FRESULT res;
; 5376		DIR dj;
; 5377		FATFS *fs;
; 5378		BYTE dirvn[22];
; 5379		UINT di;
; 5380		WCHAR wc;
; 5381		static const char badchr[18] = "+.,;=[]" "/*:<>|\\\"\?\x7F";	/* [0..16] for FAT, [7..16] for exFAT */
; 5382	#if FF_USE_LFN
; 5383		DWORD dc;
; 5384	#endif
; 5385	
; 5386		/* Get logical drive */
; 5387		res = mount_volume(&label, &fs, FA_WRITE);
; 5388		if (res != FR_OK) LEAVE_FF(fs, res);
; 5389	
; 5390	#if FF_FS_EXFAT
; 5391		if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
; 5392			memset(dirvn, 0, 22);
; 5393			di = 0;
; 5394			while ((UINT)*label >= ' ') {	/* Create volume label */
; 5395				dc = tchar2uni(&label);	/* Get a Unicode character */
; 5396				if (dc >= 0x10000) {
; 5397					if (dc == 0xFFFFFFFF || di >= 10) {	/* Wrong surrogate or buffer overflow */
; 5398						dc = 0;
; 5399					} else {
; 5400						st_word(dirvn + di * 2, (WCHAR)(dc >> 16)); di++;
; 5401					}
; 5402				}
; 5403				if (dc == 0 || strchr(&badchr[7], (int)dc) || di >= 11) {	/* Check validity of the volume label */
; 5404					LEAVE_FF(fs, FR_INVALID_NAME);
; 5405				}
; 5406				st_word(dirvn + di * 2, (WCHAR)dc); di++;
; 5407			}
; 5408		} else
; 5409	#endif
; 5410		{	/* On the FAT/FAT32 volume */
; 5411			memset(dirvn, ' ', 11);
; 5412			di = 0;
; 5413			while ((UINT)*label >= ' ') {	/* Create volume label */
; 5414	#if FF_USE_LFN
; 5415				dc = tchar2uni(&label);
; 5416				wc = (dc < 0x10000) ? ff_uni2oem(ff_wtoupper(dc), CODEPAGE) : 0;
; 5417	#else									/* ANSI/OEM input */
; 5418				wc = (BYTE)*label++;
; 5419				if (dbc_1st((BYTE)wc)) wc = dbc_2nd((BYTE)*label) ? wc << 8 | (BYTE)*label++ : 0;
; 5420				if (IsLower(wc)) wc -= 0x20;		/* To upper ASCII characters */
; 5421	#if FF_CODE_PAGE == 0
; 5422				if (ExCvt && wc >= 0x80) wc = ExCvt[wc - 0x80];	/* To upper extended characters (SBCS cfg) */
; 5423	#elif FF_CODE_PAGE < 900
; 5424				if (wc >= 0x80) wc = ExCvt[wc - 0x80];	/* To upper extended characters (SBCS cfg) */
; 5425	#endif
; 5426	#endif
; 5427				if (wc == 0 || strchr(&badchr[0], (int)wc) || di >= (UINT)((wc >= 0x100) ? 10 : 11)) {	/* Reject invalid characters for volume label */
; 5428					LEAVE_FF(fs, FR_INVALID_NAME);
; 5429				}
; 5430				if (wc >= 0x100) dirvn[di++] = (BYTE)(wc >> 8);
; 5431				dirvn[di++] = (BYTE)wc;
; 5432			}
; 5433			if (dirvn[0] == DDEM) LEAVE_FF(fs, FR_INVALID_NAME);	/* Reject illegal name (heading DDEM) */
; 5434			while (di && dirvn[di - 1] == ' ') di--;				/* Snip trailing spaces */
; 5435		}
; 5436	
; 5437		/* Set volume label */
; 5438		dj.obj.fs = fs; dj.obj.sclust = 0;	/* Open root directory */
; 5439		res = dir_sdi(&dj, 0);
; 5440		if (res == FR_OK) {
; 5441			res = DIR_READ_LABEL(&dj);	/* Get volume label entry */
; 5442			if (res == FR_OK) {
; 5443				if (FF_FS_EXFAT && fs->fs_type == FS_EXFAT) {
; 5444					dj.dir[XDIR_NumLabel] = (BYTE)di;	/* Change the volume label */
; 5445					memcpy(dj.dir + XDIR_Label, dirvn, 22);
; 5446				} else {
; 5447					if (di != 0) {
; 5448						memcpy(dj.dir, dirvn, 11);	/* Change the volume label */
; 5449					} else {
; 5450						dj.dir[DIR_Name] = DDEM;	/* Remove the volume label */
; 5451					}
; 5452				}
; 5453				fs->wflag = 1;
; 5454				res = sync_fs(fs);
; 5455			} else {			/* No volume label entry or an error */
; 5456				if (res == FR_NO_FILE) {
; 5457					res = FR_OK;
; 5458					if (di != 0) {	/* Create a volume label entry */
; 5459						res = dir_alloc(&dj, 1);	/* Allocate an entry */
; 5460						if (res == FR_OK) {
; 5461							memset(dj.dir, 0, SZDIRE);	/* Clean the entry */
; 5462							if (FF_FS_EXFAT && fs->fs_type == FS_EXFAT) {
; 5463								dj.dir[XDIR_Type] = ET_VLABEL;	/* Create volume label entry */
; 5464								dj.dir[XDIR_NumLabel] = (BYTE)di;
; 5465								memcpy(dj.dir + XDIR_Label, dirvn, 22);
; 5466							} else {
; 5467								dj.dir[DIR_Attr] = AM_VOL;		/* Create volume label entry */
; 5468								memcpy(dj.dir, dirvn, 11);
; 5469							}
; 5470							fs->wflag = 1;
; 5471							res = sync_fs(fs);
; 5472						}
; 5473					}
; 5474				}
; 5475			}
; 5476		}
; 5477	
; 5478		LEAVE_FF(fs, res);
; 5479	}
; 5480	
; 5481	#endif /* !FF_FS_READONLY */
; 5482	#endif /* FF_USE_LABEL */
; 5483	
; 5484	
; 5485	
; 5486	#if FF_USE_EXPAND && !FF_FS_READONLY
; 5487	/*-----------------------------------------------------------------------*/
; 5488	/* Allocate a Contiguous Blocks to the File                              */
; 5489	/*-----------------------------------------------------------------------*/
; 5490	
; 5491	FRESULT f_expand (
; 5492		FIL* fp,		/* Pointer to the file object */
; 5493		FSIZE_t fsz,	/* File size to be expanded to */
; 5494		BYTE opt		/* Operation mode 0:Find and prepare or 1:Find and allocate */
; 5495	)
; 5496	{
; 5497		FRESULT res;
; 5498		FATFS *fs;
; 5499		DWORD n, clst, stcl, scl, ncl, tcl, lclst;
; 5500	
; 5501	
; 5502		res = validate(&fp->obj, &fs);		/* Check validity of the file object */
; 5503		if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);
; 5504		if (fsz == 0 || fp->obj.objsize != 0 || !(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);
; 5505	#if FF_FS_EXFAT
; 5506		if (fs->fs_type != FS_EXFAT && fsz >= 0x100000000) LEAVE_FF(fs, FR_DENIED);	/* Check if in size limit */
; 5507	#endif
; 5508		n = (DWORD)fs->csize * SS(fs);	/* Cluster size */
; 5509		tcl = (DWORD)(fsz / n) + ((fsz & (n - 1)) ? 1 : 0);	/* Number of clusters required */
; 5510		stcl = fs->last_clst; lclst = 0;
; 5511		if (stcl < 2 || stcl >= fs->n_fatent) stcl = 2;
; 5512	
; 5513	#if FF_FS_EXFAT
; 5514		if (fs->fs_type == FS_EXFAT) {
; 5515			scl = find_bitmap(fs, stcl, tcl);			/* Find a contiguous cluster block */
; 5516			if (scl == 0) res = FR_DENIED;				/* No contiguous cluster block was found */
; 5517			if (scl == 0xFFFFFFFF) res = FR_DISK_ERR;
; 5518			if (res == FR_OK) {	/* A contiguous free area is found */
; 5519				if (opt) {		/* Allocate it now */
; 5520					res = change_bitmap(fs, scl, tcl, 1);	/* Mark the cluster block 'in use' */
; 5521					lclst = scl + tcl - 1;
; 5522				} else {		/* Set it as suggested point for next allocation */
; 5523					lclst = scl - 1;
; 5524				}
; 5525			}
; 5526		} else
; 5527	#endif
; 5528		{
; 5529			scl = clst = stcl; ncl = 0;
; 5530			for (;;) {	/* Find a contiguous cluster block */
; 5531				n = get_fat(&fp->obj, clst);
; 5532				if (++clst >= fs->n_fatent) clst = 2;
; 5533				if (n == 1) { res = FR_INT_ERR; break; }
; 5534				if (n == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
; 5535				if (n == 0) {	/* Is it a free cluster? */
; 5536					if (++ncl == tcl) break;	/* Break if a contiguous cluster block is found */
; 5537				} else {
; 5538					scl = clst; ncl = 0;		/* Not a free cluster */
; 5539				}
; 5540				if (clst == stcl) { res = FR_DENIED; break; }	/* No contiguous cluster? */
; 5541			}
; 5542			if (res == FR_OK) {	/* A contiguous free area is found */
; 5543				if (opt) {		/* Allocate it now */
; 5544					for (clst = scl, n = tcl; n; clst++, n--) {	/* Create a cluster chain on the FAT */
; 5545						res = put_fat(fs, clst, (n == 1) ? 0xFFFFFFFF : clst + 1);
; 5546						if (res != FR_OK) break;
; 5547						lclst = clst;
; 5548					}
; 5549				} else {		/* Set it as suggested point for next allocation */
; 5550					lclst = scl - 1;
; 5551				}
; 5552			}
; 5553		}
; 5554	
; 5555		if (res == FR_OK) {
; 5556			fs->last_clst = lclst;		/* Set suggested start cluster to start next */
; 5557			if (opt) {	/* Is it allocated now? */
; 5558				fp->obj.sclust = scl;		/* Update object allocation information */
; 5559				fp->obj.objsize = fsz;
; 5560				if (FF_FS_EXFAT) fp->obj.stat = 2;	/* Set status 'contiguous chain' */
; 5561				fp->flag |= FA_MODIFIED;
; 5562				if (fs->free_clst <= fs->n_fatent - 2) {	/* Update FSINFO */
; 5563					fs->free_clst -= tcl;
; 5564					fs->fsi_flag |= 1;
; 5565				}
; 5566			}
; 5567		}
; 5568	
; 5569		LEAVE_FF(fs, res);
; 5570	}
; 5571	
; 5572	#endif /* FF_USE_EXPAND && !FF_FS_READONLY */
; 5573	
; 5574	
; 5575	
; 5576	#if FF_USE_FORWARD
; 5577	/*-----------------------------------------------------------------------*/
; 5578	/* Forward Data to the Stream Directly                                   */
; 5579	/*-----------------------------------------------------------------------*/
; 5580	
; 5581	FRESULT f_forward (
; 5582		FIL* fp, 						/* Pointer to the file object */
; 5583		UINT (*func)(const BYTE*,UINT),	/* Pointer to the streaming function */
; 5584		UINT btf,						/* Number of bytes to forward */
; 5585		UINT* bf						/* Pointer to number of bytes forwarded */
; 5586	)
; 5587	{
; 5588		FRESULT res;
; 5589		FATFS *fs;
; 5590		DWORD clst;
; 5591		LBA_t sect;
; 5592		FSIZE_t remain;
; 5593		UINT rcnt, csect;
; 5594		BYTE *dbuf;
; 5595	
; 5596	
; 5597		*bf = 0;	/* Clear transfer byte counter */
; 5598		res = validate(&fp->obj, &fs);		/* Check validity of the file object */
; 5599		if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);
; 5600		if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
; 5601	
; 5602		remain = fp->obj.objsize - fp->fptr;
; 5603		if (btf > remain) btf = (UINT)remain;			/* Truncate btf by remaining bytes */
; 5604	
; 5605		for ( ; btf > 0 && (*func)(0, 0); fp->fptr += rcnt, *bf += rcnt, btf -= rcnt) {	/* Repeat until all data transferred or stream goes busy */
; 5606			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
; 5607			if (fp->fptr % SS(fs) == 0) {				/* On the sector boundary? */
; 5608				if (csect == 0) {						/* On the cluster boundary? */
; 5609					clst = (fp->fptr == 0) ?			/* On the top of the file? */
; 5610						fp->obj.sclust : get_fat(&fp->obj, fp->clust);
; 5611					if (clst <= 1) ABORT(fs, FR_INT_ERR);
; 5612					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
; 5613					fp->clust = clst;					/* Update current cluster */
; 5614				}
; 5615			}
; 5616			sect = clst2sect(fs, fp->clust);			/* Get current data sector */
; 5617			if (sect == 0) ABORT(fs, FR_INT_ERR);
; 5618			sect += csect;
; 5619	#if FF_FS_TINY
; 5620			if (move_window(fs, sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window to the file data */
; 5621			dbuf = fs->win;
; 5622	#else
; 5623			if (fp->sect != sect) {		/* Fill sector cache with file data */
; 5624	#if !FF_FS_READONLY
; 5625				if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
; 5626					if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
; 5627					fp->flag &= (BYTE)~FA_DIRTY;
; 5628				}
; 5629	#endif
; 5630				if (disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
; 5631			}
; 5632			dbuf = fp->buf;
; 5633	#endif
; 5634			fp->sect = sect;
; 5635			rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes remains in the sector */
; 5636			if (rcnt > btf) rcnt = btf;					/* Clip it by btr if needed */
; 5637			rcnt = (*func)(dbuf + ((UINT)fp->fptr % SS(fs)), rcnt);	/* Forward the file data */
; 5638			if (rcnt == 0) ABORT(fs, FR_INT_ERR);
; 5639		}
; 5640	
; 5641		LEAVE_FF(fs, FR_OK);
; 5642	}
; 5643	#endif /* FF_USE_FORWARD */
; 5644	
; 5645	
; 5646	
; 5647	#if !FF_FS_READONLY && FF_USE_MKFS
; 5648	/*-----------------------------------------------------------------------*/
; 5649	/* Create FAT/exFAT volume (with sub-functions)                          */
; 5650	/*-----------------------------------------------------------------------*/
; 5651	
; 5652	#define N_SEC_TRACK 63			/* Sectors per track for determination of drive CHS */
; 5653	#define	GPT_ALIGN	0x100000	/* Alignment of partitions in GPT [byte] (>=128KB) */
; 5654	#define GPT_ITEMS	128			/* Number of GPT table size (>=128, sector aligned) */
; 5655	
; 5656	
; 5657	/* Create partitions on the physical drive in format of MBR or GPT */
; 5658	
; 5659	static FRESULT create_partition (
; 5660		BYTE drv,			/* Physical drive number */
; 5661		const LBA_t plst[],	/* Partition list */
; 5662		BYTE sys,			/* System ID (for only MBR, temp setting) */
; 5663		BYTE* buf			/* Working buffer for a sector */
; 5664	)
; 5665	{
; 5666		UINT i, cy;
; 5667		LBA_t sz_drv;
; 5668		DWORD sz_drv32, nxt_alloc32, sz_part32;
; 5669		BYTE *pte;
; 5670		BYTE hd, n_hd, sc, n_sc;
; 5671	
; 5672		/* Get physical drive size */
; 5673		if (disk_ioctl(drv, GET_SECTOR_COUNT, &sz_drv) != RES_OK) return FR_DISK_ERR;
; 5674	
; 5675	#if FF_LBA64
; 5676		if (sz_drv >= FF_MIN_GPT) {	/* Create partitions in GPT format */
; 5677			WORD ss;
; 5678			UINT sz_ptbl, pi, si, ofs;
; 5679			DWORD bcc, rnd, align;
; 5680			QWORD nxt_alloc, sz_part, sz_pool, top_bpt;
; 5681			static const BYTE gpt_mbr[16] = {0x00, 0x00, 0x02, 0x00, 0xEE, 0xFE, 0xFF, 0x00, 0x01, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF};
; 5682	
; 5683	#if FF_MAX_SS != FF_MIN_SS
; 5684			if (disk_ioctl(drv, GET_SECTOR_SIZE, &ss) != RES_OK) return FR_DISK_ERR;	/* Get sector size */
; 5685			if (ss > FF_MAX_SS || ss < FF_MIN_SS || (ss & (ss - 1))) return FR_DISK_ERR;
; 5686	#else
; 5687			ss = FF_MAX_SS;
; 5688	#endif
; 5689			rnd = (DWORD)sz_drv + GET_FATTIME();	/* Random seed */
; 5690			align = GPT_ALIGN / ss;				/* Partition alignment for GPT [sector] */
; 5691			sz_ptbl = GPT_ITEMS * SZ_GPTE / ss;	/* Size of partition table [sector] */
; 5692			top_bpt = sz_drv - sz_ptbl - 1;		/* Backup partiiton table start sector */
; 5693			nxt_alloc = 2 + sz_ptbl;			/* First allocatable sector */
; 5694			sz_pool = top_bpt - nxt_alloc;		/* Size of allocatable area */
; 5695			bcc = 0xFFFFFFFF; sz_part = 1;
; 5696			pi = si = 0;	/* partition table index, size table index */
; 5697			do {
; 5698				if (pi * SZ_GPTE % ss == 0) memset(buf, 0, ss);	/* Clean the buffer if needed */
; 5699				if (sz_part != 0) {				/* Is the size table not termintated? */
; 5700					nxt_alloc = (nxt_alloc + align - 1) & ((QWORD)0 - align);	/* Align partition start */
; 5701					sz_part = plst[si++];		/* Get a partition size */
; 5702					if (sz_part <= 100) {		/* Is the size in percentage? */
; 5703						sz_part = sz_pool * sz_part / 100;
; 5704						sz_part = (sz_part + align - 1) & ((QWORD)0 - align);	/* Align partition end (only if in percentage) */
; 5705					}
; 5706					if (nxt_alloc + sz_part > top_bpt) {	/* Clip the size at end of the pool */
; 5707						sz_part = (nxt_alloc < top_bpt) ? top_bpt - nxt_alloc : 0;
; 5708					}
; 5709				}
; 5710				if (sz_part != 0) {				/* Add a partition? */
; 5711					ofs = pi * SZ_GPTE % ss;
; 5712					memcpy(buf + ofs + GPTE_PtGuid, GUID_MS_Basic, 16);	/* Set partition GUID (Microsoft Basic Data) */
; 5713					rnd = make_rand(rnd, buf + ofs + GPTE_UpGuid, 16);	/* Set unique partition GUID */
; 5714					st_qword(buf + ofs + GPTE_FstLba, nxt_alloc);		/* Set partition start sector */
; 5715					st_qword(buf + ofs + GPTE_LstLba, nxt_alloc + sz_part - 1);	/* Set partition end sector */
; 5716					nxt_alloc += sz_part;								/* Next allocatable sector */
; 5717				}
; 5718				if ((pi + 1) * SZ_GPTE % ss == 0) {		/* Write the buffer if it is filled up */
; 5719					for (i = 0; i < ss; bcc = crc32(bcc, buf[i++])) ;	/* Calculate table check sum */
; 5720					if (disk_write(drv, buf, 2 + pi * SZ_GPTE / ss, 1) != RES_OK) return FR_DISK_ERR;		/* Write to primary table */
; 5721					if (disk_write(drv, buf, top_bpt + pi * SZ_GPTE / ss, 1) != RES_OK) return FR_DISK_ERR;	/* Write to secondary table */
; 5722				}
; 5723			} while (++pi < GPT_ITEMS);
; 5724	
; 5725			/* Create primary GPT header */
; 5726			memset(buf, 0, ss);
; 5727			memcpy(buf + GPTH_Sign, "EFI PART" "\0\0\1\0" "\x5C\0\0", 16);	/* Signature, version (1.0) and size (92) */
; 5728			st_dword(buf + GPTH_PtBcc, ~bcc);			/* Table check sum */
; 5729			st_qword(buf + GPTH_CurLba, 1);				/* LBA of this header */
; 5730			st_qword(buf + GPTH_BakLba, sz_drv - 1);	/* LBA of secondary header */
; 5731			st_qword(buf + GPTH_FstLba, 2 + sz_ptbl);	/* LBA of first allocatable sector */
; 5732			st_qword(buf + GPTH_LstLba, top_bpt - 1);	/* LBA of last allocatable sector */
; 5733			st_dword(buf + GPTH_PteSize, SZ_GPTE);		/* Size of a table entry */
; 5734			st_dword(buf + GPTH_PtNum, GPT_ITEMS);		/* Number of table entries */
; 5735			st_dword(buf + GPTH_PtOfs, 2);				/* LBA of this table */
; 5736			rnd = make_rand(rnd, buf + GPTH_DskGuid, 16);	/* Disk GUID */
; 5737			for (i = 0, bcc= 0xFFFFFFFF; i < 92; bcc = crc32(bcc, buf[i++])) ;	/* Calculate header check sum */
; 5738			st_dword(buf + GPTH_Bcc, ~bcc);				/* Header check sum */
; 5739			if (disk_write(drv, buf, 1, 1) != RES_OK) return FR_DISK_ERR;
; 5740	
; 5741			/* Create secondary GPT header */
; 5742			st_qword(buf + GPTH_CurLba, sz_drv - 1);	/* LBA of this header */
; 5743			st_qword(buf + GPTH_BakLba, 1);				/* LBA of primary header */
; 5744			st_qword(buf + GPTH_PtOfs, top_bpt);		/* LBA of this table */
; 5745			st_dword(buf + GPTH_Bcc, 0);
; 5746			for (i = 0, bcc= 0xFFFFFFFF; i < 92; bcc = crc32(bcc, buf[i++])) ;	/* Calculate header check sum */
; 5747			st_dword(buf + GPTH_Bcc, ~bcc);				/* Header check sum */
; 5748			if (disk_write(drv, buf, sz_drv - 1, 1) != RES_OK) return FR_DISK_ERR;
; 5749	
; 5750			/* Create protective MBR */
; 5751			memset(buf, 0, ss);
; 5752			memcpy(buf + MBR_Table, gpt_mbr, 16);		/* Create a GPT partition */
; 5753			st_word(buf + BS_55AA, 0xAA55);
; 5754			if (disk_write(drv, buf, 0, 1) != RES_OK) return FR_DISK_ERR;
; 5755	
; 5756		} else
; 5757	#endif
; 5758		{	/* Create partitions in MBR format */
; 5759			sz_drv32 = (DWORD)sz_drv;
; 5760			n_sc = N_SEC_TRACK;				/* Determine drive CHS without any consideration of the drive geometry */
; 5761			for (n_hd = 8; n_hd != 0 && sz_drv32 / n_hd / n_sc > 1024; n_hd *= 2) ;
; 5762			if (n_hd == 0) n_hd = 255;		/* Number of heads needs to be <256 */
; 5763	
; 5764			memset(buf, 0, FF_MAX_SS);		/* Clear MBR */
; 5765			pte = buf + MBR_Table;	/* Partition table in the MBR */
; 5766			for (i = 0, nxt_alloc32 = n_sc; i < 4 && nxt_alloc32 != 0 && nxt_alloc32 < sz_drv32; i++, nxt_alloc32 += sz_part32) {
; 5767				sz_part32 = (DWORD)plst[i];	/* Get partition size */
; 5768				if (sz_part32 <= 100) sz_part32 = (sz_part32 == 100) ? sz_drv32 : sz_drv32 / 100 * sz_part32;	/* Size in percentage? */
; 5769				if (nxt_alloc32 + sz_part32 > sz_drv32 || nxt_alloc32 + sz_part32 < nxt_alloc32) sz_part32 = sz_drv32 - nxt_alloc32;	/* Clip at drive size */
; 5770				if (sz_part32 == 0) break;	/* End of table or no sector to allocate? */
; 5771	
; 5772				st_dword(pte + PTE_StLba, nxt_alloc32);	/* Start LBA */
; 5773				st_dword(pte + PTE_SizLba, sz_part32);	/* Number of sectors */
; 5774				pte[PTE_System] = sys;					/* System type */
; 5775	
; 5776				cy = (UINT)(nxt_alloc32 / n_sc / n_hd);	/* Start cylinder */
; 5777				hd = (BYTE)(nxt_alloc32 / n_sc % n_hd);	/* Start head */
; 5778				sc = (BYTE)(nxt_alloc32 % n_sc + 1);	/* Start sector */
; 5779				pte[PTE_StHead] = hd;
; 5780				pte[PTE_StSec] = (BYTE)((cy >> 2 & 0xC0) | sc);
; 5781				pte[PTE_StCyl] = (BYTE)cy;
; 5782	
; 5783				cy = (UINT)((nxt_alloc32 + sz_part32 - 1) / n_sc / n_hd);	/* End cylinder */
; 5784				hd = (BYTE)((nxt_alloc32 + sz_part32 - 1) / n_sc % n_hd);	/* End head */
; 5785				sc = (BYTE)((nxt_alloc32 + sz_part32 - 1) % n_sc + 1);		/* End sector */
; 5786				pte[PTE_EdHead] = hd;
; 5787				pte[PTE_EdSec] = (BYTE)((cy >> 2 & 0xC0) | sc);
; 5788				pte[PTE_EdCyl] = (BYTE)cy;
; 5789	
; 5790				pte += SZ_PTE;		/* Next entry */
; 5791			}
; 5792	
; 5793			st_word(buf + BS_55AA, 0xAA55);		/* MBR signature */
; 5794			if (disk_write(drv, buf, 0, 1) != RES_OK) return FR_DISK_ERR;	/* Write it to the MBR */
; 5795		}
; 5796	
; 5797		return FR_OK;
; 5798	}
; 5799	
; 5800	
; 5801	
; 5802	FRESULT f_mkfs (
; 5803		const TCHAR* path,		/* Logical drive number */
; 5804		const MKFS_PARM* opt,	/* Format options */
; 5805		void* work,				/* Pointer to working buffer (null: use heap memory) */
; 5806		UINT len				/* Size of working buffer [byte] */
; 5807	)
; 5808	{
; 5809		static const WORD cst[] = {1, 4, 16, 64, 256, 512, 0};	/* Cluster size boundary for FAT volume (4Ks unit) */
; 5810		static const WORD cst32[] = {1, 2, 4, 8, 16, 32, 0};	/* Cluster size boundary for FAT32 volume (128Ks unit) */
; 5811		static const MKFS_PARM defopt = {FM_ANY, 0, 0, 0, 0};	/* Default parameter */
; 5812		BYTE fsopt, fsty, sys, *buf, *pte, pdrv, ipart;
; 5813		WORD ss;	/* Sector size */
; 5814		DWORD sz_buf, sz_blk, n_clst, pau, nsect, n, vsn;
; 5815		LBA_t sz_vol, b_vol, b_fat, b_data;		/* Size of volume, Base LBA of volume, fat, data */
; 5816		LBA_t sect, lba[2];
; 5817		DWORD sz_rsv, sz_fat, sz_dir, sz_au;	/* Size of reserved, fat, dir, data, cluster */
; 5818		UINT n_fat, n_root, i;					/* Index, Number of FATs and Number of roor dir entries */
; 5819		int vol;
; 5820		DSTATUS ds;
; 5821		FRESULT fr;
; 5822	
; 5823	
; 5824		/* Check mounted drive and clear work area */
; 5825		vol = get_ldnumber(&path);					/* Get target logical drive */
; 5826		if (vol < 0) return FR_INVALID_DRIVE;
; 5827		if (FatFs[vol]) FatFs[vol]->fs_type = 0;	/* Clear the fs object if mounted */
; 5828		pdrv = LD2PD(vol);			/* Physical drive */
; 5829		ipart = LD2PT(vol);			/* Partition (0:create as new, 1..:get from partition table) */
; 5830		if (!opt) opt = &defopt;	/* Use default parameter if it is not given */
; 5831	
; 5832		/* Get physical drive status (sz_drv, sz_blk, ss) */
; 5833		ds = disk_initialize(pdrv);
; 5834		if (ds & STA_NOINIT) return FR_NOT_READY;
; 5835		if (ds & STA_PROTECT) return FR_WRITE_PROTECTED;
; 5836		sz_blk = opt->align;
; 5837		if (sz_blk == 0 && disk_ioctl(pdrv, GET_BLOCK_SIZE, &sz_blk) != RES_OK) sz_blk = 1;
; 5838	 	if (sz_blk == 0 || sz_blk > 0x8000 || (sz_blk & (sz_blk - 1))) sz_blk = 1;
; 5839	#if FF_MAX_SS != FF_MIN_SS
; 5840		if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &ss) != RES_OK) return FR_DISK_ERR;
; 5841		if (ss > FF_MAX_SS || ss < FF_MIN_SS || (ss & (ss - 1))) return FR_DISK_ERR;
; 5842	#else
; 5843		ss = FF_MAX_SS;
; 5844	#endif
; 5845		/* Options for FAT sub-type and FAT parameters */
; 5846		fsopt = opt->fmt & (FM_ANY | FM_SFD);
; 5847		n_fat = (opt->n_fat >= 1 && opt->n_fat <= 2) ? opt->n_fat : 1;
; 5848		n_root = (opt->n_root >= 1 && opt->n_root <= 32768 && (opt->n_root % (ss / SZDIRE)) == 0) ? opt->n_root : 512;
; 5849		sz_au = (opt->au_size <= 0x1000000 && (opt->au_size & (opt->au_size - 1)) == 0) ? opt->au_size : 0;
; 5850		sz_au /= ss;	/* Byte --> Sector */
; 5851	
; 5852		/* Get working buffer */
; 5853		sz_buf = len / ss;		/* Size of working buffer [sector] */
; 5854		if (sz_buf == 0) return FR_NOT_ENOUGH_CORE;
; 5855		buf = (BYTE*)work;		/* Working buffer */
; 5856	#if FF_USE_LFN == 3
; 5857		if (!buf) buf = ff_memalloc(sz_buf * ss);	/* Use heap memory for working buffer */
; 5858	#endif
; 5859		if (!buf) return FR_NOT_ENOUGH_CORE;
; 5860	
; 5861		/* Determine where the volume to be located (b_vol, sz_vol) */
; 5862		b_vol = sz_vol = 0;
; 5863		if (FF_MULTI_PARTITION && ipart != 0) {	/* Is the volume associated with any specific partition? */
; 5864			/* Get partition location from the existing partition table */
; 5865			if (disk_read(pdrv, buf, 0, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);	/* Load MBR */
; 5866			if (ld_word(buf + BS_55AA) != 0xAA55) LEAVE_MKFS(FR_MKFS_ABORTED);	/* Check if MBR is valid */
; 5867	#if FF_LBA64
; 5868			if (buf[MBR_Table + PTE_System] == 0xEE) {	/* GPT protective MBR? */
; 5869				DWORD n_ent, ofs;
; 5870				QWORD pt_lba;
; 5871	
; 5872				/* Get the partition location from GPT */
; 5873				if (disk_read(pdrv, buf, 1, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);	/* Load GPT header sector (next to MBR) */
; 5874				if (!test_gpt_header(buf)) LEAVE_MKFS(FR_MKFS_ABORTED);	/* Check if GPT header is valid */
; 5875				n_ent = ld_dword(buf + GPTH_PtNum);		/* Number of entries */
; 5876				pt_lba = ld_qword(buf + GPTH_PtOfs);	/* Table start sector */
; 5877				ofs = i = 0;
; 5878				while (n_ent) {		/* Find MS Basic partition with order of ipart */
; 5879					if (ofs == 0 && disk_read(pdrv, buf, pt_lba++, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);	/* Get PT sector */
; 5880					if (!memcmp(buf + ofs + GPTE_PtGuid, GUID_MS_Basic, 16) && ++i == ipart) {	/* MS basic data partition? */
; 5881						b_vol = ld_qword(buf + ofs + GPTE_FstLba);
; 5882						sz_vol = ld_qword(buf + ofs + GPTE_LstLba) - b_vol + 1;
; 5883						break;
; 5884					}
; 5885					n_ent--; ofs = (ofs + SZ_GPTE) % ss;	/* Next entry */
; 5886				}
; 5887				if (n_ent == 0) LEAVE_MKFS(FR_MKFS_ABORTED);	/* Partition not found */
; 5888				fsopt |= 0x80;	/* Partitioning is in GPT */
; 5889			} else
; 5890	#endif
; 5891			{	/* Get the partition location from MBR partition table */
; 5892				pte = buf + (MBR_Table + (ipart - 1) * SZ_PTE);
; 5893				if (ipart > 4 || pte[PTE_System] == 0) LEAVE_MKFS(FR_MKFS_ABORTED);	/* No partition? */
; 5894				b_vol = ld_dword(pte + PTE_StLba);		/* Get volume start sector */
; 5895				sz_vol = ld_dword(pte + PTE_SizLba);	/* Get volume size */
; 5896			}
; 5897		} else {	/* The volume is associated with a physical drive */
; 5898			if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_vol) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
; 5899			if (!(fsopt & FM_SFD)) {	/* To be partitioned? */
; 5900				/* Create a single-partition on the drive in this function */
; 5901	#if FF_LBA64
; 5902				if (sz_vol >= FF_MIN_GPT) {	/* Which partition type to create, MBR or GPT? */
; 5903					fsopt |= 0x80;		/* Partitioning is in GPT */
; 5904					b_vol = GPT_ALIGN / ss; sz_vol -= b_vol + GPT_ITEMS * SZ_GPTE / ss + 1;	/* Estimated partition offset and size */
; 5905				} else
; 5906	#endif
; 5907				{	/* Partitioning is in MBR */
; 5908					if (sz_vol > N_SEC_TRACK) {
; 5909						b_vol = N_SEC_TRACK; sz_vol -= b_vol;	/* Estimated partition offset and size */
; 5910					}
; 5911				}
; 5912			}
; 5913		}
; 5914		if (sz_vol < 128) LEAVE_MKFS(FR_MKFS_ABORTED);	/* Check if volume size is >=128s */
; 5915	
; 5916		/* Now start to create an FAT volume at b_vol and sz_vol */
; 5917	
; 5918		do {	/* Pre-determine the FAT type */
; 5919			if (FF_FS_EXFAT && (fsopt & FM_EXFAT)) {	/* exFAT possible? */
; 5920				if ((fsopt & FM_ANY) == FM_EXFAT || sz_vol >= 0x4000000 || sz_au > 128) {	/* exFAT only, vol >= 64MS or sz_au > 128S ? */
; 5921					fsty = FS_EXFAT; break;
; 5922				}
; 5923			}
; 5924	#if FF_LBA64
; 5925			if (sz_vol >= 0x100000000) LEAVE_MKFS(FR_MKFS_ABORTED);	/* Too large volume for FAT/FAT32 */
; 5926	#endif
; 5927			if (sz_au > 128) sz_au = 128;	/* Invalid AU for FAT/FAT32? */
; 5928			if (fsopt & FM_FAT32) {	/* FAT32 possible? */
; 5929				if (!(fsopt & FM_FAT)) {	/* no-FAT? */
; 5930					fsty = FS_FAT32; break;
; 5931				}
; 5932			}
; 5933			if (!(fsopt & FM_FAT)) LEAVE_MKFS(FR_INVALID_PARAMETER);	/* no-FAT? */
; 5934			fsty = FS_FAT16;
; 5935		} while (0);
; 5936	
; 5937		vsn = (DWORD)sz_vol + GET_FATTIME();	/* VSN generated from current time and partitiion size */
; 5938	
; 5939	#if FF_FS_EXFAT
; 5940		if (fsty == FS_EXFAT) {	/* Create an exFAT volume */
; 5941			DWORD szb_bit, szb_case, sum, nbit, clu, clen[3];
; 5942			WCHAR ch, si;
; 5943			UINT j, st;
; 5944	
; 5945			if (sz_vol < 0x1000) LEAVE_MKFS(FR_MKFS_ABORTED);	/* Too small volume for exFAT? */
; 5946	#if FF_USE_TRIM
; 5947			lba[0] = b_vol; lba[1] = b_vol + sz_vol - 1;	/* Inform storage device that the volume area may be erased */
; 5948			disk_ioctl(pdrv, CTRL_TRIM, lba);
; 5949	#endif
; 5950			/* Determine FAT location, data location and number of clusters */
; 5951			if (sz_au == 0) {	/* AU auto-selection */
; 5952				sz_au = 8;
; 5953				if (sz_vol >= 0x80000) sz_au = 64;		/* >= 512Ks */
; 5954				if (sz_vol >= 0x4000000) sz_au = 256;	/* >= 64Ms */
; 5955			}
; 5956			b_fat = b_vol + 32;										/* FAT start at offset 32 */
; 5957			sz_fat = (DWORD)((sz_vol / sz_au + 2) * 4 + ss - 1) / ss;	/* Number of FAT sectors */
; 5958			b_data = (b_fat + sz_fat + sz_blk - 1) & ~((LBA_t)sz_blk - 1);	/* Align data area to the erase block boundary */
; 5959			if (b_data - b_vol >= sz_vol / 2) LEAVE_MKFS(FR_MKFS_ABORTED);	/* Too small volume? */
; 5960			n_clst = (DWORD)(sz_vol - (b_data - b_vol)) / sz_au;	/* Number of clusters */
; 5961			if (n_clst <16) LEAVE_MKFS(FR_MKFS_ABORTED);			/* Too few clusters? */
; 5962			if (n_clst > MAX_EXFAT) LEAVE_MKFS(FR_MKFS_ABORTED);	/* Too many clusters? */
; 5963	
; 5964			szb_bit = (n_clst + 7) / 8;								/* Size of allocation bitmap */
; 5965			clen[0] = (szb_bit + sz_au * ss - 1) / (sz_au * ss);	/* Number of allocation bitmap clusters */
; 5966	
; 5967			/* Create a compressed up-case table */
; 5968			sect = b_data + sz_au * clen[0];	/* Table start sector */
; 5969			sum = 0;							/* Table checksum to be stored in the 82 entry */
; 5970			st = 0; si = 0; i = 0; j = 0; szb_case = 0;
; 5971			do {
; 5972				switch (st) {
; 5973				case 0:
; 5974					ch = (WCHAR)ff_wtoupper(si);	/* Get an up-case char */
; 5975					if (ch != si) {
; 5976						si++; break;		/* Store the up-case char if exist */
; 5977					}
; 5978					for (j = 1; (WCHAR)(si + j) && (WCHAR)(si + j) == ff_wtoupper((WCHAR)(si + j)); j++) ;	/* Get run length of no-case block */
; 5979					if (j >= 128) {
; 5980						ch = 0xFFFF; st = 2; break;	/* Compress the no-case block if run is >= 128 chars */
; 5981					}
; 5982					st = 1;			/* Do not compress short run */
; 5983					/* FALLTHROUGH */
; 5984				case 1:
; 5985					ch = si++;		/* Fill the short run */
; 5986					if (--j == 0) st = 0;
; 5987					break;
; 5988	
; 5989				default:
; 5990					ch = (WCHAR)j; si += (WCHAR)j;	/* Number of chars to skip */
; 5991					st = 0;
; 5992				}
; 5993				sum = xsum32(buf[i + 0] = (BYTE)ch, sum);	/* Put it into the write buffer */
; 5994				sum = xsum32(buf[i + 1] = (BYTE)(ch >> 8), sum);
; 5995				i += 2; szb_case += 2;
; 5996				if (si == 0 || i == sz_buf * ss) {		/* Write buffered data when buffer full or end of process */
; 5997					n = (i + ss - 1) / ss;
; 5998					if (disk_write(pdrv, buf, sect, n) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
; 5999					sect += n; i = 0;
; 6000				}
; 6001			} while (si);
; 6002			clen[1] = (szb_case + sz_au * ss - 1) / (sz_au * ss);	/* Number of up-case table clusters */
; 6003			clen[2] = 1;	/* Number of root dir clusters */
; 6004	
; 6005			/* Initialize the allocation bitmap */
; 6006			sect = b_data; nsect = (szb_bit + ss - 1) / ss;	/* Start of bitmap and number of bitmap sectors */
; 6007			nbit = clen[0] + clen[1] + clen[2];				/* Number of clusters in-use by system (bitmap, up-case and root-dir) */
; 6008			do {
; 6009				memset(buf, 0, sz_buf * ss);				/* Initialize bitmap buffer */
; 6010				for (i = 0; nbit != 0 && i / 8 < sz_buf * ss; buf[i / 8] |= 1 << (i % 8), i++, nbit--) ;	/* Mark used clusters */
; 6011				n = (nsect > sz_buf) ? sz_buf : nsect;		/* Write the buffered data */
; 6012				if (disk_write(pdrv, buf, sect, n) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
; 6013				sect += n; nsect -= n;
; 6014			} while (nsect);
; 6015	
; 6016			/* Initialize the FAT */
; 6017			sect = b_fat; nsect = sz_fat;	/* Start of FAT and number of FAT sectors */
; 6018			j = nbit = clu = 0;
; 6019			do {
; 6020				memset(buf, 0, sz_buf * ss); i = 0;	/* Clear work area and reset write offset */
; 6021				if (clu == 0) {	/* Initialize FAT [0] and FAT[1] */
; 6022					st_dword(buf + i, 0xFFFFFFF8); i += 4; clu++;
; 6023					st_dword(buf + i, 0xFFFFFFFF); i += 4; clu++;
; 6024				}
; 6025				do {			/* Create chains of bitmap, up-case and root dir */
; 6026					while (nbit != 0 && i < sz_buf * ss) {	/* Create a chain */
; 6027						st_dword(buf + i, (nbit > 1) ? clu + 1 : 0xFFFFFFFF);
; 6028						i += 4; clu++; nbit--;
; 6029					}
; 6030					if (nbit == 0 && j < 3) nbit = clen[j++];	/* Get next chain length */
; 6031				} while (nbit != 0 && i < sz_buf * ss);
; 6032				n = (nsect > sz_buf) ? sz_buf : nsect;	/* Write the buffered data */
; 6033				if (disk_write(pdrv, buf, sect, n) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
; 6034				sect += n; nsect -= n;
; 6035			} while (nsect);
; 6036	
; 6037			/* Initialize the root directory */
; 6038			memset(buf, 0, sz_buf * ss);
; 6039			buf[SZDIRE * 0 + 0] = ET_VLABEL;				/* Volume label entry (no label) */
; 6040			buf[SZDIRE * 1 + 0] = ET_BITMAP;				/* Bitmap entry */
; 6041			st_dword(buf + SZDIRE * 1 + 20, 2);				/*  cluster */
; 6042			st_dword(buf + SZDIRE * 1 + 24, szb_bit);		/*  size */
; 6043			buf[SZDIRE * 2 + 0] = ET_UPCASE;				/* Up-case table entry */
; 6044			st_dword(buf + SZDIRE * 2 + 4, sum);			/*  sum */
; 6045			st_dword(buf + SZDIRE * 2 + 20, 2 + clen[0]);	/*  cluster */
; 6046			st_dword(buf + SZDIRE * 2 + 24, szb_case);		/*  size */
; 6047			sect = b_data + sz_au * (clen[0] + clen[1]); nsect = sz_au;	/* Start of the root directory and number of sectors */
; 6048			do {	/* Fill root directory sectors */
; 6049				n = (nsect > sz_buf) ? sz_buf : nsect;
; 6050				if (disk_write(pdrv, buf, sect, n) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
; 6051				memset(buf, 0, ss);	/* Rest of entries are filled with zero */
; 6052				sect += n; nsect -= n;
; 6053			} while (nsect);
; 6054	
; 6055			/* Create two set of the exFAT VBR blocks */
; 6056			sect = b_vol;
; 6057			for (n = 0; n < 2; n++) {
; 6058				/* Main record (+0) */
; 6059				memset(buf, 0, ss);
; 6060				memcpy(buf + BS_JmpBoot, "\xEB\x76\x90" "EXFAT   ", 11);	/* Boot jump code (x86), OEM name */
; 6061				st_qword(buf + BPB_VolOfsEx, b_vol);					/* Volume offset in the physical drive [sector] */
; 6062				st_qword(buf + BPB_TotSecEx, sz_vol);					/* Volume size [sector] */
; 6063				st_dword(buf + BPB_FatOfsEx, (DWORD)(b_fat - b_vol));	/* FAT offset [sector] */
; 6064				st_dword(buf + BPB_FatSzEx, sz_fat);					/* FAT size [sector] */
; 6065				st_dword(buf + BPB_DataOfsEx, (DWORD)(b_data - b_vol));	/* Data offset [sector] */
; 6066				st_dword(buf + BPB_NumClusEx, n_clst);					/* Number of clusters */
; 6067				st_dword(buf + BPB_RootClusEx, 2 + clen[0] + clen[1]);	/* Root dir cluster # */
; 6068				st_dword(buf + BPB_VolIDEx, vsn);						/* VSN */
; 6069				st_word(buf + BPB_FSVerEx, 0x100);						/* Filesystem version (1.00) */
; 6070				for (buf[BPB_BytsPerSecEx] = 0, i = ss; i >>= 1; buf[BPB_BytsPerSecEx]++) ;	/* Log2 of sector size [byte] */
; 6071				for (buf[BPB_SecPerClusEx] = 0, i = sz_au; i >>= 1; buf[BPB_SecPerClusEx]++) ;	/* Log2 of cluster size [sector] */
; 6072				buf[BPB_NumFATsEx] = 1;					/* Number of FATs */
; 6073				buf[BPB_DrvNumEx] = 0x80;				/* Drive number (for int13) */
; 6074				st_word(buf + BS_BootCodeEx, 0xFEEB);	/* Boot code (x86) */
; 6075				st_word(buf + BS_55AA, 0xAA55);			/* Signature (placed here regardless of sector size) */
; 6076				for (i = sum = 0; i < ss; i++) {		/* VBR checksum */
; 6077					if (i != BPB_VolFlagEx && i != BPB_VolFlagEx + 1 && i != BPB_PercInUseEx) sum = xsum32(buf[i], sum);
; 6078				}
; 6079				if (disk_write(pdrv, buf, sect++, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
; 6080				/* Extended bootstrap record (+1..+8) */
; 6081				memset(buf, 0, ss);
; 6082				st_word(buf + ss - 2, 0xAA55);	/* Signature (placed at end of sector) */
; 6083				for (j = 1; j < 9; j++) {
; 6084					for (i = 0; i < ss; sum = xsum32(buf[i++], sum)) ;	/* VBR checksum */
; 6085					if (disk_write(pdrv, buf, sect++, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
; 6086				}
; 6087				/* OEM/Reserved record (+9..+10) */
; 6088				memset(buf, 0, ss);
; 6089				for ( ; j < 11; j++) {
; 6090					for (i = 0; i < ss; sum = xsum32(buf[i++], sum)) ;	/* VBR checksum */
; 6091					if (disk_write(pdrv, buf, sect++, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
; 6092				}
; 6093				/* Sum record (+11) */
; 6094				for (i = 0; i < ss; i += 4) st_dword(buf + i, sum);		/* Fill with checksum value */
; 6095				if (disk_write(pdrv, buf, sect++, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
; 6096			}
; 6097	
; 6098		} else
; 6099	#endif	/* FF_FS_EXFAT */
; 6100		{	/* Create an FAT/FAT32 volume */
; 6101			do {
; 6102				pau = sz_au;
; 6103				/* Pre-determine number of clusters and FAT sub-type */
; 6104				if (fsty == FS_FAT32) {	/* FAT32 volume */
; 6105					if (pau == 0) {	/* AU auto-selection */
; 6106						n = (DWORD)sz_vol / 0x20000;	/* Volume size in unit of 128KS */
; 6107						for (i = 0, pau = 1; cst32[i] && cst32[i] <= n; i++, pau <<= 1) ;	/* Get from table */
; 6108					}
; 6109					n_clst = (DWORD)sz_vol / pau;	/* Number of clusters */
; 6110					sz_fat = (n_clst * 4 + 8 + ss - 1) / ss;	/* FAT size [sector] */
; 6111					sz_rsv = 32;	/* Number of reserved sectors */
; 6112					sz_dir = 0;		/* No static directory */
; 6113					if (n_clst <= MAX_FAT16 || n_clst > MAX_FAT32) LEAVE_MKFS(FR_MKFS_ABORTED);
; 6114				} else {				/* FAT volume */
; 6115					if (pau == 0) {	/* au auto-selection */
; 6116						n = (DWORD)sz_vol / 0x1000;	/* Volume size in unit of 4KS */
; 6117						for (i = 0, pau = 1; cst[i] && cst[i] <= n; i++, pau <<= 1) ;	/* Get from table */
; 6118					}
; 6119					n_clst = (DWORD)sz_vol / pau;
; 6120					if (n_clst > MAX_FAT12) {
; 6121						n = n_clst * 2 + 4;		/* FAT size [byte] */
; 6122					} else {
; 6123						fsty = FS_FAT12;
; 6124						n = (n_clst * 3 + 1) / 2 + 3;	/* FAT size [byte] */
; 6125					}
; 6126					sz_fat = (n + ss - 1) / ss;		/* FAT size [sector] */
; 6127					sz_rsv = 1;						/* Number of reserved sectors */
; 6128					sz_dir = (DWORD)n_root * SZDIRE / ss;	/* Root dir size [sector] */
; 6129				}
; 6130				b_fat = b_vol + sz_rsv;						/* FAT base */
; 6131				b_data = b_fat + sz_fat * n_fat + sz_dir;	/* Data base */
; 6132	
; 6133				/* Align data area to erase block boundary (for flash memory media) */
; 6134				n = (DWORD)(((b_data + sz_blk - 1) & ~(sz_blk - 1)) - b_data);	/* Sectors to next nearest from current data base */
; 6135				if (fsty == FS_FAT32) {		/* FAT32: Move FAT */
; 6136					sz_rsv += n; b_fat += n;
; 6137				} else {					/* FAT: Expand FAT */
; 6138					if (n % n_fat) {	/* Adjust fractional error if needed */
; 6139						n--; sz_rsv++; b_fat++;
; 6140					}
; 6141					sz_fat += n / n_fat;
; 6142				}
; 6143	
; 6144				/* Determine number of clusters and final check of validity of the FAT sub-type */
; 6145				if (sz_vol < b_data + pau * 16 - b_vol) LEAVE_MKFS(FR_MKFS_ABORTED);	/* Too small volume? */
; 6146				n_clst = ((DWORD)sz_vol - sz_rsv - sz_fat * n_fat - sz_dir) / pau;
; 6147				if (fsty == FS_FAT32) {
; 6148					if (n_clst <= MAX_FAT16) {	/* Too few clusters for FAT32? */
; 6149						if (sz_au == 0 && (sz_au = pau / 2) != 0) continue;	/* Adjust cluster size and retry */
; 6150						LEAVE_MKFS(FR_MKFS_ABORTED);
; 6151					}
; 6152				}
; 6153				if (fsty == FS_FAT16) {
; 6154					if (n_clst > MAX_FAT16) {	/* Too many clusters for FAT16 */
; 6155						if (sz_au == 0 && (pau * 2) <= 64) {
; 6156							sz_au = pau * 2; continue;	/* Adjust cluster size and retry */
; 6157						}
; 6158						if ((fsopt & FM_FAT32)) {
; 6159							fsty = FS_FAT32; continue;	/* Switch type to FAT32 and retry */
; 6160						}
; 6161						if (sz_au == 0 && (sz_au = pau * 2) <= 128) continue;	/* Adjust cluster size and retry */
; 6162						LEAVE_MKFS(FR_MKFS_ABORTED);
; 6163					}
; 6164					if  (n_clst <= MAX_FAT12) {	/* Too few clusters for FAT16 */
; 6165						if (sz_au == 0 && (sz_au = pau * 2) <= 128) continue;	/* Adjust cluster size and retry */
; 6166						LEAVE_MKFS(FR_MKFS_ABORTED);
; 6167					}
; 6168				}
; 6169				if (fsty == FS_FAT12 && n_clst > MAX_FAT12) LEAVE_MKFS(FR_MKFS_ABORTED);	/* Too many clusters for FAT12 */
; 6170	
; 6171				/* Ok, it is the valid cluster configuration */
; 6172				break;
; 6173			} while (1);
; 6174	
; 6175	#if FF_USE_TRIM
; 6176			lba[0] = b_vol; lba[1] = b_vol + sz_vol - 1;	/* Inform storage device that the volume area may be erased */
; 6177			disk_ioctl(pdrv, CTRL_TRIM, lba);
; 6178	#endif
; 6179			/* Create FAT VBR */
; 6180			memset(buf, 0, ss);
; 6181			memcpy(buf + BS_JmpBoot, "\xEB\xFE\x90" "MSDOS5.0", 11);	/* Boot jump code (x86), OEM name */
; 6182			st_word(buf + BPB_BytsPerSec, ss);				/* Sector size [byte] */
; 6183			buf[BPB_SecPerClus] = (BYTE)pau;				/* Cluster size [sector] */
; 6184			st_word(buf + BPB_RsvdSecCnt, (WORD)sz_rsv);	/* Size of reserved area */
; 6185			buf[BPB_NumFATs] = (BYTE)n_fat;					/* Number of FATs */
; 6186			st_word(buf + BPB_RootEntCnt, (WORD)((fsty == FS_FAT32) ? 0 : n_root));	/* Number of root directory entries */
; 6187			if (sz_vol < 0x10000) {
; 6188				st_word(buf + BPB_TotSec16, (WORD)sz_vol);	/* Volume size in 16-bit LBA */
; 6189			} else {
; 6190				st_dword(buf + BPB_TotSec32, (DWORD)sz_vol);	/* Volume size in 32-bit LBA */
; 6191			}
; 6192			buf[BPB_Media] = 0xF8;							/* Media descriptor byte */
; 6193			st_word(buf + BPB_SecPerTrk, 63);				/* Number of sectors per track (for int13) */
; 6194			st_word(buf + BPB_NumHeads, 255);				/* Number of heads (for int13) */
; 6195			st_dword(buf + BPB_HiddSec, (DWORD)b_vol);		/* Volume offset in the physical drive [sector] */
; 6196			if (fsty == FS_FAT32) {
; 6197				st_dword(buf + BS_VolID32, vsn);			/* VSN */
; 6198				st_dword(buf + BPB_FATSz32, sz_fat);		/* FAT size [sector] */
; 6199				st_dword(buf + BPB_RootClus32, 2);			/* Root directory cluster # (2) */
; 6200				st_word(buf + BPB_FSInfo32, 1);				/* Offset of FSINFO sector (VBR + 1) */
; 6201				st_word(buf + BPB_BkBootSec32, 6);			/* Offset of backup VBR (VBR + 6) */
; 6202				buf[BS_DrvNum32] = 0x80;					/* Drive number (for int13) */
; 6203				buf[BS_BootSig32] = 0x29;					/* Extended boot signature */
; 6204				memcpy(buf + BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
; 6205			} else {
; 6206				st_dword(buf + BS_VolID, vsn);				/* VSN */
; 6207				st_word(buf + BPB_FATSz16, (WORD)sz_fat);	/* FAT size [sector] */
; 6208				buf[BS_DrvNum] = 0x80;						/* Drive number (for int13) */
; 6209				buf[BS_BootSig] = 0x29;						/* Extended boot signature */
; 6210				memcpy(buf + BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
; 6211			}
; 6212			st_word(buf + BS_55AA, 0xAA55);					/* Signature (offset is fixed here regardless of sector size) */
; 6213			if (disk_write(pdrv, buf, b_vol, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);	/* Write it to the VBR sector */
; 6214	
; 6215			/* Create FSINFO record if needed */
; 6216			if (fsty == FS_FAT32) {
; 6217				disk_write(pdrv, buf, b_vol + 6, 1);		/* Write backup VBR (VBR + 6) */
; 6218				memset(buf, 0, ss);
; 6219				st_dword(buf + FSI_LeadSig, 0x41615252);
; 6220				st_dword(buf + FSI_StrucSig, 0x61417272);
; 6221				st_dword(buf + FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
; 6222				st_dword(buf + FSI_Nxt_Free, 2);			/* Last allocated cluster# */
; 6223				st_word(buf + BS_55AA, 0xAA55);
; 6224				disk_write(pdrv, buf, b_vol + 7, 1);		/* Write backup FSINFO (VBR + 7) */
; 6225				disk_write(pdrv, buf, b_vol + 1, 1);		/* Write original FSINFO (VBR + 1) */
; 6226			}
; 6227	
; 6228			/* Initialize FAT area */
; 6229			memset(buf, 0, sz_buf * ss);
; 6230			sect = b_fat;		/* FAT start sector */
; 6231			for (i = 0; i < n_fat; i++) {			/* Initialize FATs each */
; 6232				if (fsty == FS_FAT32) {
; 6233					st_dword(buf + 0, 0xFFFFFFF8);	/* FAT[0] */
; 6234					st_dword(buf + 4, 0xFFFFFFFF);	/* FAT[1] */
; 6235					st_dword(buf + 8, 0x0FFFFFFF);	/* FAT[2] (root directory) */
; 6236				} else {
; 6237					st_dword(buf + 0, (fsty == FS_FAT12) ? 0xFFFFF8 : 0xFFFFFFF8);	/* FAT[0] and FAT[1] */
; 6238				}
; 6239				nsect = sz_fat;		/* Number of FAT sectors */
; 6240				do {	/* Fill FAT sectors */
; 6241					n = (nsect > sz_buf) ? sz_buf : nsect;
; 6242					if (disk_write(pdrv, buf, sect, (UINT)n) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
; 6243					memset(buf, 0, ss);	/* Rest of FAT all are cleared */
; 6244					sect += n; nsect -= n;
; 6245				} while (nsect);
; 6246			}
; 6247	
; 6248			/* Initialize root directory (fill with zero) */
; 6249			nsect = (fsty == FS_FAT32) ? pau : sz_dir;	/* Number of root directory sectors */
; 6250			do {
; 6251				n = (nsect > sz_buf) ? sz_buf : nsect;
; 6252				if (disk_write(pdrv, buf, sect, (UINT)n) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
; 6253				sect += n; nsect -= n;
; 6254			} while (nsect);
; 6255		}
; 6256	
; 6257		/* A FAT volume has been created here */
; 6258	
; 6259		/* Determine system ID in the MBR partition table */
; 6260		if (FF_FS_EXFAT && fsty == FS_EXFAT) {
; 6261			sys = 0x07;			/* exFAT */
; 6262		} else {
; 6263			if (fsty == FS_FAT32) {
; 6264				sys = 0x0C;		/* FAT32X */
; 6265			} else {
; 6266				if (sz_vol >= 0x10000) {
; 6267					sys = 0x06;	/* FAT12/16 (large) */
; 6268				} else {
; 6269					sys = (fsty == FS_FAT16) ? 0x04 : 0x01;	/* FAT16 : FAT12 */
; 6270				}
; 6271			}
; 6272		}
; 6273	
; 6274		/* Update partition information */
; 6275		if (FF_MULTI_PARTITION && ipart != 0) {	/* Volume is in the existing partition */
; 6276			if (!FF_LBA64 || !(fsopt & 0x80)) {
; 6277				/* Update system ID in the partition table */
; 6278				if (disk_read(pdrv, buf, 0, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);	/* Read the MBR */
; 6279				buf[MBR_Table + (ipart - 1) * SZ_PTE + PTE_System] = sys;			/* Set system ID */
; 6280				if (disk_write(pdrv, buf, 0, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);	/* Write it back to the MBR */
; 6281			}
; 6282		} else {								/* Volume as a new single partition */
; 6283			if (!(fsopt & FM_SFD)) {			/* Create partition table if not in SFD */
; 6284				lba[0] = sz_vol; lba[1] = 0;
; 6285				fr = create_partition(pdrv, lba, sys, buf);
; 6286				if (fr != FR_OK) LEAVE_MKFS(fr);
; 6287			}
; 6288		}
; 6289	
; 6290		if (disk_ioctl(pdrv, CTRL_SYNC, 0) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
; 6291	
; 6292		LEAVE_MKFS(FR_OK);
; 6293	}
; 6294	
; 6295	
; 6296	
; 6297	
; 6298	#if FF_MULTI_PARTITION
; 6299	/*-----------------------------------------------------------------------*/
; 6300	/* Create Partition Table on the Physical Drive                          */
; 6301	/*-----------------------------------------------------------------------*/
; 6302	
; 6303	FRESULT f_fdisk (
; 6304		BYTE pdrv,			/* Physical drive number */
; 6305		const LBA_t ptbl[],	/* Pointer to the size table for each partitions */
; 6306		void* work			/* Pointer to the working buffer (null: use heap memory) */
; 6307	)
; 6308	{
; 6309		BYTE *buf = (BYTE*)work;
; 6310		DSTATUS stat;
; 6311	
; 6312	
; 6313		stat = disk_initialize(pdrv);
; 6314		if (stat & STA_NOINIT) return FR_NOT_READY;
; 6315		if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
; 6316	#if FF_USE_LFN == 3
; 6317		if (!buf) buf = ff_memalloc(FF_MAX_SS);	/* Use heap memory for working buffer */
; 6318	#endif
; 6319		if (!buf) return FR_NOT_ENOUGH_CORE;
; 6320	
; 6321		LEAVE_MKFS(create_partition(pdrv, ptbl, 0x07, buf));
; 6322	}
; 6323	
; 6324	#endif /* FF_MULTI_PARTITION */
; 6325	#endif /* !FF_FS_READONLY && FF_USE_MKFS */
; 6326	
; 6327	
; 6328	
; 6329	
; 6330	#if FF_USE_STRFUNC
; 6331	#if FF_USE_LFN && FF_LFN_UNICODE && (FF_STRF_ENCODE < 0 || FF_STRF_ENCODE > 3)
; 6332	#error Wrong FF_STRF_ENCODE setting
; 6333	#endif
; 6334	/*-----------------------------------------------------------------------*/
; 6335	/* Get a String from the File                                            */
; 6336	/*-----------------------------------------------------------------------*/
; 6337	
; 6338	TCHAR* f_gets (
; 6339		TCHAR* buff,	/* Pointer to the buffer to store read string */
; 6340		int len,		/* Size of string buffer (items) */
; 6341		FIL* fp			/* Pointer to the file object */
; 6342	)
; 6343	{
_f_gets:
.DEFINE "_f_gets"

.VALUE _f_gets

.CLASS 2

.TYPE 322

.ENDEF

.BEGFUNC "f_gets",6343,"_f_gets"

.LINE 6343

.DEFINE "buff"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "len"

.CLASS 65

.VALUE 9

.TYPE 4

.ENDEF

.DEFINE "fp"

.CLASS 65

.VALUE 12

.TAG "NONAME2"

.TYPE 40

.ENDEF

.DEFINE "nc"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "p"

.CLASS 65

.VALUE -6

.TYPE 34

.ENDEF

.DEFINE "rc"

.CLASS 65

.VALUE -12

.TYPE 14

.ENDEF

.DEFINE "dc"

.CLASS 65

.VALUE -16

.TYPE 15

.ENDEF

.DEFINE "s"

.CLASS 65

.VALUE -20

.DIM 4

.TYPE 108

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFE8
	LD	SP,HL
; 6344		int nc = 0;
.LINE 6344

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
; 6345		TCHAR *p = buff;
.LINE 6345

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFA),BC
; 6346		BYTE s[4];
; 6347		UINT rc;
; 6348		DWORD dc;
; 6349	#if FF_USE_LFN && FF_LFN_UNICODE && FF_STRF_ENCODE <= 2
; 6350		WCHAR wc;
; 6351	#endif
; 6352	#if FF_USE_LFN && FF_LFN_UNICODE && FF_STRF_ENCODE == 3
; 6353		UINT ct;
; 6354	#endif
; 6355	
; 6356	#if FF_USE_LFN && FF_LFN_UNICODE			/* With code conversion (Unicode API) */
; 6357		/* Make a room for the character and terminator  */
; 6358		if (FF_LFN_UNICODE == 1) len -= (FF_STRF_ENCODE == 0) ? 1 : 2;
; 6359		if (FF_LFN_UNICODE == 2) len -= (FF_STRF_ENCODE == 0) ? 3 : 4;
; 6360		if (FF_LFN_UNICODE == 3) len -= 1;
; 6361		while (nc < len) {
; 6362	#if FF_STRF_ENCODE == 0				/* Read a character in ANSI/OEM */
; 6363			f_read(fp, s, 1, &rc);		/* Get a code unit */
; 6364			if (rc != 1) break;			/* EOF? */
; 6365			wc = s[0];
; 6366			if (dbc_1st((BYTE)wc)) {	/* DBC 1st byte? */
; 6367				f_read(fp, s, 1, &rc);	/* Get 2nd byte */
; 6368				if (rc != 1 || !dbc_2nd(s[0])) continue;	/* Wrong code? */
; 6369				wc = wc << 8 | s[0];
; 6370			}
; 6371			dc = ff_oem2uni(wc, CODEPAGE);	/* Convert ANSI/OEM into Unicode */
; 6372			if (dc == 0) continue;		/* Conversion error? */
; 6373	#elif FF_STRF_ENCODE == 1 || FF_STRF_ENCODE == 2 	/* Read a character in UTF-16LE/BE */
; 6374			f_read(fp, s, 2, &rc);		/* Get a code unit */
; 6375			if (rc != 2) break;			/* EOF? */
; 6376			dc = (FF_STRF_ENCODE == 1) ? ld_word(s) : s[0] << 8 | s[1];
; 6377			if (IsSurrogateL(dc)) continue;	/* Broken surrogate pair? */
; 6378			if (IsSurrogateH(dc)) {		/* High surrogate? */
; 6379				f_read(fp, s, 2, &rc);	/* Get low surrogate */
; 6380				if (rc != 2) break;		/* EOF? */
; 6381				wc = (FF_STRF_ENCODE == 1) ? ld_word(s) : s[0] << 8 | s[1];
; 6382				if (!IsSurrogateL(wc)) continue;	/* Broken surrogate pair? */
; 6383				dc = ((dc & 0x3FF) + 0x40) << 10 | (wc & 0x3FF);	/* Merge surrogate pair */
; 6384			}
; 6385	#else	/* Read a character in UTF-8 */
; 6386			f_read(fp, s, 1, &rc);		/* Get a code unit */
; 6387			if (rc != 1) break;			/* EOF? */
; 6388			dc = s[0];
; 6389			if (dc >= 0x80) {			/* Multi-byte sequence? */
; 6390				ct = 0;
; 6391				if ((dc & 0xE0) == 0xC0) { dc &= 0x1F; ct = 1; }	/* 2-byte sequence? */
; 6392				if ((dc & 0xF0) == 0xE0) { dc &= 0x0F; ct = 2; }	/* 3-byte sequence? */
; 6393				if ((dc & 0xF8) == 0xF0) { dc &= 0x07; ct = 3; }	/* 4-byte sequence? */
; 6394				if (ct == 0) continue;
; 6395				f_read(fp, s, ct, &rc);	/* Get trailing bytes */
; 6396				if (rc != ct) break;
; 6397				rc = 0;
; 6398				do {	/* Merge the byte sequence */
; 6399					if ((s[rc] & 0xC0) != 0x80) break;
; 6400					dc = dc << 6 | (s[rc] & 0x3F);
; 6401				} while (++rc < ct);
; 6402				if (rc != ct || dc < 0x80 || IsSurrogate(dc) || dc >= 0x110000) continue;	/* Wrong encoding? */
; 6403			}
; 6404	#endif
; 6405			/* A code point is avaialble in dc to be output */
; 6406	
; 6407			if (FF_USE_STRFUNC == 2 && dc == '\r') continue;	/* Strip \r off if needed */
; 6408	#if FF_LFN_UNICODE == 1	|| FF_LFN_UNICODE == 3	/* Output it in UTF-16/32 encoding */
; 6409			if (FF_LFN_UNICODE == 1 && dc >= 0x10000) {	/* Out of BMP at UTF-16? */
; 6410				*p++ = (TCHAR)(0xD800 | ((dc >> 10) - 0x40)); nc++;	/* Make and output high surrogate */
; 6411				dc = 0xDC00 | (dc & 0x3FF);		/* Make low surrogate */
; 6412			}
; 6413			*p++ = (TCHAR)dc; nc++;
; 6414			if (dc == '\n') break;	/* End of line? */
; 6415	#elif FF_LFN_UNICODE == 2		/* Output it in UTF-8 encoding */
; 6416			if (dc < 0x80) {	/* Single byte? */
; 6417				*p++ = (TCHAR)dc;
; 6418				nc++;
; 6419				if (dc == '\n') break;	/* End of line? */
; 6420			} else {
; 6421				if (dc < 0x800) {		/* 2-byte sequence? */
; 6422					*p++ = (TCHAR)(0xC0 | (dc >> 6 & 0x1F));
; 6423					*p++ = (TCHAR)(0x80 | (dc >> 0 & 0x3F));
; 6424					nc += 2;
; 6425				} else {
; 6426					if (dc < 0x10000) {	/* 3-byte sequence? */
; 6427						*p++ = (TCHAR)(0xE0 | (dc >> 12 & 0x0F));
; 6428						*p++ = (TCHAR)(0x80 | (dc >> 6 & 0x3F));
; 6429						*p++ = (TCHAR)(0x80 | (dc >> 0 & 0x3F));
; 6430						nc += 3;
; 6431					} else {			/* 4-byte sequence? */
; 6432						*p++ = (TCHAR)(0xF0 | (dc >> 18 & 0x07));
; 6433						*p++ = (TCHAR)(0x80 | (dc >> 12 & 0x3F));
; 6434						*p++ = (TCHAR)(0x80 | (dc >> 6 & 0x3F));
; 6435						*p++ = (TCHAR)(0x80 | (dc >> 0 & 0x3F));
; 6436						nc += 4;
; 6437					}
; 6438				}
; 6439			}
; 6440	#endif
; 6441		}
; 6442	
; 6443	#else			/* Byte-by-byte read without any conversion (ANSI/OEM API) */
; 6444		len -= 1;	/* Make a room for the terminator */
.LINE 6444

	LD	BC,(IX+%9)
	DEC	BC
	LD	(IX+%9),BC
; 6445		while (nc < len) {
.LINE 6445

	JR	L_691
L_692:
; 6446			f_read(fp, s, 1, &rc);	/* Get a byte */
.LINE 6446

	PEA	IX+%FFFFFFF4
	LD	BC,1
	PUSH	BC
	PEA	IX+%FFFFFFEC
	LD	BC,(IX+%C)
	PUSH	BC
	LD	(IX+%FFFFFFE8),A
	CALL	_f_read
	LD	A,(IX+%FFFFFFE8)
	POP	BC
	POP	BC
	POP	BC
	POP	BC
; 6447			if (rc != 1) break;		/* EOF? */
.LINE 6447

	LD	BC,1
	LD	HL,(IX+%FFFFFFF4)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_693
; 6448			dc = s[0];
.LINE 6448

	UEXT	HL
	LD	L,(IX+%FFFFFFEC)
	LD	(IX+%FFFFFFF0),HL
	LD	(IX+%FFFFFFF3),H
; 6449			if (FF_USE_STRFUNC == 2 && dc == '\r') continue;
; 6450			*p++ = (TCHAR)dc; nc++;
.LINE 6450

	LD	BC,(IX+%FFFFFFFA)
	LD	(IX+%FFFFFFE9),BC
	LD	A,(IX+%FFFFFFF0)
	LD	HL,BC
	LD	(HL),A
	LD	BC,(IX+%FFFFFFFA)
	INC	BC
	LD	(IX+%FFFFFFFA),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
; 6451			if (dc == '\n') break;
.LINE 6451

	LD	HL,(IX+%FFFFFFF0)
	LD	E,(IX+%FFFFFFF3)
	LD	BC,10
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_693
; 6452		}
L_691:
.LINE 6452

	LD	BC,(IX+%9)
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JP	M,L_692
L_693:
; 6453	#endif
; 6454	
; 6455		*p = 0;		/* Terminate the string */
.LINE 6455

	LD	HL,(IX+%FFFFFFFA)
	LD	(HL),%0
; 6456		return nc ? buff : 0;	/* When no data read due to EOF or error, return with error. */
.LINE 6456

	LD	HL,(IX+%FFFFFFFD)
	CALL	__icmpzero
	JR	Z,L_696
	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFF7),BC
	JR	L_697
L_696:
	LD	BC,0
	LD	(IX+%FFFFFFF7),BC
L_697:
	LD	HL,(IX+%FFFFFFF7)
; 6457	}
.LINE 6457

	LD	SP,IX
	POP	IX
	RET	


;**************************** _f_gets ***************************
;Name                         Addr/Register   Size   Type
;_f_read                             IMPORT  -----   function
;s                                    IX-20      4   variable
;dc                                   IX-16      4   variable
;rc                                   IX-12      3   variable
;temp694                               IX-9      3   variable
;p                                     IX-6      3   variable
;nc                                    IX-3      3   variable
;fp                                   IX+12      3   parameter
;len                                   IX+9      3   parameter
;buff                                  IX+6      3   parameter


; Stack Frame Size: 39 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "f_gets",6457,"_f_gets"
	XREF _disk_read:ROM
	XREF _disk_status:ROM
	XREF _disk_initialize:ROM
	XREF _ff_wtoupper:ROM
	XREF _ff_uni2oem:ROM
	XREF _ff_oem2uni:ROM
	XREF _strchr:ROM
	XREF _memset:ROM
	XREF _memcmp:ROM
	XREF _memcpy:ROM
	XREF __lcmpu:ROM
	XREF __ladd:ROM
	XREF __lsub:ROM
	XREF __ldivu:ROM
	XREF __lmulu:ROM
	XREF __sor:ROM
	XREF __ior:ROM
	XREF __lor:ROM
	XREF __sand:ROM
	XREF __iand:ROM
	XREF __land:ROM
	XREF __bshl:ROM
	XREF __lshl:ROM
	XREF __lshru:ROM
	XREF __stoiu:ROM
	XREF __itol:ROM
	XREF __ildix:ROM
	XREF __istix:ROM
	XREF __setflag:ROM
	XREF __scmpzero:ROM
	XREF __icmpzero:ROM
	XREF __lcmpzero:ROM
	XREF __case8D:ROM
	XREF __seqcaseD:ROM
	XREF __imul_b:ROM
	XREF __ladd_b:ROM
	XREF __ishl_b:ROM
	XREF __ishru_b:ROM
	XREF __ishrs_b:ROM
	XDEF _f_gets
	XDEF _f_getlabel
	XDEF _f_getcwd
	XDEF _f_chdir
	XDEF _f_chdrive
	XDEF _f_close
	XDEF _f_read
	XDEF _f_open
	XDEF _f_mount
	END

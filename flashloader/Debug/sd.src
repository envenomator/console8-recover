; Zilog eZ80 ANSI C Compiler Release 3.4
; -nomodsect -optsize -noreduceopt -nopadbranch -debug
; -peephole -globalopt -localcse -const=ROM 
	FILE	"..\sd.c"
	.assume ADL=1
.DEBUG "C"
	SEGMENT CODE
.BEGREC "fmt_type",19
.DEFINE "status"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "flags"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "size"
.VALUE 2
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "chr"
.VALUE 3
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "type"
.VALUE 4
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "field_width"
.VALUE 5
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "precision"
.VALUE 6
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "set_begin"
.VALUE 7
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "set_end"
.VALUE 10
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "pad_whole"
.VALUE 13
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_pre_fract"
.VALUE 14
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_post_fract"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_at"
.VALUE 16
.CLASS 8
.TYPE 34
.ENDEF
.ENDREC "fmt_type"
.BEGREC "flt_info",12
.DEFINE "flags"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "exp"
.VALUE 1
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "digits"
.VALUE 2
.CLASS 8
.DIM 10
.TYPE 108
.ENDEF
.ENDREC "flt_info"
;    1	/*
;    2	 * Title:			AGON MOS - Low level SD card functionality
;    3	 * Author:			RJH
;    4	 * Modified by:		Dean Belfield
;    5	 * Created:			19/06/2022
;    6	 * Last Updated:	09/03/2023
;    7	 * 
;    8	 * Code taken from this article: http://www.rjhcoding.com/avrc-sd-interface-1.php
;    9	 *
;   10	 * Modinfo:
;   11	 * 11/07/2022:		Now includes defines.h
;   12	 * 13/07/2022:		Fixed bug in SD_writeBlocks
;   13	 * 09/03/2023:      Now uses wait_timer0
;   14	 */
;   15	
;   16	#include <eZ80.h>
;   17	#include <defines.h>
;   18	
;   19	#include <stdio.h>
;   20	#include <String.h>
;   21	
;   22	#include "spi.h"
;   23	#include "sd.h"
;   24	#include "timer.h"
;   25	
;   26	void SD_command(BYTE cmd, DWORD arg, BYTE crc) {
_SD_command:
.DEFINE "_SD_command"

.VALUE _SD_command

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "SD_command",26,"_SD_command"

.LINE 26

.DEFINE "cmd"

.CLASS 65

.VALUE 6

.TYPE 12

.ENDEF

.DEFINE "arg"

.CLASS 65

.VALUE 9

.TYPE 15

.ENDEF

.DEFINE "crc"

.CLASS 65

.VALUE 15

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   27	    spi_transfer(cmd|0x40);
.LINE 27

	LD	A,(IX+%6)
	SET	%6,A
	LD	C,A
	LD	B,%0
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;   28	    spi_transfer((BYTE)(arg >> 24));
.LINE 28

	LD	A,(IX+%C)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	B,%0
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;   29	    spi_transfer((BYTE)(arg >> 16));
.LINE 29

	LD	BC,(IX+%9)
	LD	A,(IX+%C)
	LD	L,%10
	CALL	__lshru
	LD	B,%0
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;   30	    spi_transfer((BYTE)(arg >> 8));
.LINE 30

	LD	BC,(IX+%9)
	LD	A,(IX+%C)
	LD	L,%8
	CALL	__lshru
	LD	B,%0
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;   31	    spi_transfer((BYTE)(arg));
.LINE 31

	LD	C,(IX+%9)
	LD	B,%0
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;   32	    spi_transfer(crc|0x01);
.LINE 32

	LD	A,(IX+%F)
	SET	%0,A
	LD	C,A
	LD	B,%0
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;   33	}
.LINE 33

	LD	SP,IX
	POP	IX
	RET	


;**************************** _SD_command ***************************
;Name                         Addr/Register   Size   Type
;_spi_transfer                       IMPORT  -----   function
;crc                                  IX+15      1   parameter
;arg                                   IX+9      4   parameter
;cmd                                   IX+6      1   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "SD_command",33,"_SD_command"
;   34	
;   35	BYTE SD_readRes1() {
_SD_readRes1:
.DEFINE "_SD_readRes1"

.VALUE _SD_readRes1

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "SD_readRes1",35,"_SD_readRes1"

.LINE 35

.DEFINE "i"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "res1"

.CLASS 65

.VALUE -2

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
	DEC	SP
;   36	    BYTE i = 0, res1;
.LINE 36

	LD	(IX+%FFFFFFFF),%0
;   37	
;   38	    // keep polling until actual data received
;   39	    while((res1 = spi_transfer(0xFF)) == 0xFF) {
.LINE 39

	JR	L_3
L_4:
;   40	        i++;
.LINE 40

	INC	(IX+%FFFFFFFF)
;   41	        // if no data received for 8 bytes, break
;   42	        if(i > 8) break;
.LINE 42

	LD	A,%8
	CP	A,(IX+%FFFFFFFF)
	JR	C,L_5
;   43	    }
L_3:
.LINE 43

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
	LD	(IX+%FFFFFFFE),A
	CP	A,%FF
	JR	Z,L_4
L_5:
;   44	    return res1;
.LINE 44

	LD	A,(IX+%FFFFFFFE)
;   45	}
.LINE 45

	LD	SP,IX
	POP	IX
	RET	


;**************************** _SD_readRes1 ***************************
;Name                         Addr/Register   Size   Type
;_spi_transfer                       IMPORT  -----   function
;res1                                  IX-2      1   variable
;i                                     IX-1      1   variable


; Stack Frame Size: 8 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "SD_readRes1",45,"_SD_readRes1"
;   46	
;   47	void SD_readRes7(BYTE *res) {
_SD_readRes7:
.DEFINE "_SD_readRes7"

.VALUE _SD_readRes7

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "SD_readRes7",47,"_SD_readRes7"

.LINE 47

.DEFINE "res"

.CLASS 65

.VALUE 6

.TYPE 44

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   48	    res[0] = SD_readRes1();
.LINE 48

	CALL	_SD_readRes1
	LD	HL,(IX+%6)
	LD	(HL),A
;   49	
;   50	    // if error reading R1, return
;   51	    if(res[0] > 1) return;
.LINE 51

	LD	HL,(IX+%6)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,1
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_9
;   52	
;   53	    // read remaining bytes
;   54	    res[1] = spi_transfer(0xFF);
.LINE 54

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
	LD	HL,(IX+%6)
	INC	HL
	LD	(HL),A
;   55	    res[2] = spi_transfer(0xFF);
.LINE 55

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
	LD	IY,(IX+%6)
	LEA	HL,IY+%2
	LD	(HL),A
;   56	    res[3] = spi_transfer(0xFF);
.LINE 56

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
	LD	IY,(IX+%6)
	LEA	HL,IY+%3
	LD	(HL),A
;   57	    res[4] = spi_transfer(0xFF);
.LINE 57

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
	LD	IY,(IX+%6)
	LEA	HL,IY+%4
	LD	(HL),A
;   58	}
L_9:
.LINE 58

	LD	SP,IX
	POP	IX
	RET	


;**************************** _SD_readRes7 ***************************
;Name                         Addr/Register   Size   Type
;_spi_transfer                       IMPORT  -----   function
;_SD_readRes1                        IMPORT  -----   function
;res                                   IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "SD_readRes7",58,"_SD_readRes7"
;   59	
;   60	BYTE SD_goIdleState() {
_SD_goIdleState:
.DEFINE "_SD_goIdleState"

.VALUE _SD_goIdleState

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "SD_goIdleState",60,"_SD_goIdleState"

.LINE 60

.DEFINE "res1"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
;   61		BYTE res1;
;   62	//  printf("SD_goIdleState()\n");
;   63	    spi_transfer(0xFF);
.LINE 63

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;   64	    SD_CS_enable();
.LINE 64

	CALL	_SD_CS_enable
;   65	    spi_transfer(0xFF);
.LINE 65

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;   66	    SD_command(CMD0, CMD0_ARG, CMD0_CRC);
.LINE 66

	LD	BC,148
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	PUSH	BC
	CALL	_SD_command
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;   67	    res1 = SD_readRes1();
.LINE 67

	CALL	_SD_readRes1
	LD	(IX+%FFFFFFFF),A
;   68	    spi_transfer(0xFF);
.LINE 68

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;   69	    SD_CS_disable();
.LINE 69

	CALL	_SD_CS_disable
;   70	    spi_transfer(0xFF);
.LINE 70

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;   71	    return res1;
.LINE 71

	LD	A,(IX+%FFFFFFFF)
;   72	}
.LINE 72

	LD	SP,IX
	POP	IX
	RET	


;**************************** _SD_goIdleState ***************************
;Name                         Addr/Register   Size   Type
;_SD_CS_disable                      IMPORT  -----   function
;_SD_readRes1                        IMPORT  -----   function
;_SD_command                         IMPORT  -----   function
;_SD_CS_enable                       IMPORT  -----   function
;_spi_transfer                       IMPORT  -----   function
;res1                                  IX-1      1   variable


; Stack Frame Size: 7 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "SD_goIdleState",72,"_SD_goIdleState"
;   73	
;   74	void SD_sendIfCond(BYTE *res) {
_SD_sendIfCond:
.DEFINE "_SD_sendIfCond"

.VALUE _SD_sendIfCond

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "SD_sendIfCond",74,"_SD_sendIfCond"

.LINE 74

.DEFINE "res"

.CLASS 65

.VALUE 6

.TYPE 44

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   75	//  printf("SD_sendIfCond()\n");
;   76	    spi_transfer(0xFF);
.LINE 76

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;   77	    SD_CS_enable();
.LINE 77

	CALL	_SD_CS_enable
;   78	    spi_transfer(0xFF);
.LINE 78

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;   79	    SD_command(CMD8, CMD8_ARG, CMD8_CRC);
.LINE 79

	LD	BC,134
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,426
	PUSH	BC
	LD	BC,8
	PUSH	BC
	CALL	_SD_command
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;   80	    SD_readRes7(res);
.LINE 80

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_SD_readRes7
	POP	BC
;   81	    spi_transfer(0xFF);
.LINE 81

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;   82	    SD_CS_disable();
.LINE 82

	CALL	_SD_CS_disable
;   83	    spi_transfer(0xFF);
.LINE 83

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;   84	}
.LINE 84

	LD	SP,IX
	POP	IX
	RET	


;**************************** _SD_sendIfCond ***************************
;Name                         Addr/Register   Size   Type
;_SD_CS_disable                      IMPORT  -----   function
;_SD_readRes7                        IMPORT  -----   function
;_SD_command                         IMPORT  -----   function
;_SD_CS_enable                       IMPORT  -----   function
;_spi_transfer                       IMPORT  -----   function
;res                                   IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "SD_sendIfCond",84,"_SD_sendIfCond"
;   85	
;   86	UINT8 SD_sendApp() {
_SD_sendApp:
.DEFINE "_SD_sendApp"

.VALUE _SD_sendApp

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "SD_sendApp",86,"_SD_sendApp"

.LINE 86

.DEFINE "res1"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
;   87		BYTE res1;
;   88	//	printf("SD_sendApp()\n");
;   89	    spi_transfer(0xFF);
.LINE 89

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;   90	    SD_CS_enable();
.LINE 90

	CALL	_SD_CS_enable
;   91	    spi_transfer(0xFF);
.LINE 91

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;   92	    SD_command(CMD55, CMD55_ARG, CMD55_CRC);
.LINE 92

	LD	BC,0
	PUSH	BC
	PUSH	BC
	PUSH	BC
	LD	BC,55
	PUSH	BC
	CALL	_SD_command
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;   93	    res1 = SD_readRes1();
.LINE 93

	CALL	_SD_readRes1
	LD	(IX+%FFFFFFFF),A
;   94	    spi_transfer(0xFF);
.LINE 94

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;   95	    SD_CS_disable();
.LINE 95

	CALL	_SD_CS_disable
;   96	    spi_transfer(0xFF);
.LINE 96

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;   97	    return res1;
.LINE 97

	LD	A,(IX+%FFFFFFFF)
;   98	}
.LINE 98

	LD	SP,IX
	POP	IX
	RET	


;**************************** _SD_sendApp ***************************
;Name                         Addr/Register   Size   Type
;_SD_CS_disable                      IMPORT  -----   function
;_SD_readRes1                        IMPORT  -----   function
;_SD_command                         IMPORT  -----   function
;_SD_CS_enable                       IMPORT  -----   function
;_spi_transfer                       IMPORT  -----   function
;res1                                  IX-1      1   variable


; Stack Frame Size: 7 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "SD_sendApp",98,"_SD_sendApp"
;   99	
;  100	UINT8 SD_sendOpCond() {
_SD_sendOpCond:
.DEFINE "_SD_sendOpCond"

.VALUE _SD_sendOpCond

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "SD_sendOpCond",100,"_SD_sendOpCond"

.LINE 100

.DEFINE "res1"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
;  101		BYTE res1;
;  102	//  printf("SD_sendOpCond()\n");
;  103	    spi_transfer(0xFF);
.LINE 103

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;  104	    SD_CS_enable();
.LINE 104

	CALL	_SD_CS_enable
;  105	    spi_transfer(0xFF);
.LINE 105

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;  106	    SD_command(ACMD41, ACMD41_ARG, ACMD41_CRC);
.LINE 106

	LD	BC,0
	PUSH	BC
	LD	BC,64
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,41
	PUSH	BC
	CALL	_SD_command
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  107	    res1 = SD_readRes1();
.LINE 107

	CALL	_SD_readRes1
	LD	(IX+%FFFFFFFF),A
;  108	    spi_transfer(0xFF);
.LINE 108

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;  109	    SD_CS_disable();
.LINE 109

	CALL	_SD_CS_disable
;  110	    spi_transfer(0xFF);
.LINE 110

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;  111	    return res1;
.LINE 111

	LD	A,(IX+%FFFFFFFF)
;  112	}
.LINE 112

	LD	SP,IX
	POP	IX
	RET	


;**************************** _SD_sendOpCond ***************************
;Name                         Addr/Register   Size   Type
;_SD_CS_disable                      IMPORT  -----   function
;_SD_readRes1                        IMPORT  -----   function
;_SD_command                         IMPORT  -----   function
;_SD_CS_enable                       IMPORT  -----   function
;_spi_transfer                       IMPORT  -----   function
;res1                                  IX-1      1   variable


; Stack Frame Size: 7 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "SD_sendOpCond",112,"_SD_sendOpCond"
;  113	
;  114	void SD_readOCR(BYTE *res) {
_SD_readOCR:
.DEFINE "_SD_readOCR"

.VALUE _SD_readOCR

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "SD_readOCR",114,"_SD_readOCR"

.LINE 114

.DEFINE "res"

.CLASS 65

.VALUE 6

.TYPE 44

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  115	//  printf("SD_readOCR()\n");
;  116	    spi_transfer(0xFF);
.LINE 116

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;  117	    SD_CS_enable();
.LINE 117

	CALL	_SD_CS_enable
;  118	    spi_transfer(0xFF);
.LINE 118

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;  119	    SD_command(CMD58, CMD58_ARG, CMD58_CRC);
.LINE 119

	LD	BC,0
	PUSH	BC
	PUSH	BC
	PUSH	BC
	LD	BC,58
	PUSH	BC
	CALL	_SD_command
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  120	    SD_readRes7(res);
.LINE 120

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_SD_readRes7
	POP	BC
;  121	    spi_transfer(0xFF);
.LINE 121

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;  122	    SD_CS_disable();
.LINE 122

	CALL	_SD_CS_disable
;  123	    spi_transfer(0xFF);
.LINE 123

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;  124	}
.LINE 124

	LD	SP,IX
	POP	IX
	RET	


;**************************** _SD_readOCR ***************************
;Name                         Addr/Register   Size   Type
;_SD_CS_disable                      IMPORT  -----   function
;_SD_readRes7                        IMPORT  -----   function
;_SD_command                         IMPORT  -----   function
;_SD_CS_enable                       IMPORT  -----   function
;_spi_transfer                       IMPORT  -----   function
;res                                   IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "SD_readOCR",124,"_SD_readOCR"
;  125	
;  126	void SD_powerUpSeq() {
_SD_powerUpSeq:
.DEFINE "_SD_powerUpSeq"

.VALUE _SD_powerUpSeq

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "SD_powerUpSeq",126,"_SD_powerUpSeq"

.LINE 126

.DEFINE "i"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
;  127		int i;
;  128	//  printf("SD_powerUpSeq()\n");
;  129	    SD_CS_disable();
.LINE 129

	CALL	_SD_CS_disable
;  130		wait_timer0();
.LINE 130

	CALL	_wait_timer0
;  131		spi_transfer(0xFF);
.LINE 131

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;  132	    SD_CS_disable();
.LINE 132

	CALL	_SD_CS_disable
;  133		for(i = 0; i < SD_INIT_CYCLES; i++) {
.LINE 133

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	JR	L_18
L_16:
;  134	        spi_transfer(0xFF);
.LINE 134

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
;  135		}
L_18:
.LINE 135

	LD	BC,10
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_16
;  136	}
.LINE 136

	LD	SP,IX
	POP	IX
	RET	


;**************************** _SD_powerUpSeq ***************************
;Name                         Addr/Register   Size   Type
;_spi_transfer                       IMPORT  -----   function
;_wait_timer0                        IMPORT  -----   function
;_SD_CS_disable                      IMPORT  -----   function
;i                                     IX-3      3   variable


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "SD_powerUpSeq",136,"_SD_powerUpSeq"
;  137	
;  138	BYTE SD_readBlocks(DWORD addr, BYTE *buf, WORD count) {
_SD_readBlocks:
.DEFINE "_SD_readBlocks"

.VALUE _SD_readBlocks

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "SD_readBlocks",138,"_SD_readBlocks"

.LINE 138

.DEFINE "addr"

.CLASS 65

.VALUE 6

.TYPE 15

.ENDEF

.DEFINE "buf"

.CLASS 65

.VALUE 12

.TYPE 44

.ENDEF

.DEFINE "count"

.CLASS 65

.VALUE 15

.TYPE 13

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -3

.TYPE 14

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -4

.TYPE 12

.ENDEF

.DEFINE "token"

.CLASS 65

.VALUE -5

.TYPE 12

.ENDEF

.DEFINE "ptr"

.CLASS 65

.VALUE -8

.TYPE 44

.ENDEF

.DEFINE "sector"

.CLASS 65

.VALUE -12

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF4
	LD	SP,HL
;  139		DWORD	sector = addr;
.LINE 139

	LD	BC,(IX+%6)
	LD	A,(IX+%9)
	LD	(IX+%FFFFFFF4),BC
	LD	(IX+%FFFFFFF7),A
;  140		BYTE	res;
;  141		BYTE	token;
;  142		BYTE *	ptr = buf;
.LINE 142

	LD	BC,(IX+%C)
	LD	(IX+%FFFFFFF8),BC
;  143		UINT	i;
;  144	
;  145		for(i = 0; i < count; i++) {
.LINE 145

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	JR	L_27
L_25:
;  146			res = SD_readSingleBlock(sector, ptr, &token);
.LINE 146

	PEA	IX+%FFFFFFFB
	LD	BC,(IX+%FFFFFFF8)
	PUSH	BC
	LD	C,(IX+%FFFFFFF7)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFF4)
	PUSH	BC
	CALL	_SD_readSingleBlock
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFC),A
;  147			if(SD_R1_NO_ERROR(res) && (token == 0xFE)) {
.LINE 147

	CP	A,%2
	JR	NC,L_24
	LD	A,(IX+%FFFFFFFB)
	CP	A,%FE
	JR	NZ,L_24
;  148				sector++;
.LINE 148

	LD	HL,(IX+%FFFFFFF4)
	LD	E,(IX+%FFFFFFF7)
	LD	A,%1
	CALL	__ladd_b
	LD	(IX+%FFFFFFF4),HL
	LD	(IX+%FFFFFFF7),E
;  149				ptr += SD_BLOCK_LEN;
.LINE 149

	LD	BC,512
	LD	HL,(IX+%FFFFFFF8)
	ADD	HL,BC
	LD	(IX+%FFFFFFF8),HL
;  150			}
;  151			else {
.LINE 151

	JR	L_26
L_24:
;  152				return SD_ERROR;
.LINE 152

	LD	A,%1
	JR	L_29
;  153			}
;  154		}	
L_26:
.LINE 154

	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
L_27:
	LD	BC,(IX+%F)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	C,L_25
;  155		return SD_SUCCESS;
.LINE 155

	XOR	A,A
;  156	}
L_29:
.LINE 156

	LD	SP,IX
	POP	IX
	RET	


;**************************** _SD_readBlocks ***************************
;Name                         Addr/Register   Size   Type
;_SD_readSingleBlock                 IMPORT  -----   function
;sector                               IX-12      4   variable
;ptr                                   IX-8      3   variable
;token                                 IX-5      1   variable
;res                                   IX-4      1   variable
;i                                     IX-3      3   variable
;count                                IX+15      2   parameter
;buf                                  IX+12      3   parameter
;addr                                  IX+6      4   parameter


; Stack Frame Size: 30 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "SD_readBlocks",156,"_SD_readBlocks"
;  157	
;  158	BYTE SD_writeBlocks(DWORD addr, BYTE *buf, WORD count) {
_SD_writeBlocks:
.DEFINE "_SD_writeBlocks"

.VALUE _SD_writeBlocks

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "SD_writeBlocks",158,"_SD_writeBlocks"

.LINE 158

.DEFINE "addr"

.CLASS 65

.VALUE 6

.TYPE 15

.ENDEF

.DEFINE "buf"

.CLASS 65

.VALUE 12

.TYPE 44

.ENDEF

.DEFINE "count"

.CLASS 65

.VALUE 15

.TYPE 13

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -3

.TYPE 14

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -4

.TYPE 12

.ENDEF

.DEFINE "token"

.CLASS 65

.VALUE -5

.TYPE 12

.ENDEF

.DEFINE "ptr"

.CLASS 65

.VALUE -8

.TYPE 44

.ENDEF

.DEFINE "sector"

.CLASS 65

.VALUE -12

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF4
	LD	SP,HL
;  159		DWORD	sector = addr;
.LINE 159

	LD	BC,(IX+%6)
	LD	A,(IX+%9)
	LD	(IX+%FFFFFFF4),BC
	LD	(IX+%FFFFFFF7),A
;  160		BYTE	res;
;  161		BYTE	token;
;  162		BYTE *	ptr = buf;
.LINE 162

	LD	BC,(IX+%C)
	LD	(IX+%FFFFFFF8),BC
;  163		UINT	i;
;  164	
;  165		for(i = 0; i < count; i++) {
.LINE 165

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	JR	L_37
L_35:
;  166			res = SD_writeSingleBlock(sector, ptr, &token);
.LINE 166

	PEA	IX+%FFFFFFFB
	LD	BC,(IX+%FFFFFFF8)
	PUSH	BC
	LD	C,(IX+%FFFFFFF7)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFF4)
	PUSH	BC
	CALL	_SD_writeSingleBlock
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFC),A
;  167			if(res == 0x00 && token == SD_DATA_ACCEPTED) {
.LINE 167

	OR	A,A
	JR	NZ,L_34
	LD	A,(IX+%FFFFFFFB)
	CP	A,%5
	JR	NZ,L_34
;  168				sector++;
.LINE 168

	LD	HL,(IX+%FFFFFFF4)
	LD	E,(IX+%FFFFFFF7)
	LD	A,%1
	CALL	__ladd_b
	LD	(IX+%FFFFFFF4),HL
	LD	(IX+%FFFFFFF7),E
;  169				ptr += SD_BLOCK_LEN;
.LINE 169

	LD	BC,512
	LD	HL,(IX+%FFFFFFF8)
	ADD	HL,BC
	LD	(IX+%FFFFFFF8),HL
;  170			}
;  171			else {
.LINE 171

	JR	L_36
L_34:
;  172				return SD_ERROR;
.LINE 172

	LD	A,%1
	JR	L_39
;  173			}
;  174		}	
L_36:
.LINE 174

	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
L_37:
	LD	BC,(IX+%F)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	C,L_35
;  175		return SD_SUCCESS;	
.LINE 175

	XOR	A,A
;  176	}
L_39:
.LINE 176

	LD	SP,IX
	POP	IX
	RET	


;**************************** _SD_writeBlocks ***************************
;Name                         Addr/Register   Size   Type
;_SD_writeSingleBlock                IMPORT  -----   function
;sector                               IX-12      4   variable
;ptr                                   IX-8      3   variable
;token                                 IX-5      1   variable
;res                                   IX-4      1   variable
;i                                     IX-3      3   variable
;count                                IX+15      2   parameter
;buf                                  IX+12      3   parameter
;addr                                  IX+6      4   parameter


; Stack Frame Size: 30 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "SD_writeBlocks",176,"_SD_writeBlocks"
;  177	
;  178	BYTE SD_writeSingleBlock(DWORD addr, BYTE *buf, BYTE *token) {
_SD_writeSingleBlock:
.DEFINE "_SD_writeSingleBlock"

.VALUE _SD_writeSingleBlock

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "SD_writeSingleBlock",178,"_SD_writeSingleBlock"

.LINE 178

.DEFINE "addr"

.CLASS 65

.VALUE 6

.TYPE 15

.ENDEF

.DEFINE "buf"

.CLASS 65

.VALUE 12

.TYPE 44

.ENDEF

.DEFINE "token"

.CLASS 65

.VALUE 15

.TYPE 44

.ENDEF

.DEFINE "readAttempts"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -3

.TYPE 13

.ENDEF

.DEFINE "read"

.CLASS 65

.VALUE -4

.TYPE 12

.ENDEF

.DEFINE "res1"

.CLASS 65

.VALUE -5

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
	DEC	SP
;  179	    BYTE	res1;
;  180		BYTE 	readAttempts;
;  181		BYTE	read = 0x00;
.LINE 181

	LD	(IX+%FFFFFFFC),%0
;  182		WORD	i;
;  183		//
;  184	    // Set token to none
;  185		//
;  186	    *token = 0xFF;
.LINE 186

	LD	HL,(IX+%F)
	LD	(HL),%FF
;  187		//
;  188	    // Assert chip select
;  189		//
;  190	    spi_transfer(0xFF);
.LINE 190

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;  191		SD_CS_enable();
.LINE 191

	CALL	_SD_CS_enable
;  192	    spi_transfer(0xFF);
.LINE 192

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;  193		//
;  194	    // Send CMD24
;  195		//
;  196	    SD_command(CMD24, addr, CMD24_CRC);
.LINE 196

	LD	BC,0
	PUSH	BC
	LD	C,(IX+%9)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	LD	BC,24
	PUSH	BC
	CALL	_SD_command
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  197		//
;  198	    // Read response
;  199		//
;  200	    res1 = SD_readRes1();
.LINE 200

	CALL	_SD_readRes1
	LD	(IX+%FFFFFFFB),A
;  201	
;  202	    // If no error
;  203	    if(res1 == SD_READY) {
.LINE 203

	OR	A,A
	JR	NZ,L_54
;  204			//
;  205	        // Send start token
;  206			//
;  207	        spi_transfer(SD_START_TOKEN);
.LINE 207

	LD	BC,254
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;  208	
;  209	        // Write buffer to card
;  210			//
;  211	        for(i = 0; i < SD_BLOCK_LEN; i++) {
.LINE 211

	LD	(IX+%FFFFFFFD),%0
	LD	(IX+%FFFFFFFE),%0
	JR	L_43
L_41:
;  212				spi_transfer(buf[i]);
.LINE 212

	LD	BC,(IX+%FFFFFFFD)
	CALL	__stoiu
	LD	BC,(IX+%C)
	ADD	HL,BC
	LD	C,(HL)
	LD	B,%0
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
	LD	HL,(IX+%FFFFFFFD)
	INC	HL
	LD	(IX+%FFFFFFFD),L
	LD	(IX+%FFFFFFFE),H
;  213			}
L_43:
.LINE 213

	LD.LIS	BC,512
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_41
;  214			//
;  215	        // Wait for a response (timeout = 250ms)
;  216			//
;  217	        readAttempts = 0;
.LINE 217

	LD	(IX+%FFFFFFFF),%0
;  218	        while(++readAttempts != SD_MAX_WRITE_ATTEMPTS)
.LINE 218

	JR	L_46
L_47:
;  219	            if((read = spi_transfer(0xFF)) != 0xFF) {
.LINE 219

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
	LD	(IX+%FFFFFFFC),A
	CP	A,%FF
	JR	Z,L_46
;  220					*token = 0xFF;
.LINE 220

	LD	HL,(IX+%F)
	LD	(HL),%FF
;  221					break;
.LINE 221

	JR	L_52
;  222				}
L_46:
.LINE 222

	INC	(IX+%FFFFFFFF)
	LD	A,(IX+%FFFFFFFF)
	UEXT	HL
	LD	L,A
	LD	BC,3907
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_47
L_52:
;  223			//
;  224	        // If data accepted
;  225			//
;  226	        if((read & 0x1F) == 0x05) {
.LINE 226

	LD	A,(IX+%FFFFFFFC)
	AND	A,%1F
	CP	A,%5
	JR	NZ,L_54
;  227				//
;  228	            // Set token to data accepted
;  229				//
;  230	            *token = 0x05;
.LINE 230

	LD	HL,(IX+%F)
	LD	(HL),%5
;  231				//
;  232	            // Wait for write to finish (timeout = 250ms)
;  233				//
;  234	            readAttempts = 0;
.LINE 234

	LD	(IX+%FFFFFFFF),%0
;  235	            while(spi_transfer(0xFF) == 0x00) {
.LINE 235

	JR	L_49
L_50:
;  236	                if(++readAttempts == SD_MAX_WRITE_ATTEMPTS) {
.LINE 236

	INC	(IX+%FFFFFFFF)
	LD	A,(IX+%FFFFFFFF)
	UEXT	HL
	LD	L,A
	LD	BC,3907
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_49
;  237						*token = 0x00;
.LINE 237

	LD	HL,(IX+%F)
	LD	(HL),%0
;  238						break;
.LINE 238

	JR	L_54
;  239					}
;  240				}
L_49:
.LINE 240

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
	OR	A,A
	JR	Z,L_50
;  241	        }
;  242	    }
L_54:
.LINE 242

;  243		//
;  244	    // Deassert chip select
;  245		//
;  246	    spi_transfer(0xFF);
.LINE 246

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;  247	    SD_CS_disable();
.LINE 247

	CALL	_SD_CS_disable
;  248	    spi_transfer(0xFF);
.LINE 248

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;  249	
;  250	    return res1;	
.LINE 250

	LD	A,(IX+%FFFFFFFB)
;  251	}
.LINE 251

	LD	SP,IX
	POP	IX
	RET	


;**************************** _SD_writeSingleBlock ***************************
;Name                         Addr/Register   Size   Type
;_SD_CS_disable                      IMPORT  -----   function
;_SD_readRes1                        IMPORT  -----   function
;_SD_command                         IMPORT  -----   function
;_SD_CS_enable                       IMPORT  -----   function
;_spi_transfer                       IMPORT  -----   function
;res1                                  IX-5      1   variable
;read                                  IX-4      1   variable
;i                                     IX-3      2   variable
;readAttempts                          IX-1      1   variable
;token                                IX+15      3   parameter
;buf                                  IX+12      3   parameter
;addr                                  IX+6      4   parameter


; Stack Frame Size: 23 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "SD_writeSingleBlock",251,"_SD_writeSingleBlock"
;  252	
;  253	BYTE SD_readSingleBlock(DWORD addr, BYTE *buf, BYTE *token)
;  254	{
_SD_readSingleBlock:
.DEFINE "_SD_readSingleBlock"

.VALUE _SD_readSingleBlock

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "SD_readSingleBlock",254,"_SD_readSingleBlock"

.LINE 254

.DEFINE "addr"

.CLASS 65

.VALUE 6

.TYPE 15

.ENDEF

.DEFINE "buf"

.CLASS 65

.VALUE 12

.TYPE 44

.ENDEF

.DEFINE "token"

.CLASS 65

.VALUE 15

.TYPE 44

.ENDEF

.DEFINE "read"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -3

.TYPE 13

.ENDEF

.DEFINE "readAttempts"

.CLASS 65

.VALUE -5

.TYPE 13

.ENDEF

.DEFINE "res1"

.CLASS 65

.VALUE -6

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
;  255	    BYTE	res1;
;  256		BYTE	read = 0x00;
.LINE 256

	LD	(IX+%FFFFFFFF),%0
;  257	    WORD	readAttempts, i;
;  258		//
;  259	    // Set token to none
;  260		//
;  261	    *token = 0xFF;
.LINE 261

	LD	HL,(IX+%F)
	LD	(HL),%FF
;  262		//
;  263	    // Assert chip select
;  264		//
;  265	    spi_transfer(0xFF);
.LINE 265

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;  266	    SD_CS_enable();
.LINE 266

	CALL	_SD_CS_enable
;  267	    spi_transfer(0xFF);
.LINE 267

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;  268		//
;  269	    // Send CMD17
;  270		//
;  271	    SD_command(CMD17, addr, CMD17_CRC);
.LINE 271

	LD	BC,0
	PUSH	BC
	LD	C,(IX+%9)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	LD	BC,17
	PUSH	BC
	CALL	_SD_command
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  272		//
;  273	    // Read R1
;  274		//
;  275	    res1 = SD_readRes1();
.LINE 275

	CALL	_SD_readRes1
	LD	(IX+%FFFFFFFA),A
;  276		//
;  277	    // If response received from card
;  278		//
;  279	    if(res1 != 0xFF) {
.LINE 279

	CP	A,%FF
	JR	Z,L_69
;  280			//
;  281	        // Wait for a response token (timeout = 100ms)
;  282			//
;  283	        readAttempts = 0;
.LINE 283

	LD	(IX+%FFFFFFFB),%0
	LD	(IX+%FFFFFFFC),%0
;  284	        while(++readAttempts != SD_MAX_READ_ATTEMPTS) 
.LINE 284

	JR	L_57
L_58:
;  285	            if((read = spi_transfer(0xFF)) != 0xFF)
.LINE 285

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
	LD	(IX+%FFFFFFFF),A
	CP	A,%FF
	JR	NZ,L_66
;  286					break;
L_57:
.LINE 286

	LD	HL,(IX+%FFFFFFFB)
	INC	HL
	LD	(IX+%FFFFFFFB),L
	LD	(IX+%FFFFFFFC),H
	LD.LIS	BC,1563
	LD	HL,(IX+%FFFFFFFB)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_58
L_66:
;  287			//
;  288	        // If response token is 0xFE
;  289			//
;  290	        if(read == SD_START_TOKEN) {
.LINE 290

	LD	A,(IX+%FFFFFFFF)
	CP	A,%FE
	JR	NZ,L_67
;  291				//
;  292	            // Read 512 byte block
;  293				//
;  294	            for(i = 0; i < SD_BLOCK_LEN; i++) {
.LINE 294

	LD	(IX+%FFFFFFFD),%0
	LD	(IX+%FFFFFFFE),%0
	JR	L_63
L_61:
;  295					*buf++ = spi_transfer(0xFF);
.LINE 295

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
	LD	HL,(IX+%C)
	LD	(HL),A
	LD	BC,(IX+%C)
	INC	BC
	LD	(IX+%C),BC
	LD	HL,(IX+%FFFFFFFD)
	INC	HL
	LD	(IX+%FFFFFFFD),L
	LD	(IX+%FFFFFFFE),H
;  296				}
L_63:
.LINE 296

	LD.LIS	BC,512
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_61
;  297				//
;  298	            // Read 16-bit CRC
;  299				//
;  300	            spi_transfer(0xFF);
.LINE 300

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;  301	            spi_transfer(0xFF);
.LINE 301

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;  302	        }
L_67:
.LINE 302

;  303			//
;  304	        // Set token to card response
;  305			//
;  306	        *token = read;
.LINE 306

	LD	HL,(IX+%F)
	LD	A,(IX+%FFFFFFFF)
	LD	(HL),A
;  307	    }
L_69:
.LINE 307

;  308		//
;  309	    // Deassert chip select
;  310		//
;  311	    spi_transfer(0xFF);
.LINE 311

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;  312	    SD_CS_disable();
.LINE 312

	CALL	_SD_CS_disable
;  313	    spi_transfer(0xFF);
.LINE 313

	LD	BC,255
	PUSH	BC
	CALL	_spi_transfer
	POP	BC
;  314	
;  315	    return res1;
.LINE 315

	LD	A,(IX+%FFFFFFFA)
;  316	}
.LINE 316

	LD	SP,IX
	POP	IX
	RET	


;**************************** _SD_readSingleBlock ***************************
;Name                         Addr/Register   Size   Type
;_SD_CS_disable                      IMPORT  -----   function
;_SD_readRes1                        IMPORT  -----   function
;_SD_command                         IMPORT  -----   function
;_SD_CS_enable                       IMPORT  -----   function
;_spi_transfer                       IMPORT  -----   function
;res1                                  IX-6      1   variable
;readAttempts                          IX-5      2   variable
;i                                     IX-3      2   variable
;read                                  IX-1      1   variable
;token                                IX+15      3   parameter
;buf                                  IX+12      3   parameter
;addr                                  IX+6      4   parameter


; Stack Frame Size: 24 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "SD_readSingleBlock",316,"_SD_readSingleBlock"
;  317	
;  318	BYTE SD_init(void) {
_SD_init:
.DEFINE "_SD_init"

.VALUE _SD_init

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "SD_init",318,"_SD_init"

.LINE 318

.DEFINE "cmdAttempts"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -6

.DIM 5

.TYPE 108

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
;  319		BYTE res[5], cmdAttempts = 0;
.LINE 319

	LD	(IX+%FFFFFFFF),%0
;  320	
;  321		init_timer0(10, 16, 0x00);  // 10ms timer for delay
.LINE 321

	LD	BC,0
	PUSH	BC
	LD	BC,16
	PUSH	BC
	LD	BC,10
	PUSH	BC
	CALL	_init_timer0
	POP	BC
	POP	BC
	POP	BC
;  322	
;  323		SD_powerUpSeq();
.LINE 323

	CALL	_SD_powerUpSeq
;  324		//
;  325	    // Command card to idle
;  326		//
;  327	    while((res[0] = SD_goIdleState()) != 0x01) {
.LINE 327

	JR	L_73
L_74:
;  328	        cmdAttempts++;
.LINE 328

	INC	(IX+%FFFFFFFF)
;  329	        if(cmdAttempts > 10) return SD_ERROR;
.LINE 329

	LD	A,%A
	CP	A,(IX+%FFFFFFFF)
	JR	NC,L_73
	LD	A,%1
	JR	L_90
;  330	    }
L_73:
.LINE 330

	CALL	_SD_goIdleState
	LD	(IX+%FFFFFFFA),A
	UEXT	HL
	LD	L,A
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_74
;  331		//
;  332	    // Send interface conditions
;  333		//
;  334	    SD_sendIfCond(res);
.LINE 334

	PEA	IX+%FFFFFFFA
	CALL	_SD_sendIfCond
	POP	BC
;  335	    if(res[0] != 0x01) {
.LINE 335

	LD	A,(IX+%FFFFFFFA)
	UEXT	HL
	LD	L,A
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	Z,L_78
;  336	        return SD_ERROR;
.LINE 336

	LD	A,%1
	JR	L_90
;  337	    }
L_78:
.LINE 337

;  338		//
;  339	    // Check echo pattern
;  340		//
;  341	    if(res[4] != 0xAA) {
.LINE 341

	LEA	HL,IX+%FFFFFFFE
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,170
	OR	A,A
	SBC	HL,BC
	JR	Z,L_79
;  342	        return SD_ERROR;
.LINE 342

	LD	A,%1
	JR	L_90
;  343	    }
L_79:
.LINE 343

;  344		//
;  345	    // Attempt to initialize card
;  346		//
;  347	    cmdAttempts = 0;
.LINE 347

	LD	(IX+%FFFFFFFF),%0
;  348	    do {
L_85:
.LINE 348

;  349	        if(cmdAttempts > 100) return SD_ERROR;
.LINE 349

	LD	A,%64
	CP	A,(IX+%FFFFFFFF)
	JR	NC,L_81
	LD	A,%1
	JR	L_90
L_81:
;  350			//
;  351	        // Send app cmd
;  352			//
;  353	        res[0] = SD_sendApp();
.LINE 353

	CALL	_SD_sendApp
	LD	(IX+%FFFFFFFA),A
;  354			//
;  355	        // If no error in response
;  356			//
;  357	        if(res[0] < 2) {
.LINE 357

	UEXT	HL
	LD	L,A
	LD	BC,2
	OR	A,A
	SBC	HL,BC
	JP	P,L_83
;  358	            res[0] = SD_sendOpCond();
.LINE 358

	CALL	_SD_sendOpCond
	LD	(IX+%FFFFFFFA),A
;  359	        }
L_83:
.LINE 359

;  360			//
;  361	        // Wait
;  362			//
;  363	        wait_timer0();
.LINE 363

	CALL	_wait_timer0
;  364	        cmdAttempts++;
.LINE 364

	INC	(IX+%FFFFFFFF)
;  365	    }
;  366	    while(res[0] != SD_READY);
.LINE 366

	LD	A,(IX+%FFFFFFFA)
	OR	A,A
	JR	NZ,L_85
;  367		//
;  368	    // Read OCR
;  369		//
;  370	    SD_readOCR(res);
.LINE 370

	PEA	IX+%FFFFFFFA
	CALL	_SD_readOCR
	POP	BC
;  371	    //
;  372	    // Disable 10ms timer
;  373	    //
;  374	   	enable_timer0(0);
.LINE 374

	LD	BC,0
	PUSH	BC
	CALL	_enable_timer0
	POP	BC
;  375		//
;  376	    // Check card is ready
;  377		//
;  378	    if(!(res[1] & 0x80)) return SD_ERROR;
.LINE 378

	LEA	HL,IX+%FFFFFFFA
	INC	HL
	LD	A,(HL)
	AND	A,%80
	JR	NZ,L_89
	LD	A,%1
	JR	L_90
L_89:
;  379	
;  380	    return SD_SUCCESS;	
.LINE 380

	XOR	A,A
;  381	}
L_90:
.LINE 381

	LD	SP,IX
	POP	IX
	RET	


;**************************** _SD_init ***************************
;Name                         Addr/Register   Size   Type
;_enable_timer0                      IMPORT  -----   function
;_SD_readOCR                         IMPORT  -----   function
;_wait_timer0                        IMPORT  -----   function
;_SD_sendOpCond                      IMPORT  -----   function
;_SD_sendApp                         IMPORT  -----   function
;_SD_sendIfCond                      IMPORT  -----   function
;_SD_goIdleState                     IMPORT  -----   function
;_SD_powerUpSeq                      IMPORT  -----   function
;_init_timer0                        IMPORT  -----   function
;res                                   IX-6      5   variable
;cmdAttempts                           IX-1      1   variable


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "SD_init",381,"_SD_init"
	XREF _wait_timer0:ROM
	XREF _enable_timer0:ROM
	XREF _init_timer0:ROM
	XREF _SD_CS_disable:ROM
	XREF _SD_CS_enable:ROM
	XREF _spi_transfer:ROM
	XREF __lshru:ROM
	XREF __stoiu:ROM
	XREF __setflag:ROM
	XREF __ladd_b:ROM
	XDEF _SD_init
	XDEF _SD_readSingleBlock
	XDEF _SD_writeSingleBlock
	XDEF _SD_writeBlocks
	XDEF _SD_readBlocks
	XDEF _SD_powerUpSeq
	XDEF _SD_readOCR
	XDEF _SD_sendOpCond
	XDEF _SD_sendApp
	XDEF _SD_sendIfCond
	XDEF _SD_goIdleState
	XDEF _SD_readRes7
	XDEF _SD_readRes1
	XDEF _SD_command
	END
